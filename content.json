{"meta":{"title":"哲锄","subtitle":"用智慧耕耘人生","description":null,"author":"zhechu","url":"https://zhechu.github.io"},"pages":[{"title":"","date":"2023-11-05T09:54:17.017Z","updated":"2020-11-03T13:04:34.291Z","comments":true,"path":"googlee46c0dc224c61087.html","permalink":"https://zhechu.github.io/googlee46c0dc224c61087.html","excerpt":"","text":"google-site-verification: googlee46c0dc224c61087.html"},{"title":"404","date":"2019-03-26T15:45:39.000Z","updated":"2020-11-03T13:04:34.051Z","comments":true,"path":"404/index.html","permalink":"https://zhechu.github.io/404/index.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404"},{"title":"关于","date":"2019-03-26T15:45:39.000Z","updated":"2023-11-03T16:12:37.413Z","comments":true,"path":"about/index.html","permalink":"https://zhechu.github.io/about/index.html","excerpt":"","text":"哲锄 90后 Java 程序员一枚，7年开发经验，坐标广州，目标成为系统架构设计师。"},{"title":"分类","date":"2019-03-26T15:42:00.000Z","updated":"2020-11-03T13:04:34.291Z","comments":true,"path":"categories/index.html","permalink":"https://zhechu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"RedisLua实现限流","slug":"RedisLua实现限流","date":"2023-11-10T17:08:21.000Z","updated":"2023-11-10T17:55:11.016Z","comments":false,"path":"2023/11/11/RedisLua实现限流/","link":"","permalink":"https://zhechu.github.io/2023/11/11/RedisLua实现限流/","excerpt":"","text":"示例代码https://github.com/zhechu/redisLuaLimitDemo/tree/master/redisLuaLimitDemo lua 脚本1234567891011121314local c-- 获取调用脚本时传入的第一个参数值（限流大小）c = redis.call(&apos;get&apos;,KEYS[1])-- 超过阈值，则直接返回if c and tonumber(c) &gt; tonumber(ARGV[1]) then return c;end-- 执行计算器自加c = redis.call(&apos;incr&apos;,KEYS[1])-- 从第一次调用开始限流，设置对应键值的过期if tonumber(c) == 1 then redis.call(&apos;expire&apos;,KEYS[1],ARGV[2])endreturn c; 集成SpringBootpom.xml 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.11&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;redis.lua.limit&lt;/groupId&gt; &lt;artifactId&gt;redisLuaLimitDemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;redisLuaLimitDemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.properties配置123spring.redis.host=127.0.0.1spring.redis.port=6379 控制层1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.zhechu.limit.controller;import com.zhechu.limit.annotate.Limit;import com.zhechu.limit.enums.LimitType;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.atomic.AtomicInteger;@RestControllerpublic class LimiterController &#123; private static final AtomicInteger ATOMIC_INTEGER_1 = new AtomicInteger(); private static final AtomicInteger ATOMIC_INTEGER_2 = new AtomicInteger(); private static final AtomicInteger ATOMIC_INTEGER_3 = new AtomicInteger(); /** * 自定义限流key，限制10秒请求3次 * @return */ @Limit(key = \"limitTest\", period = 10, count = 3) @GetMapping(\"/limitTest1\") public int testLimiter1() &#123; return ATOMIC_INTEGER_1.incrementAndGet(); &#125; /** * 自定义限流key，限制10秒请求3次 * @return */ @Limit(key = \"customer_limit_test\", period = 10, count = 3, limitType = LimitType.CUSTOMER) @GetMapping(\"/limitTest2\") public int testLimiter2() &#123; return ATOMIC_INTEGER_2.incrementAndGet(); &#125; /** * 使用访问IP作为限流key，限制10秒请求3次 * @return */ @Limit(period = 10, count = 3, limitType = LimitType.IP) @GetMapping(\"/limitTest3\") public int testLimiter3() &#123; return ATOMIC_INTEGER_3.incrementAndGet(); &#125;&#125; 切面层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129package com.zhechu.limit.config;import com.google.common.collect.ImmutableList;import com.zhechu.limit.annotate.Limit;import org.apache.commons.lang3.StringUtils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.script.DefaultRedisScript;import org.springframework.data.redis.core.script.RedisScript;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import com.zhechu.limit.enums.LimitType;import javax.servlet.http.HttpServletRequest;import java.io.Serializable;import java.lang.reflect.Method;/** * 限流切面实现 */@Aspect@Configurationpublic class LimitInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(LimitInterceptor.class); private static final String UNKNOWN = \"unknown\"; private final RedisTemplate&lt;String, Serializable&gt; limitRedisTemplate; @Autowired public LimitInterceptor(RedisTemplate&lt;String, Serializable&gt; limitRedisTemplate) &#123; this.limitRedisTemplate = limitRedisTemplate; &#125; /** * 限流拦截 * @param pjp * @return */ @Around(\"execution(public * *(..)) &amp;&amp; @annotation(com.zhechu.limit.annotate.Limit)\") public Object interceptor(ProceedingJoinPoint pjp) &#123; MethodSignature signature = (MethodSignature) pjp.getSignature(); Method method = signature.getMethod(); Limit limitAnnotation = method.getAnnotation(Limit.class); LimitType limitType = limitAnnotation.limitType(); String name = limitAnnotation.name(); String key; int limitPeriod = limitAnnotation.period(); int limitCount = limitAnnotation.count(); /** * 根据限流类型获取不同的key ,如果不传我们会以方法名作为key */ switch (limitType) &#123; case IP: key = getIpAddress(); break; case CUSTOMER: key = limitAnnotation.key(); break; default: key = StringUtils.upperCase(method.getName()); &#125; ImmutableList&lt;String&gt; keys = ImmutableList.of(StringUtils.join(limitAnnotation.prefix(), key)); try &#123; String luaScript = buildLuaScript(); RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(luaScript, Long.class); Long count = limitRedisTemplate.execute(redisScript, keys, limitCount, limitPeriod); logger.info(\"Access try count is &#123;&#125; for name=&#123;&#125; and key = &#123;&#125;\", count, name, key); if (count != null &amp;&amp; count.intValue() &lt;= limitCount) &#123; return pjp.proceed(); &#125; else &#123; throw new RuntimeException(\"You have been dragged into the blacklist\"); &#125; &#125; catch (Throwable e) &#123; if (e instanceof RuntimeException) &#123; throw new RuntimeException(e.getLocalizedMessage()); &#125; throw new RuntimeException(\"server exception\"); &#125; &#125; /** * 构造限流脚本 * @return */ public String buildLuaScript() &#123; StringBuilder lua = new StringBuilder(); lua.append(\"local c\"); lua.append(\"\\nc = redis.call('get',KEYS[1])\"); // 超过阈值，则直接返回 lua.append(\"\\nif c and tonumber(c) &gt; tonumber(ARGV[1]) then\"); lua.append(\"\\nreturn c;\"); lua.append(\"\\nend\"); // 执行计算器自加 lua.append(\"\\nc = redis.call('incr',KEYS[1])\"); lua.append(\"\\nif tonumber(c) == 1 then\"); // 从第一次调用开始限流，设置对应键值的过期 lua.append(\"\\nredis.call('expire',KEYS[1],ARGV[2])\"); lua.append(\"\\nend\"); lua.append(\"\\nreturn c;\"); return lua.toString(); &#125; public String getIpAddress() &#123; HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); String ip = request.getHeader(\"x-forwarded-for\"); if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"WL-Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || UNKNOWN.equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip; &#125;&#125; 配置层123456789101112131415161718192021222324package com.zhechu.limit.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.io.Serializable;@Configurationpublic class RedisLimiterHelper &#123; @Bean public RedisTemplate&lt;String, Serializable&gt; limitRedisTemplate(LettuceConnectionFactory redisConnectionFactory) &#123; RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;&gt;(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; &#125;&#125; 自定义限流注解123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.zhechu.limit.annotate;import com.zhechu.limit.enums.LimitType;import java.lang.annotation.*;/** * 限流注解 */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Limit &#123; /** * 名字 */ String name() default \"\"; /** * key，限流类型为请求 ip 时可为空 */ String key() default \"\"; /** * Key的前缀 */ String prefix() default \"\"; /** * 给定的时间范围 单位(秒) */ int period(); /** * 一定时间内最多访问次数 */ int count(); /** * 限流的类型(用户自定义key 或者 请求ip) */ LimitType limitType() default LimitType.CUSTOMER;&#125; 限流类型1234567891011121314151617package com.zhechu.limit.enums;/** * 限流类型 */public enum LimitType &#123; /** * 自定义key */ CUSTOMER, /** * 请求者IP */ IP;&#125; 测试预期：连续请求3次均可以成功，第4次请求被拒绝。 请求地址：http://127.0.0.1:8080/limitTest1","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"限流","slug":"限流","permalink":"https://zhechu.github.io/tags/限流/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"Redis缓存读写策略","slug":"Redis缓存读写策略","date":"2023-11-10T00:33:46.000Z","updated":"2023-11-10T01:10:13.231Z","comments":false,"path":"2023/11/10/Redis缓存读写策略/","link":"","permalink":"https://zhechu.github.io/2023/11/10/Redis缓存读写策略/","excerpt":"","text":"1 Cache Aside Pattern（旁路缓存模式）适合读多写少场景，服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。 写： 先更新 db 然后直接删除 cache 。 读： 从 cache 中读取数据，读取到就直接返回 cache 中读取不到的话，就从 db 中读取数据返回 再把数据放到 cache 中。 1.1 缺点 首次请求数据一定不在 cache 预热：将热点数据提前放入 cache 中。 频繁写操作导致 cache 中的数据会被频繁被删除，存在数据不一致风险 db 和 cache 强一致：写（1和2步骤）和读（2和3步骤）时加分布式读写锁（读写和写写互斥、读读不互斥） 允许短暂不一致：更新 db 的同时更新 cache，但是给缓存加一个较短的过期时间 2 Read/Write Through Pattern（读写穿透）服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。 适用于高并发的数据，但又允许丢失的场景，如社交软件的评论功能。 写： 先查 cache，cache 中不存在，直接更新 db。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。 读： 从 cache 中读取数据，读取到就直接返回。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。 3 Write Behind Pattern（异步缓存写入）Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。 但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。 很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。 这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。 Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"EMS系统订单数据同步","slug":"EMS系统订单数据同步","date":"2023-11-03T14:05:41.000Z","updated":"2023-11-09T00:27:45.912Z","comments":false,"path":"2023/11/03/EMS系统订单数据同步/","link":"","permalink":"https://zhechu.github.io/2023/11/03/EMS系统订单数据同步/","excerpt":"","text":"需求将EMS系统的订单表数据近实时地同步到供应链平台 背景EMS系统比较成熟，可提供订单表的API查询接口；供应链平台目前还在迭代开发中 方案使用定时任务，通过API接口调用的方式，定期从EMS系统获取新增和更新的订单数据同步到供应链平台 API查询接口设计请求参数：供应链平台最大的订单号、供应链平台提供订单表最后的更新时间返回参数：订单数据列表（返回前已去重，尽量减少网络开销）返回数据上限：1万条（假设1条订单数据100Byte，1万条就是1MB） 同步订单数据流程： 获取新增和更新的订单：供应链平台提供最大的订单号（主键，一般设置为数值类型，并且递增）可以获取到EMS新增的订单；供应链平台提供订单表最后的更新时间（需包含，或者设置更小，因为时间只能精确到秒，以免丢失数据）可以获取到EMS更新的订单 将获取到的订单数据列表去重 在落库的时候需要保证幂等性（若不存在此订单，则执行插入操作；若存在此订单且更新时间比数据库的要新，则更新，否则忽略） 定时任务设计选型：使用XXL-JOB分布式定时任务系统 任务参数：通过XXL-JOB的后台管理系统编辑页面传入供应链平台最大的订单号和供应链平台提供订单表最后的更新时间两个参数，若不传则会从供应链平台的订单表拿到，若表数据为空，则使用默认值（订单号最小值为0，更新时间默认为100年前） 任务定时设计：通过XXL-JOB可以方便定制适合的频度 优化 第一次同步的数据量较大，有条件的可以手工进行同步 收集监控日志 EMS系统和供应链平台建立长连接，减少网络开销（如：使用WebSocket实现长连接通信）","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"数据同步","slug":"数据同步","permalink":"https://zhechu.github.io/tags/数据同步/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql业务日志分表设计","slug":"Mysql业务日志分表设计","date":"2021-06-23T01:03:09.000Z","updated":"2021-06-23T02:16:45.123Z","comments":false,"path":"2021/06/23/Mysql业务日志分表设计/","link":"","permalink":"https://zhechu.github.io/2021/06/23/Mysql业务日志分表设计/","excerpt":"","text":"需求：需近实时统计用户日活 背景：因项目成本及复杂度等，且项目处于初期，暂时无法引入第三方分析平台（如：神策） 方案：服务端提供埋点接口，以接收客户端上传的埋点数据，并将埋点数据异步落库。且提供日活统计接口，以满足消费端统计日活需求 1 设计接收埋点数据流程 TIPS：日活统计接口则是先读取缓存中的日表数据，然后聚合统计（此处也有提前聚合优化，不再展开） 1.1 Mysql 日表设计表名格式1active_user_log_&lt;日期时间戳&gt; TIPS：如：active_user_log_20210623 1.2 Redis 日表设计键格式1active_user_log_&lt;日期时间戳&gt; TIPS：如：active_user_log_20210623。聚合设计不再展开 2 优化由于日活统计需求后面变得比较多样，分表后难以按月、周、日维度统计，且日活数据越来越多。因此引入ClickHouse统一解决类似报表需求。 Mysql到ClickHouse同步方案","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"https://zhechu.github.io/tags/分库分表/"},{"name":"日志","slug":"日志","permalink":"https://zhechu.github.io/tags/日志/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"ClickHouse实现排行榜","slug":"ClickHouse实现排行榜","date":"2021-06-22T10:23:32.000Z","updated":"2021-06-22T10:30:40.376Z","comments":false,"path":"2021/06/22/ClickHouse实现排行榜/","link":"","permalink":"https://zhechu.github.io/2021/06/22/ClickHouse实现排行榜/","excerpt":"","text":"MySQL 初始化数据123456789101112131415CREATE TABLE saas_test_tenant.user_score ( id int(11) NOT NULL, score int(11), PRIMARY KEY (id));INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (0, 7);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (1, 1);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (2, 2);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (5, 5);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (6, 3);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (7, 4);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (8, 9);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (9, 9);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (10, 8);INSERT INTO grid_university_test_tenant.user_score(id, score) VALUES (11, 4); 同步数据到 ClickHousescript1$ /usr/bin/clickhouse-client --host 192.168.1.225 -u test --password admin123 --query=\"CREATE TABLE if not exists saas_test_tenant.user_score ENGINE = ReplacingMergeTree ORDER BY id AS SELECT * FROM mysql('192.168.1.154:3306', 'saas_test_tenant', 'user_score', 'root', '123456')\" 实现按 score 排行12345678910111213141516171819202122232425SELECT id, score, row_number, dense_rank, uniq_rankFROM ( SELECT groupArray(id) AS id, groupArray(score) AS arr_val, arrayEnumerate(arr_val) AS row_number, arrayEnumerateDense(arr_val) AS dense_rank, arrayEnumerateUniq(arr_val) AS uniq_rank FROM ( SELECT * FROM saas_test_tenant.user_score ORDER BY score ASC ) ) ARRAY JOIN id, arr_val AS score, row_number, dense_rank, uniq_rankORDER BY row_number ASC, dense_rank ASC","categories":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}],"tags":[{"name":"SQL优化","slug":"SQL优化","permalink":"https://zhechu.github.io/tags/SQL优化/"}],"keywords":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}]},{"title":"Mysql到ClickHouse同步方案","slug":"Mysql到ClickHouse同步方案","date":"2021-06-22T10:06:36.000Z","updated":"2021-06-22T10:27:59.822Z","comments":false,"path":"2021/06/22/Mysql到ClickHouse同步方案/","link":"","permalink":"https://zhechu.github.io/2021/06/22/Mysql到ClickHouse同步方案/","excerpt":"","text":"1 基于 synch redis 同步方案官方文档 https://github.com/long2ice/synch/blob/dev/README-zh.md 解压安装包 synch-0.7.1.zipscript1$ unzip synch-0.7.1.zip 数据库必须进行 bin log 相关配置 略 部署 Redis 6.2.4script1$ docker run --network=host --name redis -d redis:6.2.4 根据需求配置同步表数据script123$ cd synch-0.7.1$ cp synch.yaml synch.yaml.default$ vi synch.yaml script12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576core: debug: true # when set True, will display sql information. insert_num: 1 # how many num to submit,recommend set 20000 when production insert_interval: 1 # how many seconds to submit,recommend set 60 when production # enable this will auto create database `synch` in ClickHouse and insert monitor data monitoring: truesentry: environment: development dsn:redis: host: 192.168.180.78 port: 6379 db: 0 password: prefix: synch sentinel: false # enable redis sentinel sentinel_hosts: # redis sentinel hosts - 127.0.0.1:5000 - 127.0.0.1:5001 - 127.0.0.1:5002 sentinel_master: master queue_max_len: 200000 # stream max len, will delete redundant ones with FIFOsource_dbs: - db_type: mysql alias: mysql_db # must be unique broker_type: redis # current support redis and kafka server_id: 1 host: 192.168.1.154 port: 3306 user: root password: \"123456\" # optional, auto get from `show master status` when empty init_binlog_file: # optional, auto get from `show master status` when empty init_binlog_pos: skip_dmls: # dmls to skip skip_delete_tables: # tables skip delete, format with schema.table skip_update_tables: # tables skip update, format with schema.table databases: - database: saas_test_tenant auto_create: true tables: - table: information_info skip_decimal: false auto_full_etl: true clickhouse_engine: ReplacingMergeTree sign_column: sign - table: information_type skip_decimal: false auto_full_etl: true clickhouse_engine: ReplacingMergeTree sign_column: sign - table: information_history skip_decimal: false auto_full_etl: true clickhouse_engine: ReplacingMergeTree sign_column: sign - database: integral_test_tenant auto_create: true tables: - table: integral_total skip_decimal: false auto_full_etl: true clickhouse_engine: ReplacingMergeTree sign_column: signclickhouse: hosts: - 192.168.1.225:9000 user: test password: 'admin123' cluster_name: distributed_suffix: _all TIPS：同步 saas_test_tenant 和 integral_test_tenant 的相关表到 192.168.1.225 的 ClickHouse 中 配置订阅命令script12$ cp docker-compose.yml docker-compose.yml.default$ vi docker-compose.yml script1234567891011121314151617version: '3'services: producer: image: long2ice/synch command: synch --alias mysql_db produce volumes: - ./synch.yaml:/synch/synch.yaml consumer.saas_test_tenant: image: long2ice/synch command: synch --alias mysql_db consume --schema saas_test_tenant volumes: - ./synch.yaml:/synch/synch.yaml consumer.integral_test_tenant: image: long2ice/synch command: synch --alias mysql_db consume --schema integral_test_tenant volumes: - ./synch.yaml:/synch/synch.yaml 启动同步服务script1$ docker-compose up -d 查询 ClickHouse 是否已有数据12345678SELECT &apos;资讯总数&apos; AS type_name, count( * ) AS information_count, &apos;100%&apos; AS information_count_rateFROM saas_test_tenant.information_infoWHERE tenant_id = &apos;97c281870bf74eedba196d998f49ff7f&apos; 查看监控日志1select * from synch.log 2 基于命令行客户端同步方案 TIPS：基于此方案同步日表，并使用ClickHouse合并表机制作聚合查询 官方合并表使用文档 https://clickhouse.tech/docs/zh/engines/table-engines/special/merge/ 同步日表脚本script12$ mkdir -p /usr/local/job$ vi /usr/local/job/job.sh script12345#!/bin/bashexport YESTERDAY=`date \"+%Y%m%d\" -d \"-1day\"`echo $(date \"+%F %T\")' start job' &gt;&gt; /usr/local/job/job.log/usr/bin/clickhouse-client --host 192.168.1.225 -u test --password admin123 --multiquery -q \"create database if not exists saas_test_tenant;CREATE TABLE if not exists saas_test_tenant.active_user_log_$YESTERDAY ENGINE = ReplacingMergeTree ORDER BY id AS SELECT * FROM mysql('192.168.1.154:3306', 'saas_test_tenant', 'active_user_log_$YESTERDAY', 'root', '123456');\" &gt;&gt; /usr/local/job/job.logecho $(date \"+%F %T\")' end job' &gt;&gt; /usr/local/job/job.log script1$ chmod +x /usr/local/job/job.sh 设置定时每天 0 点 30 分执行script12$ crontab -e30 0 * * * /bin/sh /usr/local/job/job.sh &gt;/dev/null 2&gt;&amp;1 &amp; 同步历史日表script1$ vi /usr/local/job/sync_history_data.sh script123456789#! /bin/bashfirst=$1second=$2while [ \"$first\" != \"$second\" ]doecho $first/usr/bin/clickhouse-client --host 192.168.1.225 -u test --password admin123 --multiquery -q \"create database if not exists saas_test_tenant;CREATE TABLE if not exists saas_test_tenant.active_user_log_$first ENGINE = ReplacingMergeTree ORDER BY id AS SELECT * FROM mysql('192.168.1.154:3306', 'saas_test_tenant', 'active_user_log_$first', 'root', '123456');\"let first=`date -d \"-1 days ago $&#123;first&#125;\" +%Y%m%d`done script12$ chmod +x /usr/local/job/sync_history_data.sh$ sh /usr/local/job/sync_history_data.sh 20201218 20210610 TIPS：不包含 20210610 创建日表归并表script1$ /usr/bin/clickhouse-client --host 192.168.1.225 -u test --password admin123 --multiquery -q \"create database if not exists saas_test_tenant;CREATE TABLE saas_test_tenant.active_user_log as saas_test_tenant.active_user_log_20210610 ENGINE=Merge('saas_test_tenant', 'active_user_log_*');\"","categories":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"},{"name":"数据同步","slug":"数据同步","permalink":"https://zhechu.github.io/tags/数据同步/"}],"keywords":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}]},{"title":"CentOS7安装ClickHouse","slug":"CentOS7安装ClickHouse","date":"2021-06-22T09:55:07.000Z","updated":"2021-06-22T10:32:17.415Z","comments":false,"path":"2021/06/22/CentOS7安装ClickHouse/","link":"","permalink":"https://zhechu.github.io/2021/06/22/CentOS7安装ClickHouse/","excerpt":"","text":"官方文档 https://clickhouse.tech/docs/zh/interfaces/third-party/gui/ 1 安装ClickHouse 20.8.3.18官方安装文档 https://clickhouse.tech/docs/zh/getting-started/install/ 2 初始化配置配置远程可连接 8123 端口script12$ vi /etc/clickhouse-server/config.xml&lt;listen_host&gt;::&lt;/listen_host&gt; 配置用户 test/admin123script12$ cp /etc/clickhouse-server/users.xml /etc/clickhouse-server/users.xml.default$ vi /etc/clickhouse-server/users.xml script12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\"?&gt;&lt;yandex&gt; &lt;profiles&gt; &lt;default&gt; &lt;max_memory_usage&gt;10000000000&lt;/max_memory_usage&gt; &lt;use_uncompressed_cache&gt;0&lt;/use_uncompressed_cache&gt; &lt;load_balancing&gt;random&lt;/load_balancing&gt; &lt;/default&gt; &lt;readonly&gt; &lt;readonly&gt;1&lt;/readonly&gt; &lt;/readonly&gt; &lt;/profiles&gt; &lt;users&gt; &lt;test&gt; &lt;password&gt;admin123&lt;/password&gt; &lt;networks incl=\"networks\" replace=\"replace\"&gt; &lt;ip&gt;::/0&lt;/ip&gt; &lt;/networks&gt; &lt;profile&gt;default&lt;/profile&gt; &lt;quota&gt;default&lt;/quota&gt; &lt;/test&gt; &lt;/users&gt; &lt;quotas&gt; &lt;default&gt; &lt;interval&gt; &lt;duration&gt;3600&lt;/duration&gt; &lt;queries&gt;0&lt;/queries&gt; &lt;errors&gt;0&lt;/errors&gt; &lt;result_rows&gt;0&lt;/result_rows&gt; &lt;read_rows&gt;0&lt;/read_rows&gt; &lt;execution_time&gt;0&lt;/execution_time&gt; &lt;/interval&gt; &lt;/default&gt; &lt;/quotas&gt;&lt;/yandex&gt; 重启服务script1$ /etc/init.d/clickhouse-server restart 检查 8123 端口是否可达script1$ ssh -v -p 8123 root@192.168.1.225 TIPS：出现 Connection established. 即可达 3 客户端3.1 命令行客户端连接本机服务script1$ /usr/bin/clickhouse-client -u test --password admin123 全量同步（表不存在ClickHouse）script1$ /usr/bin/clickhouse-client --host 192.168.1.225 -u test --password admin123 --query=\"CREATE TABLE if not exists grid_university_test_tenant.gu_information_info ENGINE = ReplacingMergeTree ORDER BY id AS SELECT * FROM mysql('192.168.1.157:3306', 'grid_university_test_tenant', 'gu_information_info', 'university', 'gu@1234A')\" 3.2 IntelliJ IDEA略","categories":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"ClickHouse","slug":"ClickHouse","permalink":"https://zhechu.github.io/categories/ClickHouse/"}]},{"title":"Mysql日志","slug":"Mysql日志","date":"2021-06-07T02:05:23.000Z","updated":"2021-06-07T02:16:30.995Z","comments":false,"path":"2021/06/07/Mysql日志/","link":"","permalink":"https://zhechu.github.io/2021/06/07/Mysql日志/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7.30 关系型数据库 general_log MySQL 执行日志 CentOS7 操作系统 查看日志是否开启1show variables like &apos;general_log&apos;; 开启日志功能1set global general_log=on; 查看日志文件保存位置1show variables like &apos;general_log_file&apos;; 设置日志文件保存位置1set global general_log_file=&apos;tmp/general.log&apos;; 查看日志输出类型 table 或 file1show variables like &apos;log_output&apos;; 设置输出类型为 file1set global log_output=&apos;file&apos;;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://zhechu.github.io/tags/日志/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"SpringBoot配置饿汉式异步线程池","slug":"SpringBoot配置饿汉式异步线程池","date":"2021-03-05T03:08:18.000Z","updated":"2021-03-05T03:35:49.021Z","comments":false,"path":"2021/03/05/SpringBoot配置饿汉式异步线程池/","link":"","permalink":"https://zhechu.github.io/2021/03/05/SpringBoot配置饿汉式异步线程池/","excerpt":"","text":"问题：普通线程池在线程池队列满时，才开始从核心线程池个数增加到最大线程池个数。一个核心的矛盾则是，若线程池的队列已满，说明待处理的任务很多（客户端发送任务的速度可能也很快），即便在队列满后线程池个数增加到最大值，那也为时已晚，因为此时请求可能更多，将队列和线程占满后只能被丢弃（如此，那配置线程池最大阈值，只能在极限场景使用；而在任务队列未满时，maxPoolSize-corePoolSize 个隐藏可用的线程只能被搁置） 方案：引入饿汉式线程池，当线程池核心线程个数达到设置的阈值时，新来的任务不会被放入线程池队列，而是会开启新线程来处理任务（前提是当前线程个数没有超过线程池最大线程个数），当线程个数达到最大线程个数时，才会把任务放入线程池队列 环境说明 环境 说明 spring-boot-1.5.x 企业应用程序框架 1 定义饿汉式线程池饿汉式线程池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;/** * 饿汉式线程池 * 当线程数达到 max size 后再放入队列 */public class EagerThreadPoolExecutor extends ThreadPoolExecutor &#123; private final AtomicInteger submittedTaskCount = new AtomicInteger(0); public EagerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, TaskQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); &#125; public int getSubmittedTaskCount() &#123; return submittedTaskCount.get(); &#125; @Override protected void afterExecute(Runnable r, Throwable t) &#123; submittedTaskCount.decrementAndGet(); &#125; /** * 当线程池核心线程个数达到设置的阈值时，新来的任务不会被放入线程池队列， * 而是会开启新线程来处理任务（前提是当前线程个数没有超过线程池最大线程个数）， * 当线程个数达到最大线程个数时，才会把任务放入线程池队列 * @param command */ @Override public void execute(Runnable command) &#123; if (command == null) &#123; throw new NullPointerException(); &#125; submittedTaskCount.incrementAndGet(); try &#123; super.execute(command); &#125; catch (RejectedExecutionException rx) &#123; final TaskQueue queue = (TaskQueue) super.getQueue(); try &#123; if (!queue.retryOffer(command, 0, TimeUnit.MILLISECONDS)) &#123; submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(\"Queue capacity is full.\", rx); &#125; &#125; catch (InterruptedException x) &#123; submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(x); &#125; &#125; catch (Throwable t) &#123; submittedTaskCount.decrementAndGet(); throw t; &#125; &#125;&#125; 支持定义线程池名称的线程工厂123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.ThreadFactory;import java.util.concurrent.atomic.AtomicInteger;public class NamedThreadFactory implements ThreadFactory &#123; protected static final AtomicInteger POOL_SEQ = new AtomicInteger(1); protected final AtomicInteger mThreadNum = new AtomicInteger(1); protected final String mPrefix; protected final boolean mDaemon; protected final ThreadGroup mGroup; public NamedThreadFactory() &#123; this(\"pool-\" + POOL_SEQ.getAndIncrement(), false); &#125; public NamedThreadFactory(String prefix) &#123; this(prefix, false); &#125; public NamedThreadFactory(String prefix, boolean daemon) &#123; mPrefix = prefix + \"-thread-\"; mDaemon = daemon; SecurityManager s = System.getSecurityManager(); mGroup = (s == null) ? Thread.currentThread().getThreadGroup() : s.getThreadGroup(); &#125; @Override public Thread newThread(Runnable runnable) &#123; String name = mPrefix + mThreadNum.getAndIncrement(); Thread ret = new Thread(mGroup, runnable, name, 0); ret.setDaemon(mDaemon); return ret; &#125; public ThreadGroup getThreadGroup() &#123; return mGroup; &#125;&#125; 线程池任务队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.RejectedExecutionException;import java.util.concurrent.TimeUnit;public class TaskQueue&lt;R extends Runnable&gt; extends LinkedBlockingQueue&lt;Runnable&gt; &#123; private static final long serialVersionUID = -2635853580887179627L; private EagerThreadPoolExecutor executor; public TaskQueue(int capacity) &#123; super(capacity); &#125; public void setExecutor(EagerThreadPoolExecutor exec) &#123; executor = exec; &#125; @Override public boolean offer(Runnable runnable) &#123; if (executor == null) &#123; throw new RejectedExecutionException(\"The task queue does not have executor!\"); &#125; int currentPoolThreadSize = executor.getPoolSize(); // have free worker. put task into queue to let the worker deal with task. if (executor.getSubmittedTaskCount() &lt; currentPoolThreadSize) &#123; return super.offer(runnable); &#125; // return false to let executor create new worker. if (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123; return false; &#125; // currentPoolThreadSize &gt;= max return super.offer(runnable); &#125; /** * retry offer task * * @param o task * @return offer success or not * @throws RejectedExecutionException if executor is terminated. */ public boolean retryOffer(Runnable o, long timeout, TimeUnit unit) throws InterruptedException &#123; if (executor.isShutdown()) &#123; throw new RejectedExecutionException(\"Executor is shutdown!\"); &#125; return super.offer(o, timeout, unit); &#125;&#125; 2 定义异步线程池属性1234567891011121314151617181920212223242526272829303132import lombok.AccessLevel;import lombok.Data;import lombok.experimental.FieldDefaults;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = \"spring.async.pool\")@Data@FieldDefaults(level = AccessLevel.PRIVATE)public class AsyncThreadPoolProperties &#123; /** * 核心线程数 线程池维护线程的最少数量，默认为1 * 若配置值等于或小于0，则使用当前可用线程数减1（最小为1） */ int corePoolSize = 1; /** * 线程池维护线程的最大数量 */ int maxPoolSize = 2; /** * 线程池维护线程所允许的空闲时间 */ int keepAliveSeconds = 60; /** * 线程池所使用的缓冲队列容量 */ int queueCapacity = 1000;&#125; 3 配置异步线程池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import core.config.properties.AsyncThreadPoolProperties;import core.thread.EagerThreadPoolExecutor;import core.thread.NamedThreadFactory;import core.thread.TaskQueue;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.concurrent.Executor;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * 异步线程池配置 */@Configuration@EnableConfigurationProperties(AsyncThreadPoolProperties.class)public class AsyncConfig &#123; @Autowired private AsyncThreadPoolProperties asyncThreadPoolProperties; @Bean public Executor asyncExecutor() &#123; // 线程池中线程的名称前缀 String name = \"asyncExecutor\"; // 核心线程的个数，如果没有设置，则使用默认的数值0 int cores = Math.max(0, asyncThreadPoolProperties.getCorePoolSize()); // 线程池中最大线程的个数 int threads = Math.max(1, Math.max(Runtime.getRuntime().availableProcessors() &gt;&gt; 1, asyncThreadPoolProperties.getMaxPoolSize())); // 线程池阻塞队列大小，如果没有设置，则使用默认的数值1 int queues = Math.max(1, asyncThreadPoolProperties.getQueueCapacity()); // 线程被回收的空闲时间值，如果没有设置，则使用默认的数值60 int alive = Math.max(60, asyncThreadPoolProperties.getKeepAliveSeconds()); TaskQueue&lt;Runnable&gt; taskQueue = new TaskQueue&lt;&gt;(queues); EagerThreadPoolExecutor executor = new EagerThreadPoolExecutor(cores, threads, alive, TimeUnit.SECONDS, taskQueue, new NamedThreadFactory(name), new ThreadPoolExecutor.CallerRunsPolicy()); taskQueue.setExecutor(executor); return executor; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"异步","slug":"异步","permalink":"https://zhechu.github.io/tags/异步/"},{"name":"线程池","slug":"线程池","permalink":"https://zhechu.github.io/tags/线程池/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"行为型-模板方法模式","slug":"行为型-模板方法模式","date":"2021-03-05T02:04:19.000Z","updated":"2021-03-05T03:04:29.025Z","comments":false,"path":"2021/03/05/行为型-模板方法模式/","link":"","permalink":"https://zhechu.github.io/2021/03/05/行为型-模板方法模式/","excerpt":"","text":"1 定义定义一个操作中的算法骨架，将部分步骤延迟到子类中实现；使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。本质是固定算法骨架。 2 结构 角色 说明 AbstractClass 抽象类，定义算法骨架和原语操作并提供算法中部分步骤的通用实现 ConcreteClass 实现类，实现算法骨架中的某些步骤，完成跟特定子类相关的功能 3 优缺点优点 代码复用 缺点 算法骨架不易升级 4 使用场景 需固定算法骨架，实现一个算法不变的部分，并将可变的行为由其子类实现 各个子类中具有公共行为，应该抽取出来，集中到公共类中实现，从而实现代码复用 需控制子类扩展的情况，模板方法模式会在特定时刻调用子类的方法，这样只允许在扩展这些方法 5 示例5.1 封装请求重试5.1.1 JDK1.8回调方式定义重试模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import exception.base.AuthenticationFailureException;import lombok.extern.slf4j.Slf4j;import org.springframework.web.client.RestClientResponseException;import java.util.function.Supplier;@Slf4jpublic abstract class BaseRpc &#123; /** * 最大重试次数 */ protected static final int MAX_RETRY = 1; /** * 发起请求，支持重试 * @param supplier lambda 表达式函数 * @return 返回请求结果 */ protected &lt;T&gt; T doRequestToSupportRetry(Supplier&lt;T&gt; supplier) &#123; boolean isRetry = false; int retry = 0; do &#123; try &#123; return supplier.get(); &#125; catch (RestClientResponseException e) &#123; isRetry = isRetry(e); if (!isRetry) &#123; throw e; &#125; // 支持重试，但重试次数已用完，则抛出权限异常 else if (retry &gt;= MAX_RETRY) &#123; throw new AuthenticationFailureException(e); &#125; &#125; &#125; while (isRetry &amp;&amp; retry++ &lt; MAX_RETRY); return null; &#125; /** * 是否支持重试 * @param e 远程调用异常 * @return 布尔值 */ protected boolean isRetry(RestClientResponseException e) &#123; boolean retry = false; // TODO 具体判断 return retry; &#125;&#125; 使用12345678910111213141516171819202122232425262728293031323334@Component@Slf4jpublic class UserRpc extends BaseRpc &#123; /** * 获取单个用户信息 * @param userName 用户名 * @return 用户信息 */ public Result&lt;User&gt; getByUserName(String userName) &#123; return doRequestToSupportRetry(() -&gt; &#123; String url = String.format( \"%s/%s/user/getByUserName\", \"http://127.0.0.1:8080\", \"userServiceName\" ); UriComponentsBuilder builder = UriComponentsBuilder .fromUriString(url) .queryParam(\"userName\", userName); ResponseEntity&lt;Result&lt;User&gt;&gt; response = restTemplate.exchange( builder.build().encode().toUri(), HttpMethod.GET, new ParameterizedTypeReference&lt;Result&lt;User&gt;&gt;() &#123;&#125; ); if (response != null) &#123; return response.getBody(); &#125; return null; &#125;); &#125;&#125; 5.2 封装分页模板5.2.1 普通分页定义分页模板，一般用于循环批量查询操作，如：缓存分批重建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.springframework.util.CollectionUtils;import java.util.List;public abstract class PageTemplate&lt;E&gt; &#123; /** * 获取分页数据 * @param page * @param pageSize * @return */ protected abstract List&lt;E&gt; select(int page, int pageSize); /** * 每页显示条数 * @return */ protected abstract int getPageSize(); /** * 分页处理 */ public void handle() &#123; int page = 1; int pageSize = getPageSize(); for (;;) &#123; List&lt;E&gt; list = select(page, pageSize); if (CollectionUtils.isEmpty(list)) &#123; break; &#125; int size = list.size(); doHandle(list); // 若不满足每页条数，则为最后一页 if (size &lt; pageSize) &#123; break; &#125; // 只要每次分页查出来的数据不为空，那就页数+1 继续查询并转换 page ++; &#125; &#125; /** * 执行具体业务逻辑 * @param list */ protected abstract void doHandle(List&lt;E&gt; list);&#125; 同步用户缓存1234567891011121314151617181920212223@Overridepublic void syncUserToCache() &#123; // 分页处理 PageTemplate&lt;User&gt; pageTemplate = new PageTemplate&lt;User&gt;() &#123; @Override protected List&lt;User&gt; select(int page, int pageSize) &#123; return userService.select(page, pageSize); &#125; @Override protected int getPageSize() &#123; return 500; &#125; @Override protected void doHandle(List&lt;User&gt; list) &#123; // TODO 具体同步逻辑 &#125; &#125;; pageTemplate.handle();&#125; 5.2.2 按索引分页按索引（数值类型）在数据库本身的存储顺序进行分页查询，效率比普通分页要高，尤其是页数超10000+时 定义分页模板，一般用于循环批量查询操作，如：缓存分批重建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.apache.commons.collections4.CollectionUtils;import java.util.List;/** * 基于上一批索引分页模板类 */public abstract class IndexPageTemplate&lt;E&gt; &#123; /** * 基于上一批索引获取分页数据 * @param lastBatchMaxId 最后一批最大ID * @param batchSize 每批数量 * @return */ protected abstract List&lt;E&gt; select(Long lastBatchMaxId, int batchSize); /** * 每批数量 * @return */ protected abstract int getBatchSize(); /** * 分页处理 */ public void handle() &#123; // 分批更新 Long lastBatchMaxId = 0L; int batchSize = getBatchSize(); for (;;) &#123; List&lt;E&gt; list = select( lastBatchMaxId, batchSize ); if (CollectionUtils.isEmpty(list)) &#123; break; &#125; doHandle(list); // 检查是否为最后一批请求，若是则结束（减少处理最后一批后又去数据库取数据判断是否结束的开销） int size = list.size(); if (size &lt; batchSize) &#123; break; &#125; lastBatchMaxId = getId(list.get(size - 1)); if (lastBatchMaxId == null) &#123; break; &#125; &#125; &#125; /** * 执行具体业务逻辑 * @param list */ protected abstract void doHandle(List&lt;E&gt; list); protected abstract Long getId(E e);&#125; 使用1234567891011121314151617181920212223242526@Overridepublic void syncUserToCache() &#123; IndexPageTemplate&lt;User&gt; indexPageTemplate = new IndexPageTemplate&lt;User&gt;() &#123; @Override protected List&lt;User&gt; select(Long lastBatchMaxId, int batchSize) &#123; return userService.select(lastBatchMaxId, batchSize); &#125; @Override protected int getBatchSize() &#123; return 500; &#125; @Override protected void doHandle(List&lt;User&gt; list) &#123; // TODO 具体同步逻辑 &#125; @Override protected Long getId(User user) &#123; return user.getUserId(); &#125; &#125;; indexPageTemplate.handle();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"封装请求唯一ID","slug":"封装请求唯一ID","date":"2021-03-05T01:18:48.000Z","updated":"2021-03-05T01:59:41.913Z","comments":false,"path":"2021/03/05/封装请求唯一ID/","link":"","permalink":"https://zhechu.github.io/2021/03/05/封装请求唯一ID/","excerpt":"","text":"问题：如何在日志文件或ELK日志平台快速搜索某次请求的相关日志 方案：封装请求唯一ID，并打印在每条日志记录中，且通过请求头或出参返回（方便拿到请求唯一ID） 环境 说明 spring-boot-1.5.x 企业应用程序框架 log4j2 日志框架 1 添加过滤器请求唯一ID过滤器，用于生成唯一ID并放入日志上下文123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import com.alibaba.fastjson.JSONObject;import com.alibaba.fastjson.serializer.SerializerFeature;import domain.ResultMsg;import util.UUIDUtil;import lombok.extern.slf4j.Slf4j;import org.slf4j.MDC;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.annotation.WebFilter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.nio.charset.StandardCharsets;@Order(0) // 在所有自定义过滤器前面@Component@WebFilter(urlPatterns = \"/*\", filterName = \"requestIdFilter\")@Slf4jpublic class RequestIdFilter implements Filter &#123; private static final String REQUEST_ID = \"RequestId\"; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse httpResponse = (HttpServletResponse) response; // 防止上游已存在请求唯一ID String requestId = httpRequest.getHeader(REQUEST_ID); if (requestId == null) &#123; requestId = UUIDUtil.getUUID(); &#125; // 将请求唯一ID放入日志上下文 MDC.put(REQUEST_ID, requestId); // 放入请求头（冗余） httpResponse.setHeader(REQUEST_ID, requestId); try &#123; RequestIdHttpServletResponseWrapper responseWrapper = new RequestIdHttpServletResponseWrapper(httpResponse); chain.doFilter(httpRequest, responseWrapper); byte[] content = responseWrapper.getContent(); if (content.length &gt; 0) &#123; String resultJson = new String(content, StandardCharsets.UTF_8); try &#123; ResultMsg resultMsg = JSONObject.parseObject(resultJson, ResultMsg.class); resultMsg.setRequestId(requestId); resultJson = JSONObject.toJSONString(resultMsg, SerializerFeature.WriteMapNullValue); content = resultJson.getBytes(StandardCharsets.UTF_8); &#125; catch (Exception e) &#123; // JSON 转换异常，表示返回的 body 不是 ResultMsg 类型格式，原封返回即可 &#125; &#125; // 写入到原始的响应 ServletOutputStream output = httpResponse.getOutputStream(); output.write(content); output.flush(); &#125; finally &#123; MDC.clear(); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; 定义请求响应代理，用于截获下游响应并将请求ID写入出参123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import javax.servlet.ServletOutputStream;import javax.servlet.WriteListener;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpServletResponseWrapper;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.PrintWriter;public class RequestIdHttpServletResponseWrapper extends HttpServletResponseWrapper &#123; private ByteArrayOutputStream output; public RequestIdHttpServletResponseWrapper(HttpServletResponse httpServletResponse) &#123; super(httpServletResponse); output = new ByteArrayOutputStream(); &#125; @Override public ServletOutputStream getOutputStream() throws IOException &#123; return new ServletOutputStream() &#123; @Override public boolean isReady() &#123; return true; &#125; @Override public void setWriteListener(WriteListener listener) &#123; &#125; @Override public void write(int b) throws IOException &#123; output.write(b); &#125; @Override public void write(byte[] b, int off, int len) throws IOException &#123; output.write(b, off, len); &#125; &#125;; &#125; @Override public PrintWriter getWriter() throws IOException &#123; return new PrintWriter(output, true); &#125; public byte[] getContent() throws IOException &#123; return output.toByteArray(); &#125;&#125; 2 修改日志配置log4j2.xml 文件的 pattern 添加 [%X{RequestId}]1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration status=\"ERROR\" monitorInterval=\"10\"&gt; &lt;Properties&gt; &lt;property name=\"LOG_PATTERN\" value=\"[%d&#123;HH:mm:ss:SSS&#125;] [%X&#123;RequestId&#125;] [%p] [%thread] - %l - %m%n\" /&gt; &lt;/Properties&gt; &lt;appenders&gt; &lt;console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"$&#123;LOG_PATTERN&#125;\" /&gt; &lt;ThresholdFilter level=\"TRACE\" onMatch=\"ACCEPT\" onMismatch=\"DENY\" /&gt; &lt;/console&gt; &lt;RollingFile name=\"RollingFileInfo\" fileName=\"../logs/university-info.log\" filePattern=\"../logs/$$&#123;date:yyyy-MM&#125;/log-%d&#123;yyyy-MM-dd&#125;-info-%i.log\"&gt; &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt; &lt;ThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\" /&gt; &lt;PatternLayout pattern=\"$&#123;LOG_PATTERN&#125;\" /&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy /&gt; &lt;SizeBasedTriggeringPolicy size=\"100 MB\" /&gt; &lt;/Policies&gt; &lt;/RollingFile&gt; &lt;Async name=\"Async\" includeLocation=\"true\" bufferSize=\"1024\"&gt; &lt;appender-ref ref=\"Console\" /&gt; &lt;appender-ref ref=\"RollingFileInfo\"/&gt; &lt;/Async&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;logger name=\"org.springframework\" level=\"ERROR\"/&gt; &lt;root level=\"ERROR\"&gt; &lt;appender-ref ref=\"Async\" /&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 3 测试验证日志打印示例123456[17:46:02:683] [af665c8d2653422c9bf6f775ead27bea] [INFO] [http-nio-8888-exec-2] - core.aspect.WebLogAspect.around(WebLogAspect.java:60) -开始------------------------------------------------------- 耗时: 20ms 链路: http://127.0.0.1:8080/test controller.TestController.test 参数: [hello]结束------------------------------------------------------- 请求出参示例1234567891011&#123; \"code\": 200, \"msg\": \"操作成功!\", \"requestId\": \"d27965161b4a4796bde15ebe205d62de\", \"data\": [ &#123; \"id\": \"f627243077214e69b62a1b60be075d81\", \"createDate\": 1614760334000 &#125; ]&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"},{"name":"日志","slug":"日志","permalink":"https://zhechu.github.io/tags/日志/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Jackson序列化优雅处理","slug":"Jackson序列化优雅处理","date":"2020-11-09T13:40:48.000Z","updated":"2020-11-09T15:52:59.358Z","comments":false,"path":"2020/11/09/Jackson序列化优雅处理/","link":"","permalink":"https://zhechu.github.io/2020/11/09/Jackson序列化优雅处理/","excerpt":"","text":"问题： 服务端接口出参返回值为 null 的参数，接口调用方难以处理（有些编程语言处理起来很复杂） 服务端接口出参返回值为大数值，接口调用方对应的编程语言丢失精度 方案： 将返回 null 的参数过滤或赋默认值（如：空字符串） 将大数值的参数转为字符串 代码示例 https://github.com/zhechu/spring-boot-rest-demo/tree/master/src/main/java/com/wise/rest/demo/config/jackson 1 序列化修改器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.BeanDescription;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.SerializationConfig;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;import java.io.IOException;import java.time.OffsetDateTime;import java.time.temporal.TemporalAccessor;import java.util.Collection;import java.util.Date;import java.util.List;public class WiseBeanSerializerModifier extends BeanSerializerModifier &#123; public List&lt;BeanPropertyWriter&gt; changeProperties(SerializationConfig config, BeanDescription beanDesc, List&lt;BeanPropertyWriter&gt; beanProperties) &#123; beanProperties.forEach((writer) -&gt; &#123; if (!writer.hasNullSerializer()) &#123; JavaType type = writer.getType(); Class&lt;?&gt; clazz = type.getRawClass(); if (type.isTypeOrSubTypeOf(Number.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.STRING_JSON_SERIALIZER); &#125; else if (type.isTypeOrSubTypeOf(Boolean.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.BOOLEAN_JSON_SERIALIZER); &#125; else if (type.isTypeOrSubTypeOf(Character.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.STRING_JSON_SERIALIZER); &#125; else if (type.isTypeOrSubTypeOf(String.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.STRING_JSON_SERIALIZER); &#125; else if (!type.isArrayType() &amp;&amp; !clazz.isArray() &amp;&amp; !type.isTypeOrSubTypeOf(Collection.class)) &#123; if (type.isTypeOrSubTypeOf(OffsetDateTime.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.STRING_JSON_SERIALIZER); &#125; else if (!type.isTypeOrSubTypeOf(Date.class) &amp;&amp; !type.isTypeOrSubTypeOf(TemporalAccessor.class)) &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.OBJECT_JSON_SERIALIZER); &#125; else &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.STRING_JSON_SERIALIZER); &#125; &#125; else &#123; writer.assignNullSerializer(WiseBeanSerializerModifier.NullJsonSerializers.ARRAY_JSON_SERIALIZER); &#125; &#125; &#125;); return super.changeProperties(config, beanDesc, beanProperties); &#125; public interface NullJsonSerializers &#123; JsonSerializer&lt;Object&gt; STRING_JSON_SERIALIZER = new JsonSerializer&lt;Object&gt;() &#123; public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeString(\"\"); &#125; &#125;; JsonSerializer&lt;Object&gt; NUMBER_JSON_SERIALIZER = new JsonSerializer&lt;Object&gt;() &#123; public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeNumber(-1); &#125; &#125;; JsonSerializer&lt;Object&gt; BOOLEAN_JSON_SERIALIZER = new JsonSerializer&lt;Object&gt;() &#123; public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeObject(Boolean.FALSE); &#125; &#125;; JsonSerializer&lt;Object&gt; ARRAY_JSON_SERIALIZER = new JsonSerializer&lt;Object&gt;() &#123; public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeStartArray(); gen.writeEndArray(); &#125; &#125;; JsonSerializer&lt;Object&gt; OBJECT_JSON_SERIALIZER = new JsonSerializer&lt;Object&gt;() &#123; public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123; gen.writeStartObject(); gen.writeEndObject(); &#125; &#125;; &#125;&#125; 2 大数值转字符串1234567891011121314151617181920212223242526272829import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.SerializerProvider;import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;import com.fasterxml.jackson.databind.ser.std.NumberSerializer;import java.io.IOException;@JacksonStdImplpublic class BigNumberSerializer extends NumberSerializer &#123; private static final long JS_NUM_MAX = 9007199254740992L; private static final long JS_NUM_MIN = -9007199254740992L; public static final BigNumberSerializer instance = new BigNumberSerializer(Number.class); public BigNumberSerializer(Class&lt;? extends Number&gt; rawType) &#123; super(rawType); &#125; public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException &#123; long longValue = value.longValue(); if (longValue &gt;= JS_NUM_MIN &amp;&amp; longValue &lt;= JS_NUM_MAX) &#123; super.serialize(value, gen, provider); &#125; else &#123; gen.writeString(value.toString()); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"},{"name":"序列化","slug":"序列化","permalink":"https://zhechu.github.io/tags/序列化/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"RSA加密防破解","slug":"RSA加密防破解","date":"2020-11-09T13:39:38.000Z","updated":"2020-11-09T15:52:59.359Z","comments":false,"path":"2020/11/09/RSA加密防破解/","link":"","permalink":"https://zhechu.github.io/2020/11/09/RSA加密防破解/","excerpt":"","text":"问题：敏感接口不能暴露参数，并防篡改，如：登录接口 方案：通过非对称算法 RSA，由接口调用端通过公钥将参数进行加密，服务端接受参数通过私钥进行解密 原理：攻击者只有审查代码，才能知晓接口入参，目的是增加其攻击成本。而且可以防止中间人篡改入参（私钥是存在服务端，不容易泄露） 1 非对称加密工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225import javax.crypto.Cipher;import java.nio.charset.StandardCharsets;import java.security.*;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;/** * 非对称加密工具类 * * @author lingyuwang * @date 2020-11-09 4:32 下午 * @since 1.0.4 */public class RSAUtil &#123; /** * 非对称密钥算法 */ private static final String ALGORITHM = \"RSA\"; /** * 密钥长度，在 512 到 65536 位之间，越长，速度越慢，生成的加密数据越长 */ private static final int KEY_SIZE = 512; /** * 生成密钥对 * @return KeyPair 密钥对 * @throws Exception */ public static KeyPair getKeyPair() throws Exception &#123; return getKeyPair(null); &#125; /** * 生成密钥对 * @param password 生成密钥对的密码 * @return 密钥对 * @throws Exception */ public static KeyPair getKeyPair(String password) throws Exception &#123; // 实例化密钥生成器 KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM); // 初始化密钥生成器 if (password == null) &#123; keyPairGenerator.initialize(KEY_SIZE); &#125; else &#123; SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\"); secureRandom.setSeed(password.getBytes(StandardCharsets.UTF_8)); keyPairGenerator.initialize(KEY_SIZE, secureRandom); &#125; return keyPairGenerator.generateKeyPair(); &#125; /** * 取取私钥 * @param keyPair 密钥对 * @return byte[] 私钥 */ public static byte[] getPrivateKeyBytes(KeyPair keyPair) &#123; return keyPair.getPrivate().getEncoded(); &#125; /** * 取取 Base64 编码的私钥 * @param keyPair 密钥对 * @return String Base64编码的私钥 */ public static String getPrivateKey(KeyPair keyPair) &#123; return Base64.getEncoder().encodeToString(getPrivateKeyBytes(keyPair)); &#125; /** * 取取公钥 * @param keyPair 密钥对 * @return byte[] 公钥 */ public static byte[] getPublicKeyBytes(KeyPair keyPair) &#123; return keyPair.getPublic().getEncoded(); &#125; /** * 取取 Base64 编码的公钥 * @param keyPair 密钥对 * @return String Base64编码的公钥 */ public static String getPublicKey(KeyPair keyPair) &#123; return Base64.getEncoder().encodeToString(getPublicKeyBytes(keyPair)); &#125; /** * 私钥加密 * @param data 待加密数据 * @param privateKey 私钥字节数组 * @return byte[] 加密数据 */ public static byte[] encryptByPrivateKey(byte[] data, byte[] privateKey) throws Exception &#123; // 实例化密钥工厂 KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM); // 生成私钥 PrivateKey key = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey)); // 数据加密 Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; /** * 私钥加密 * @param data 待加密数据 * @param privateKey Base64编码的私钥 * @return String Base64编码的加密数据 */ public static String encryptByPrivateKey(String data, String privateKey) throws Exception &#123; byte[] key = Base64.getDecoder().decode(privateKey); return Base64.getEncoder().encodeToString(encryptByPrivateKey(data.getBytes(StandardCharsets.UTF_8), key)); &#125; /** * 公钥加密 * @param data 待加密数据 * @param publicKey 公钥字节数组 * @return byte[] 加密数据 */ public static byte[] encryptByPublicKey(byte[] data, byte[] publicKey) throws Exception &#123; // 实例化密钥工厂 KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM); // 生成公钥 PublicKey key = keyFactory.generatePublic(new X509EncodedKeySpec(publicKey)); // 数据加密 Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.ENCRYPT_MODE, key); return cipher.doFinal(data); &#125; /** * 公钥加密 * @param data 待加密数据 * @param publicKey Base64编码的公钥 * @return String Base64编码的加密数据 */ public static String encryptByPublicKey(String data, String publicKey) throws Exception &#123; byte[] key = Base64.getDecoder().decode(publicKey); return Base64.getEncoder().encodeToString(encryptByPublicKey(data.getBytes(StandardCharsets.UTF_8), key)); &#125; /** * 私钥解密 * @param data 待解密数据 * @param privateKey 私钥字节数组 * @return byte[] 解密数据 */ public static byte[] decryptByPrivateKey(byte[] data, byte[] privateKey) throws Exception &#123; // 实例化密钥工厂 KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM); // 生成私钥 PrivateKey key = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey)); // 数据解密 Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(data); &#125; /** * 私钥解密 * @param data Base64编码的待解密数据 * @param privateKey Base64编码的私钥 * @return String 解密数据 */ public static String decryptByPrivateKey(String data, String privateKey) throws Exception &#123; byte[] key = Base64.getDecoder().decode(privateKey); return new String(decryptByPrivateKey(Base64.getDecoder().decode(data), key), StandardCharsets.UTF_8); &#125; /** * 公钥解密 * @param data 待解密数据 * @param publicKey 公钥字节数组 * @return byte[] 解密数据 */ public static byte[] decryptByPublicKey(byte[] data, byte[] publicKey) throws Exception &#123; // 实例化密钥工厂 KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM); // 产生公钥 PublicKey key = keyFactory.generatePublic(new X509EncodedKeySpec(publicKey)); // 数据解密 Cipher cipher = Cipher.getInstance(ALGORITHM); cipher.init(Cipher.DECRYPT_MODE, key); return cipher.doFinal(data); &#125; /** * 公钥解密 * @param data Base64编码的待解密数据 * @param publicKey Base64编码的公钥 * @return String 解密数据 */ public static String decryptByPublicKey(String data, String publicKey) throws Exception &#123; byte[] key = Base64.getDecoder().decode(publicKey); return new String(decryptByPublicKey(Base64.getDecoder().decode(data), key), StandardCharsets.UTF_8); &#125; /** * 加密模式 */ public enum Mode &#123; /** * 加密 */ ENCRYPTION(), /** * 兼容 */ COMPATIBLE(), ; &#125;&#125; 2 单元测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import lombok.extern.slf4j.Slf4j;import org.junit.Test;import java.security.KeyPair;@Slf4jpublic class RSAUtilTest &#123; @Test public void getKey() throws Exception &#123; KeyPair keyPair = RSAUtil.getKeyPair(); String publicKey = RSAUtil.getPublicKey(keyPair); log.info(\"公钥:&#123;&#125;\", publicKey); // MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIbfSsEOcHpA6j5NutN7t53ZqtIrpHIHrePN3imfWNOM88h+R0ribRvdn1QmEhqUb8+mORBDmVF9kg2L3554EiUCAwEAAQ== String privateKey = RSAUtil.getPrivateKey(keyPair); log.info(\"私钥:&#123;&#125;\", privateKey); // MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAht9KwQ5wekDqPk2603u3ndmq0iukcget483eKZ9Y04zzyH5HSuJtG92fVCYSGpRvz6Y5EEOZUX2SDYvfnngSJQIDAQABAkADb9Ex1jJbiyfs6oImPXLSXOeTb3VDSprNwUM2AE99JILheZ0hgRke/o28rjy9yz0kUnh3U74oLvgZ+vrClgVBAiEAulrlZ+TmUIk0CT0uculZORROFozIl9Oui62NEwSunskCIQC5RuQzO1WKAp3S6Uouq4/+sZfItvR+SJi3IUkvseM6fQIhAJSvKzPelMgTADqS3vl+Jtr80WT6hJ1mnnABU3qmFLDJAiBSQwGLJasDDcpZHK+NLStP4DYOLf08HKuBk8vU21ySWQIgV/3HX3bwxxcb+0Wt8T09dvz4rrQaKV9oqehJP/QzeY0= &#125; /** * 公钥加密 */ @Test public void encryptTest() throws Exception &#123; // 公钥 String publicKey = \"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIbfSsEOcHpA6j5NutN7t53ZqtIrpHIHrePN3imfWNOM88h+R0ribRvdn1QmEhqUb8+mORBDmVF9kg2L3554EiUCAwEAAQ==\"; // 参数 JSON 字符串 String paramJsonStr = \"&#123;\\\"username\\\":\\\"zhechu\\\",\\\"pwd\\\":\\\"zhechu123\\\"&#125;\"; String encrypt = RSAUtil.encryptByPublicKey(paramJsonStr, publicKey); log.info(\"encrypt:&#123;&#125;\", encrypt); &#125; /** * 私钥解密 * @throws Exception */ @Test public void decryptTest() throws Exception &#123; // 私钥 String privateKey = \"MIIBVAIBADANBgkqhkiG9w0BAQEFAASCAT4wggE6AgEAAkEAht9KwQ5wekDqPk2603u3ndmq0iukcget483eKZ9Y04zzyH5HSuJtG92fVCYSGpRvz6Y5EEOZUX2SDYvfnngSJQIDAQABAkADb9Ex1jJbiyfs6oImPXLSXOeTb3VDSprNwUM2AE99JILheZ0hgRke/o28rjy9yz0kUnh3U74oLvgZ+vrClgVBAiEAulrlZ+TmUIk0CT0uculZORROFozIl9Oui62NEwSunskCIQC5RuQzO1WKAp3S6Uouq4/+sZfItvR+SJi3IUkvseM6fQIhAJSvKzPelMgTADqS3vl+Jtr80WT6hJ1mnnABU3qmFLDJAiBSQwGLJasDDcpZHK+NLStP4DYOLf08HKuBk8vU21ySWQIgV/3HX3bwxxcb+0Wt8T09dvz4rrQaKV9oqehJP/QzeY0=\"; // 加密字符串 String encrypt = \"WB+XDRgCStNTw54ktN+qJCKo3J2xXpQtRSNfgdbo9mMd8nuaveRpPihYtF7JkX9f9eoSzVG9GG2OyaDe8dhPFA==\"; String paramJsonStr = RSAUtil.decryptByPrivateKey(encrypt, privateKey); log.info(\"paramJsonStr:&#123;&#125;\", paramJsonStr); &#125;&#125; 3 过滤器解密处理3.1 过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import com.alibaba.fastjson.JSONObject;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import java.io.BufferedReader;import java.io.IOException;import java.nio.charset.StandardCharsets;/** * RSA 解密过滤器 * * @author lingyuwang * @date 2020-11-09 3:04 下午 * @since 1.0.4 */@Component@Slf4jpublic class RsaDecryptFilter implements Filter &#123; @Autowired private RsaProperties rsaProperties; /** * 需要解密的请求 */ private static final String[] URL_PATTERNS = new String[]&#123; \"/api/wechatMiniUser/registerByCode\", \"/api/mobile/registerByCode\", \"/api/mobile/resetPasswordByCode\" &#125;; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; // 非 POST 请求则跳过 if (!StringUtils.equalsIgnoreCase(\"POST\", httpServletRequest.getMethod())) &#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; String uri = httpServletRequest.getRequestURI(); int pathLen = URL_PATTERNS.length; int i = 0; for (; i &lt; pathLen; i++) &#123; if (uri.equals(URL_PATTERNS[i])) &#123; break; &#125; if (URL_PATTERNS[i].endsWith(\"*\") &amp;&amp; uri.startsWith(URL_PATTERNS[i].replace(\"*\",\"\"))) &#123; break; &#125; &#125; // 非加密请求 if (i == pathLen) &#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; RsaDecryptHttpServletRequestWrapper rsaDecryptHttpServletRequestWrapper = new RsaDecryptHttpServletRequestWrapper(httpServletRequest); BufferedReader bufferedReader = rsaDecryptHttpServletRequestWrapper.getReader(); String encrypt = convertToString(bufferedReader); log.info(\"&#123;&#125; encrypt body:&#123;&#125;\", httpServletRequest.getRequestURI(), encrypt); // body 没有数据 if (StringUtils.isBlank(encrypt)) &#123; String defaultErrorMsg = ExceptionTypeEnum.BusinessValidationException.getDefaultErrorMsg(); Integer code = ExceptionTypeEnum.BusinessValidationException.getCode(); ResultMsg resultMsg = ResultMsg.error(code, defaultErrorMsg); servletResponse.getWriter().print(JSONObject.toJSON(resultMsg)); return; &#125; // 若是兼容模式，则判断是否需要解密 if (RSAUtil.Mode.COMPATIBLE == rsaProperties.getMode() &amp;&amp; StringUtils.startsWith(encrypt, \"&#123;\") &amp;&amp; StringUtils.endsWith(encrypt, \"&#125;\")) &#123; filterChain.doFilter(rsaDecryptHttpServletRequestWrapper, servletResponse); return; &#125; try &#123; // 解密 String decrypt = RSAUtil.decryptByPrivateKey(encrypt, rsaProperties.getPrivateKey()); log.info(\"&#123;&#125; decrypt body:&#123;&#125;\", httpServletRequest.getRequestURI(), decrypt); // 覆盖加密的数据 rsaDecryptHttpServletRequestWrapper.setBody(decrypt.getBytes(StandardCharsets.UTF_8)); &#125; catch (Exception e) &#123; log.error(\"非对称解密失败\", e); ResultMsg resultMsg = ResultMsg.error(ExceptionTypeEnum.BusinessValidationException); servletResponse.getWriter().print(JSONObject.toJSON(resultMsg)); return; &#125; filterChain.doFilter(rsaDecryptHttpServletRequestWrapper, servletResponse); &#125; @Override public void destroy() &#123; &#125; /** * 将流转成字符串 * @param br 缓冲流 * @return 字符串 */ private static String convertToString(BufferedReader br) &#123; StringBuilder sb = new StringBuilder(); try &#123; String inputLine; while ((inputLine = br.readLine()) != null) &#123; sb.append(inputLine); &#125; &#125; catch (IOException e) &#123; log.error(\"读取请求流失败\", e); &#125; finally &#123; if (br != null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; log.error(\"关闭请求流失败\", e); &#125; &#125; &#125; return sb.toString(); &#125;&#125; 3.2 请求包装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import org.springframework.util.StreamUtils;import javax.servlet.ReadListener;import javax.servlet.ServletInputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStreamReader;/** * RSA 解密请求包装 * * @author lingyuwang * @date 2020-11-09 3:09 下午 * @since 1.0.4 */public class RsaDecryptHttpServletRequestWrapper extends HttpServletRequestWrapper &#123; /** * 用于保存 body 中数据 */ private byte[] body; public RsaDecryptHttpServletRequestWrapper(HttpServletRequest request) throws IOException &#123; super(request); body = StreamUtils.copyToByteArray(request.getInputStream()); &#125; @Override public BufferedReader getReader() throws IOException &#123; return new BufferedReader(new InputStreamReader(getInputStream())); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(body); return new ServletInputStream() &#123; @Override public int read() throws IOException &#123; return byteArrayInputStream.read(); &#125; @Override public boolean isFinished() &#123; return false; &#125; @Override public boolean isReady() &#123; return false; &#125; @Override public void setReadListener(ReadListener arg0) &#123;&#125; &#125;; &#125; public void setBody(byte[] body) &#123; this.body = body; &#125;&#125; 3.3 加密属性配置123456789101112131415161718192021222324252627import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;/** * RSA 加密配置 * * @author lingyuwang * @date 2020-11-09 6:09 下午 * @since 1.0.4 */@Configuration@ConfigurationProperties(prefix = \"rsa\")@Datapublic class RsaProperties &#123; /** * 秘钥 */ private String privateKey; /** * 加密模式，默认为加密 */ private RSAUtil.Mode mode = RSAUtil.Mode.ENCRYPTION;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"},{"name":"安全","slug":"安全","permalink":"https://zhechu.github.io/tags/安全/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Github克隆加速","slug":"Github克隆加速","date":"2020-11-03T13:29:39.000Z","updated":"2020-11-03T13:32:15.959Z","comments":false,"path":"2020/11/03/Github克隆加速/","link":"","permalink":"https://zhechu.github.io/2020/11/03/Github克隆加速/","excerpt":"","text":"问题：墙内 clone github 上的项目到本地非常慢 方案：本地 git 配置 Shadowsocks 代理（前置条件是本地有 Shadowsocks 代理） 1 socks5需要确定安装的 Shadowsocks 是基于 socks5 协议代理的，需将 1080 端口修改成本地代理端口12$ git config --global http.proxy socks5://127.0.0.1:1080$ git config --global https.proxy socks5://127.0.0.1:1080 2 http需要确定安装的 Shadowsocks 是基于 http 协议代理的，需将 1081 端口修改成本地代理端口12$ git config --global http.proxy http://127.0.0.1:1081$ git config --global https.proxy https://127.0.0.1:1081 3 验证查看 git 配置12$ git config http.proxy$ git config https.proxy TIPS：可执行 git clone https://github.com/zhechu/spring-cloud-dubbo-demo.git 验证是否有加速效果 4 重置 git 配置在不需要代理时，可以重置代理设置12$ git config --global --unset http.proxy$ git config --global --unset https.proxy 查看 git 配置12$ git config http.proxy$ git config https.proxy TIPS：没有输出表示重置成功（本质是 ~/.gitconfig 配置文件删除了这两项配置）","categories":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}],"tags":[{"name":"加速器","slug":"加速器","permalink":"https://zhechu.github.io/tags/加速器/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}]},{"title":"SpringCloud&Dubbo&Nacos集成","slug":"SpringCloud-Dubbo-Nacos集成","date":"2020-08-13T14:37:10.000Z","updated":"2020-11-03T13:04:34.209Z","comments":false,"path":"2020/08/13/SpringCloud-Dubbo-Nacos集成/","link":"","permalink":"https://zhechu.github.io/2020/08/13/SpringCloud-Dubbo-Nacos集成/","excerpt":"","text":"版本说明 https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明 Spring Cloud Spring Boot Spring Cloud Alibaba Dubbo Nacos Hoxton.SR3 2.2.5.RELEASE 2.2.1.RELEASE 2.7.6 1.2.1 SpringCloud 官方文档 https://spring.io/projects/spring-cloud#learn Dubbo 官方文档 https://dubbo.apache.org/zh-cn/docs/user/quick-start.html Nacos 官方文档 https://nacos.io/zh-cn/docs/quick-start.html 参考文档 http://www.iocoder.cn/Spring-Cloud-Alibaba/Dubbo/ 示例代码 https://github.com/zhechu/spring-cloud-dubbo-demo 1 安装 Nacos基于 docker 安装123$ yum -y install git$ git clone -b 1.2.1 https://github.com/nacos-group/nacos-docker.git$ cd nacos-docker 修改镜像版本为 1.2.11234$ vi ./example/standalone-derby.yamlservices: nacos: image: nacos/nacos-server:1.2.1 启动容器1$ docker-compose -f ./example/standalone-derby.yaml up 浏览器访问 http://192.168.163.21:8848/nacos/ nacos/nacos 2 集成2.1 Nacos 配置2.1.1 添加提供者配置 123456789server.port=8090dubbo.scan.base-packages=com.wise.dubbo.provider.servicedubbo.protocol.name=dubbodubbo.protocol.port=-1dubbo.registry.address=spring-cloud://$&#123;spring.cloud.nacos.config.server-addr&#125;# 不订阅任何服务，默认订阅所有服务dubbo.cloud.subscribed-services=&apos;&apos;spring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.config.server-addr&#125;spring.main.allow-bean-definition-overriding=true 2.1.2 添加消费者配置 12345678server.port=8091dubbo.protocol.name=dubbodubbo.protocol.port=-1dubbo.registry.address=spring-cloud://$&#123;spring.cloud.nacos.config.server-addr&#125;dubbo.cloud.subscribed-services=dubbo-providerdubbo.consumer.check=falsespring.cloud.nacos.discovery.server-addr=$&#123;spring.cloud.nacos.config.server-addr&#125;spring.main.allow-bean-definition-overriding=true 2.2 示例 spring-cloud-dubbo-demo pom.xml 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;modules&gt; &lt;module&gt;dubbo-api&lt;/module&gt; &lt;module&gt;dubbo-provider&lt;/module&gt; &lt;module&gt;dubbo-consumer&lt;/module&gt; &lt;/modules&gt; &lt;groupId&gt;com.wise&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dubbo-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;spring-cloud-dubbo-demo&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Hoxton.SR3&lt;/spring-cloud.version&gt; &lt;spring-boot.version&gt;2.2.5.RELEASE&lt;/spring-boot.version&gt; &lt;spring-cloud-alibaba.version&gt;2.2.1.RELEASE&lt;/spring-cloud-alibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 2.2.1 提供者dubbo-provider pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.wise&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dubbo-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;dubbo-provider&lt;/artifactId&gt; &lt;name&gt;dubbo-provider&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wise&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 本地 bootstrap.properties 配置12345678910# Nacos 地址spring.cloud.nacos.config.server-addr=192.168.163.21:8848# 服务名，也是 Nacos 配置文件名的组成部分spring.application.name=dubbo-provider# 环境标识，也是 Nacos 配置文件名的组成部分spring.profiles.active=dev# Nacos 配置文件扩展名spring.cloud.nacos.config.file-extension=properties# 是否支持实时刷新，默认为truespring.cloud.nacos.config.refresh-enabled=true 启动类1234567891011121314151617181920import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * 启动类 * * @author lingyuwang * @date 2020-08-13 17:06 * @since 1.1.0 */@SpringBootApplication@EnableDiscoveryClientpublic class DubboProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboProviderApplication.class, args); &#125;&#125; 服务实现类123456789101112import com.wise.dubbo.api.HelloService;import org.apache.dubbo.config.annotation.Service;@Servicepublic class HelloServiceImpl implements HelloService &#123; @Override public String hello(String name) &#123; return \"Hello \" + name; &#125;&#125; 2.2.2 消费者dubbo-consumer pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.wise&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dubbo-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;artifactId&gt;dubbo-consumer&lt;/artifactId&gt; &lt;name&gt;dubbo-consumer&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.wise&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 本地 bootstrap.properties 配置12345spring.cloud.nacos.config.server-addr=192.168.163.21:8848spring.application.name=dubbo-consumerspring.profiles.active=devspring.cloud.nacos.config.file-extension=propertiesspring.cloud.nacos.config.refresh-enabled=true 启动类1234567891011121314151617181920212223import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * 启动类 * * 浏览器访问 * http://127.0.0.1:8091/hello * * @author lingyuwang * @date 2020-08-13 23:31 * @since 1.1.0 */@SpringBootApplication@EnableDiscoveryClientpublic class DubboConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DubboConsumerApplication.class, args); &#125;&#125; 控制器1234567891011121314151617import com.wise.dubbo.api.HelloService;import org.apache.dubbo.config.annotation.Reference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @Reference private HelloService helloService; @GetMapping(\"/hello\") public String hello() &#123; return helloService.hello(\"Dubbo!\"); &#125;&#125; 2.2.3 测试1$ curl http://127.0.0.1:8091/hello","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"注册中心","slug":"注册中心","permalink":"https://zhechu.github.io/tags/注册中心/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"},{"name":"配置中心","slug":"配置中心","permalink":"https://zhechu.github.io/tags/配置中心/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java代码规范","slug":"Java代码规范","date":"2020-07-31T16:26:06.000Z","updated":"2020-11-03T13:04:34.150Z","comments":false,"path":"2020/08/01/Java代码规范/","link":"","permalink":"https://zhechu.github.io/2020/08/01/Java代码规范/","excerpt":"","text":"代码示例 https://github.com/zhechu/spring-boot-rest-demo 1 分层职责 层 包路径 说明 Controller com.xxx.controller 入参和出参处理，包括校验入参和聚合出参 RPC com.xxx.rpc RPC 调用 Service com.xxx.service 具体业务处理，包括本地事务控制 Dao com.xxx.dao 持久化处理 Mapper com.xxx.dao.mapper 持久化处理，方便扩展，如：复杂查询，需手写 SQL 实现 2 领域模型 领域模型 命名方式 示例 说明 DO（Data Object） &lt;表名+DO&gt; UserDO 此对象与数据库表结构一一对应 BO（Business Object） &lt;表名+BO&gt; UserBO 业务对象，处理对象内部业务逻辑 DVO（Data Validate Object） &lt;方法名+DVO&gt; UserLoginDVO 数据校验对象 DTO（Data Transfer Object） &lt;方法名+DTO&gt; UserUpdateDTO 新增/修改入参对象 QO（Query Object） &lt;方法名+QO&gt; UserQO 查询入参对象（不与 DTO 共用，只服务查询接口） VO（Response Object） &lt;方法名+VO&gt; UserVO 返回对象 数据校验一般放在聚合层，所以DVO类切勿共享，其只服务于开放出去的接口层（一般为聚合层的Controller层） 3 注释规范3.1 IDEA 注释模板设置 新建类时的注释模板 1234567891011#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != \"\")package $&#123;PACKAGE_NAME&#125;;#end#parse(\"File Header.java\")/*** $&#123;description&#125;* @author lingyuwang* @date $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125;* @since 1.0.4**/public class $&#123;NAME&#125; &#123;&#125; 类的注释模板（快捷键为 ccmm） 1234567/** * * * @author lingyuwang * @date $date$ $time$ * @since 1.0.4 */ 方法的注释模板（快捷键为 /**）123456789* * *$params$ * @return $return$ * @author lingyuwang * @date $date$ $time$ * @since 1.0.4 */ 注意：@since 是当前版本号。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"RESTful接口设计规范","slug":"RESTful接口设计规范","date":"2020-07-27T15:35:15.000Z","updated":"2020-11-03T13:04:34.182Z","comments":false,"path":"2020/07/27/RESTful接口设计规范/","link":"","permalink":"https://zhechu.github.io/2020/07/27/RESTful接口设计规范/","excerpt":"","text":"代码示例 https://github.com/zhechu/spring-boot-rest-demo 1 接口规范 描述 路径 示例 方法 入参 返回值 添加资源 /&lt;资源名称&gt; /user POST 需添加的资源对象 资源唯一ID 批量添加 /&lt;资源名称&gt;/batch /user/batch POST 需添加的资源对象集合 资源唯一ID集合 删除资源 /&lt;资源名称&gt;/&lt;资源唯一ID&gt; /user/1 DELETE 资源唯一ID 成功删除条数 更新资源 /&lt;资源名称&gt; /user PUT 需更新的资源对象 成功更新条数 批量更新 /&lt;资源名称&gt;/batch /user/batch PUT 需更新的资源对象集合 成功更新条数 单条查询 /&lt;资源名称&gt;/&lt;资源唯一ID&gt; /user/3 GET 资源唯一ID 资源对象 单条查询 /&lt;资源名称&gt;/&lt;另一资源唯一属性名称&gt;/&lt;资源属性值&gt; /user/username/zhangsan GET 资源属性值 资源对象 批量查询 /&lt;资源名称&gt; /user GET 筛选条件对象 资源对象集合 上述基本遵循 RESTful 接口设计规范，但为了实用，有部分扩展 添加资源返回资源唯一ID，方便接口调用者再次发起请求获取资源（若有需要） 批量删除和更新操作返回成功操作条数，是为了兼容某些框架，并方便提示调用者 批量删除可以复用删除资源接口，将资源唯一ID替换为资源唯一ID加逗号分割（若非必不得已，切勿设计批量删除接口，或者批量数据设计不应超过100条），如：/user/1,2,3 批量查询需满足按分页查询和不按分页查询两种情况，当分页入参 pageIndex=-1&amp;pageSize=-1 时，则不按分页查询，但需控制最多返回条数（如：每次最多返回1000条） 若返回的资源对象存在 Long 类型属性，转为 JSON 格式时需是字符串，以免造成精度丢失（如：JavaScript 存不下 Long 类型长度数值）；入参对象若存在 Long 类型属性，要求客户端请求时传字符串（可以使用统一的编解码器处理） 2 入参示例包含 Long 和 Date 类型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import lombok.Data;import org.hibernate.validator.constraints.Range;import org.hibernate.validator.constraints.ScriptAssert;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.Size;import java.util.Date;/** * 查询活动参数校验类 * * @author lingyuwang * @date 2020-07-10 10:23 * @since 1.1.3.0 */@Data@ScriptAssert( lang = \"javascript\", script = \"_this.luckDrawStartTime == null || _this.luckDrawEndTime == null || _this.luckDrawStartTime.getTime() &lt;= _this.luckDrawEndTime.getTime()\", message = \"抽奖开始时间不能大于抽奖结束时间\")public class ActivityBatchGetDVO extends PageBase &#123; /** * 活动ID */ @Range private Long activityId; /** * 用户名称 */ @Size(max = 20, message = \"用户名称不能超过20个字符\") private String userName; /** * 抽奖开始时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date luckDrawStartTime; /** * 抽奖结束时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date luckDrawEndTime;&#125; 客户端传字符串时，是可以转 Long 类型的（SpringBoot框架已提供支持） 3 出参示例包含 Long 和 Date 类型12345678910111213141516171819202122import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.databind.annotation.JsonSerialize;import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;import lombok.Data;import java.io.Serializable;import java.util.Date;@Datapublic class UserVO implements Serializable &#123; private static final long serialVersionUID = -4205425299355062593L; @JsonSerialize(using = ToStringSerializer.class) private Long userId; private String name; @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\") private Date createTime;&#125; 4 使用 GET 方法实现批量查询SpringBoot使用GET请求实现多条件查询","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Git提交规范","slug":"Git提交规范","date":"2020-07-27T14:51:26.000Z","updated":"2020-11-03T13:04:34.083Z","comments":false,"path":"2020/07/27/Git提交规范/","link":"","permalink":"https://zhechu.github.io/2020/07/27/Git提交规范/","excerpt":"","text":"提交时间点：单个功能开发完，且单元测试成功之后，按照功能点提交 注释格式：前缀 + “:” + 功能点描述 提交步骤：commit（本地提交一个或多个） -&gt; pull（若有冲突需要谨慎解决） -&gt; push 提交步骤反例：pull（此时本地代码还未commit，开发工具可能会自动合并代码，导致部分代码丢失） -&gt; commit -&gt; push 前缀 说明 提交示例 feature 新功能 feature:用户登录接口 fix 修复 BUG fix:单点登录接口入参校验BUG test 添加测试用例 test:用户注册 refactor 重构 refactor:分页插件 revert 恢复到某个提交点 revert:fix:单点登录接口入参校验BUG","categories":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}]},{"title":"微服务内部调用规范","slug":"微服务内部调用规范","date":"2020-07-26T04:17:14.000Z","updated":"2020-11-03T13:04:34.286Z","comments":false,"path":"2020/07/26/微服务内部调用规范/","link":"","permalink":"https://zhechu.github.io/2020/07/26/微服务内部调用规范/","excerpt":"","text":"目标：规范微服务各层之间调用，提高系统扩展性、可维护性和性能（各层职责分明，引入多线程，甚至可以提高系统吞吐量） 流程 说明 过滤器/拦截器 -&gt; 事件总线 示例：实时拦截非法请求，发邮件/短信通知相关人员 控制器 -&gt; 事件总线 示例：收集用户行为数据（需判断请求是否成功，适合在此层处理），并通过异步持久化到磁盘 服务层 -&gt; 事件总线 示例：解耦同层间调用（同层调用容易混乱，且存在循环依赖风险），支持同步和异步方式 事件总线 -&gt; 消息中间件发送出口 禁止控制层/服务层直接调用消息中间件API，将调用远程API的各种异常统一交给消息中间件发送出口处理（如消息发送降级处理） 消息中间件监听入口 -&gt; 事件总线 可以做消息幂等处理（消息幂等不属于消息中间件职责）","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"},{"name":"架构","slug":"架构","permalink":"https://zhechu.github.io/tags/架构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Mysql工具集","slug":"Mysql工具集","date":"2020-06-30T16:13:08.000Z","updated":"2020-11-03T13:04:34.172Z","comments":false,"path":"2020/07/01/Mysql工具集/","link":"","permalink":"https://zhechu.github.io/2020/07/01/Mysql工具集/","excerpt":"","text":"1 pt-kill2 pt-query-digest3 gh-ost官方文档 https://github.com/github/gh-ost","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zhechu.github.io/tags/工具/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql配置优化","slug":"Mysql配置优化","date":"2020-06-29T15:25:07.000Z","updated":"2020-11-03T13:04:34.179Z","comments":false,"path":"2020/06/29/Mysql配置优化/","link":"","permalink":"https://zhechu.github.io/2020/06/29/Mysql配置优化/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.6.45-log 关系型数据库 1 线程官方文档 https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html 查看正在运行的线程1SHOW FULL PROCESSLIST TIPS：Command 列显示为 “Sleep” 表示连接空闲，由 wait_timeout 参数控制，默认 8 小时空闲连接断开 2 连接查看空闲连接超时时间1SHOW VARIABLES LIKE &apos;wait_timeout&apos; 修改空闲连接超时时间1234$ vi /etc/my.cnf[mysqld]wait_timeout=388000interactive_timeout=388000 3 事务查看事务是否开启自动提交1SHOW VARIABLES LIKE &apos;autocommit&apos; TIPS：默认开启 4 日志4.1 general_log作用：记录所有到达 Mysql Server 的 SQL 语句 场景：排查到达 Mysql server 的 SQL 语句 查看 general_log 是否开启1SHOW VARIABLES LIKE &apos;general_log&apos; TIPS：general_log 默认关闭 启用 general_log 日志（重启后无效）1SET GLOBAL general_log = ON 启用 general_log 日志（永久有效）123$ vi /etc/my.cnf[mysqld]general_log=1 查看 general_log 日志文件保存的位置1SHOW VARIABLES LIKE &apos;general_log_file&apos; 4.2 redo log若磁盘充足，建议将 redo log 文件大小设置为 1G，个数设置为 4 查看单个 redo log 文件大小1SHOW VARIABLES LIKE &apos;%innodb_log_file_size%&apos; 查看 redo log 个数1SHOW VARIABLES LIKE &apos;%innodb_log_files_in_group%&apos; 5 表空间查看 undo 表空间的个数1SHOW VARIABLES LIKE &apos;innodb_undo_tablespaces&apos; TIPS：默认值为0，表示不独立设置 undo 的 tablespace，默认记录到 ibdata 中。建议设置为2，防止大事务导致回滚段过大，方便清理 查看表数据是否存在共享表空间1SHOW VARIABLES LIKE &apos;%innodb_file_per_table%&apos; TIPS：默认是 ON ，表示每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。OFF 则表示表的数据放在系统共享表空间，即跟数据字典放在一起。建议设置为 ON，因为一个表单独存储为一个文件更容易管理，而且不需要这个表的时，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的 6 缓冲6.1 change buffer查看 buffer pool 大小1SHOW VARIABLES LIKE &apos;innodb_buffer_pool_size&apos; 查看 change buffer 最多占 buffer pool 的百分比1SHOW VARIABLES LIKE &apos;innodb_change_buffer_max_size&apos; TIPS：默认值为25，表示最多只能占用 buffer pool 的 25% 7 统计重置表的统计信息1analyze table t; 8 磁盘8.1 容量查看磁盘IO容量配置1SHOW VARIABLES LIKE &apos;%innodb_io_capacity%&apos; TIPS：默认是200，单位是页。该参数设置的大小取决于硬盘的IOPS，即每秒的输入输出量（或读写次数） innodb_io_capacity 参考配置 查看脏页比例上限1SHOW VARIABLES LIKE &apos;%innodb_max_dirty_pages_pct%&apos; 查看脏页比例12345678910111213141516SELECT ( SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = &apos;INNODB_BUFFER_POOL_PAGES_DIRTY&apos; ) / ( SELECT VARIABLE_VALUE FROM information_schema.global_status WHERE VARIABLE_NAME = &apos;INNODB_BUFFER_POOL_PAGES_TOTAL&apos; ); TIPS：不要让脏页比例经常接近 75% 相连脏页级联 flush 控制1SHOW VARIABLES LIKE &apos;%innodb_flush_neighbors%&apos; TIPS：默认为1，即开启。若是机械硬盘可以减少随机IO；若是SSD或IOPS比较高的设备，设置成0，即关闭，可以减少SQL语句响应时间 8.1 落盘查看 redo log 持久化到磁盘频率1SHOW VARIABLES LIKE &apos;innodb_flush_log_at_trx_commit&apos; TIPS：innodb_flush_log_at_trx_commit=1表示每次事务的 redo log 都持久化到磁盘，可以保证 Mysql 异常重启之后数据不丢失 查看 binlog 持久化到磁盘频率1SHOW VARIABLES LIKE &apos;sync_binlog&apos; TIPS：sync_binlog=1表示每次事务的 binlog 都持久化到磁盘，可以保证 Mysql 异常重启之后 binlog 不丢失。默认，sync_binlog=0，表示 Mysql 不控制 binlog 的持久化，由文件系统控制其缓存的持久化。此时性能是最好的，但是风险也是最大的。因为一旦系统 Crash，在 binlog_cache 中的所有 binlog 信息都会被丢失 非双1配置，是设置innodb_flush_logs_at_trx_commit=2且sync_binlog=1000，其使用场景如下 业务高峰期。一般如果有预知的高峰期，DBA 会有预案，把主库设置成“非双 1” 备库延迟，为了让备库尽快赶上主库 用备份恢复主库的副本，应用 binlog 的过程 批量导入数据时","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql闪回方案","slug":"Mysql闪回方案","date":"2020-06-21T03:37:09.000Z","updated":"2020-11-03T13:04:34.180Z","comments":false,"path":"2020/06/21/Mysql闪回方案/","link":"","permalink":"https://zhechu.github.io/2020/06/21/Mysql闪回方案/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.6.46 关系型数据库 binlog2sql 从 MySQL binlog 解析得到逆向 SQL，仅支持 Mysql 5.6, 5.7 MyFlash 回滚 DML 操作工具，仅支持 Mysql 5.6, 5.7 CentOS7 操作系统 Mysql 安装请看 CentOS7安装Mysql 或 Docker安装Mysql 1 binlog2sql官方文档 https://github.com/danfengcao/binlog2sql 1.1 安装安装 git12$ yum -y install git$ yum update -y nss curl libcurl 安装 pip12$ yum -y install epel-release$ yum -y install python-pip 安装 binlog2sql1234$ mkdir -p /usr/local/src/mysql$ cd /usr/local/src/mysql$ git clone https://github.com/danfengcao/binlog2sql.git &amp;&amp; cd binlog2sql$ pip install -r requirements.txt 1.2 使用示例Mysql server 配置123456$ vi /etc/my.cnflog-bin=mysql-binserver_id=1max_binlog_size = 1Gbinlog_format = rowbinlog_row_image = full 重启 Mysql server 使配置生效1$ systemctl restart mysql 创建闪回专用的用户并授权123mysql&gt; CREATE USER &apos;binlog2sql&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;;mysql&gt; GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;binlog2sql&apos;@&apos;localhost&apos;;mysql&gt; flush privileges; 权限 说明 select 需要读取server端information_schema.COLUMNS表，获取表结构的元信息，拼接成可视化的sql语句 super/replication client 两个权限都可以，需要执行’SHOW MASTER STATUS’, 获取server端的binlog列表 replication slave 通过BINLOG_DUMP协议获取binlog内容的权限 1.2.1 找回误删数据1.2.1.1 误删数据误删 ApolloConfigDB.App 表所有数据12mysql&gt; delete from ApolloConfigDB.App;mysql&gt; commit; 1.2.1.2 找回数据此时可能又做了其它操作，误删者突然意识到误删了，下面则是如何找回数据 手动执行将数据落盘1mysql&gt; flush logs; 查看 binlog1mysql&gt; show master logs; 查看 binlog 的事件，找到误删数据的位点（Pos 列）1mysql&gt; show binlog events in 'mysql-bin.000020'; TIPS：若 binlog 不大，也可以直接跳过此项，把整个 binlog 解析即可 解析出误删时操作的 SQL1$ python /usr/local/src/mysql/binlog2sql/binlog2sql/binlog2sql.py -h127.0.0.1 -P3306 -ubinlog2sql -p '123456' -dApolloConfigDB -tApp --start-file='mysql-bin.000020' --start-position='202' --stop-position='1436' &gt; ApolloConfigDB_App_raw.sql 123456789101112DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='Sample App' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='default' AND `DataChange_CreatedTime`='2019-11-09 21:59:51' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='SampleApp' AND `DataChange_LastModifiedBy`='' AND `DataChange_LastTime`='2019-11-09 21:59:51' AND `Id`=1 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='spring-boot-logger' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-09 22:15:44' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='spring-boot-logger' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-09 22:15:44' AND `Id`=2 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='spring-cloud-logger' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-09 22:37:04' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='spring-cloud-logger' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-09 22:37:04' AND `Id`=3 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='video-service' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-10 01:26:47' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='video-service' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 01:26:47' AND `Id`=4 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='a' AND `OrgName`='样例部门1' AND `OwnerEmail`='ling-yu-wang@qq.com' AND `DataChange_CreatedBy`='admin' AND `DataChange_CreatedTime`='2019-11-10 03:20:24' AND `OrgId`='TEST1' AND `OwnerName`='admin' AND `AppId`='a' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 03:26:27' AND `Id`=5 AND `IsDeleted`='1' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='a' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-10 21:23:58' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='a' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 21:23:58' AND `Id`=6 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='b' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-10 21:26:00' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='b' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 21:27:50' AND `Id`=7 AND `IsDeleted`='1' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='b' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-10 21:41:15' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='b' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 21:41:15' AND `Id`=8 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='c' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-10 22:00:27' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='c' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-10 22:00:27' AND `Id`=9 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='qiaoku' AND `OrgName`='样例部门1' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-12 00:33:41' AND `OrgId`='TEST1' AND `OwnerName`='apollo' AND `AppId`='qiaoku' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-12 00:33:41' AND `Id`=10 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='测试' AND `OrgName`='开发部门' AND `OwnerEmail`='ling-yu-wang@qq.com' AND `DataChange_CreatedBy`='lingyuwang' AND `DataChange_CreatedTime`='2019-11-12 00:44:13' AND `OrgId`='dev' AND `OwnerName`='lingyuwang' AND `AppId`='test' AND `DataChange_LastModifiedBy`='lingyuwang' AND `DataChange_LastTime`='2019-11-12 00:44:13' AND `Id`=11 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33DELETE FROM `ApolloConfigDB`.`App` WHERE `Name`='ty' AND `OrgName`='开发部门' AND `OwnerEmail`='apollo@acme.com' AND `DataChange_CreatedBy`='apollo' AND `DataChange_CreatedTime`='2019-11-12 00:52:51' AND `OrgId`='dev' AND `OwnerName`='apollo' AND `AppId`='ty' AND `DataChange_LastModifiedBy`='apollo' AND `DataChange_LastTime`='2019-11-12 00:52:51' AND `Id`=12 AND `IsDeleted`='0' LIMIT 1; #start 202 end 1436 time 2020-06-21 20:14:33 解析出误删时操作的逆向 SQL，用于恢复数据1$ python /usr/local/src/mysql/binlog2sql/binlog2sql/binlog2sql.py --flashback -h127.0.0.1 -P3306 -ubinlog2sql -p '123456' -dApolloConfigDB -tApp --start-file='mysql-bin.000020' --start-position='202' --stop-position='1436' &gt; ApolloConfigDB_App_flashback.sql 123456789101112INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('ty', '开发部门', 'apollo@acme.com', 'apollo', '2019-11-12 00:52:51', 'dev', 'apollo', 'ty', 'apollo', '2019-11-12 00:52:51', 12, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('测试', '开发部门', 'ling-yu-wang@qq.com', 'lingyuwang', '2019-11-12 00:44:13', 'dev', 'lingyuwang', 'test', 'lingyuwang', '2019-11-12 00:44:13', 11, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('qiaoku', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-12 00:33:41', 'TEST1', 'apollo', 'qiaoku', 'apollo', '2019-11-12 00:33:41', 10, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('c', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-10 22:00:27', 'TEST1', 'apollo', 'c', 'apollo', '2019-11-10 22:00:27', 9, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('b', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-10 21:41:15', 'TEST1', 'apollo', 'b', 'apollo', '2019-11-10 21:41:15', 8, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('b', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-10 21:26:00', 'TEST1', 'apollo', 'b', 'apollo', '2019-11-10 21:27:50', 7, '1'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('a', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-10 21:23:58', 'TEST1', 'apollo', 'a', 'apollo', '2019-11-10 21:23:58', 6, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('a', '样例部门1', 'ling-yu-wang@qq.com', 'admin', '2019-11-10 03:20:24', 'TEST1', 'admin', 'a', 'apollo', '2019-11-10 03:26:27', 5, '1'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('video-service', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-10 01:26:47', 'TEST1', 'apollo', 'video-service', 'apollo', '2019-11-10 01:26:47', 4, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('spring-cloud-logger', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-09 22:37:04', 'TEST1', 'apollo', 'spring-cloud-logger', 'apollo', '2019-11-09 22:37:04', 3, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('spring-boot-logger', '样例部门1', 'apollo@acme.com', 'apollo', '2019-11-09 22:15:44', 'TEST1', 'apollo', 'spring-boot-logger', 'apollo', '2019-11-09 22:15:44', 2, '0'); #start 202 end 1436 time 2020-06-21 20:14:33INSERT INTO `ApolloConfigDB`.`App`(`Name`, `OrgName`, `OwnerEmail`, `DataChange_CreatedBy`, `DataChange_CreatedTime`, `OrgId`, `OwnerName`, `AppId`, `DataChange_LastModifiedBy`, `DataChange_LastTime`, `Id`, `IsDeleted`) VALUES ('Sample App', '样例部门1', 'apollo@acme.com', 'default', '2019-11-09 21:59:51', 'TEST1', 'apollo', 'SampleApp', '', '2019-11-09 21:59:51', 1, '0'); #start 202 end 1436 time 2020-06-21 20:14:33 TIP：建议先确认下SQL，再执行恢复操作，以免产生二次误操作。此处解析出的回滚SQL，IsDeleted 列的数据应该去掉单引号，不然 Mysql 会报 [Err] 1406 - Data too long for column ‘IsDeleted’ at row 1异常，原因是其数据类型为 bit(1)，而单个字符的长度已超出一个位（一个字节是8位） 2 MyFlash官方文档 https://github.com/Meituan-Dianping/MyFlash 2.1 安装安装依赖1$ yum -y install gcc gcc-c++ libgnomeui-devel 安装 MyFlash1234$ mkdir -p /usr/local/src/mysql$ cd /usr/local/src/mysql$ git clone https://github.com/Meituan-Dianping/MyFlash.git &amp;&amp; cd MyFlash$ gcc -w `pkg-config --cflags --libs glib-2.0` source/binlogParseGlib.c -o binary/flashback 2.2 使用示例Mysql server 配置123456$ vi /etc/my.cnflog-bin=mysql-binserver_id=1max_binlog_size = 1Gbinlog_format = rowbinlog_row_image = full 重启 Mysql server 使配置生效1$ systemctl restart mysql 2.2.1 找回误删数据2.2.1.1 误删数据误删 ApolloConfigDB.Instance 表所有数据12mysql&gt; delete from ApolloConfigDB.Instance;mysql&gt; commit; 2.2.1.2 找回数据此时可能又做了其它操作，误删者突然意识到误删了，下面则是如何找回数据 手动执行将数据落盘1mysql&gt; flush logs; 查看 binlog1mysql&gt; show master logs; 查看 binlog 的事件，找到误删数据的位点（Pos 列）1mysql&gt; show binlog events in &apos;mysql-bin.000022&apos;; TIPS：若 binlog 不大，也可以直接跳过此项，把整个 binlog 解析即可 解析出误删时操作的回滚 SQL，用于恢复数据12$ rm /usr/local/src/mysql/MyFlash/binlog_output_base.flashback$ /usr/local/src/mysql/MyFlash/binary/flashback --databaseNames=ApolloConfigDB --tableNames=Instance --start-position=719 --stop-position=1156 --binlogFileNames=/var/lib/mysql/mysql-bin.000022 将回滚 SQL 转成可视化语句，方便确认12$ mysqlbinlog --base64-output=decode-rows -v --skip-gtids /usr/local/src/mysql/MyFlash/binlog_output_base.flashback &gt; /usr/local/src/mysql/MyFlash/binlog_output_base.log$ cat /usr/local/src/mysql/MyFlash/binlog_output_base.log 结合 mysqlbinlog 工具恢复数据1$ mysqlbinlog /usr/local/src/mysql/MyFlash/binlog_output_base.flashback | mysql -uroot -p123456 TIPS：可以将 binlog 文件离线转成 binlog_output_base.flashback 后再到线上恢复 3 总结3.1 binlog2sql VS MyFlash 方案 优点 缺点 binlog2sql 1.解析为标准SQL，方便理解、筛选 1.mysql server必须开启，离线模式下不能解析2.参数 binlog_row_image 必须为FULL，暂不支持MINIMAL3.只能回滚DML（增、删、改） MyFlash 1.支持离线解析2.解析效率更高 1.binlog格式必须为row,且binlog_row_image=full2.只能回滚DML（增、删、改） 3.2 生产实践 需回滚的数据量不大时建议用 binlog2sql，方便理解和筛选需回滚的数据 需回滚的数据量较大时建议用 MyFlash，解析更高 若在生产环境发版时需回滚版本，则可以结合数据库全库回滚技术，并通过 binlog2sql/MyFlash 补回发版时的数据更新 生产环境做删除表或字段操作时，可以在下一个版本做（一般不会影响业务，避免系统版本回滚时也需回滚DDL），从源头避免产生故障","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"升级回滚","slug":"升级回滚","permalink":"https://zhechu.github.io/tags/升级回滚/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Guava布隆过滤器的应用","slug":"Guava布隆过滤器的应用","date":"2020-05-31T15:35:23.000Z","updated":"2020-11-03T13:04:34.084Z","comments":false,"path":"2020/05/31/Guava布隆过滤器的应用/","link":"","permalink":"https://zhechu.github.io/2020/05/31/Guava布隆过滤器的应用/","excerpt":"","text":"com.google.common.hash.BloomFilter的应用 1 示例示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/bitmap/BloomFilterByGuava.java 问题：有1亿个随机数，其范围在1到1亿之间。要求将1到1亿之间没有在随机数中的数求出来？ 思路：将随机数存储到布隆过滤器中，依次遍历判断即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import com.google.common.hash.BloomFilter;import com.google.common.hash.Funnels;import java.util.*;/** * 问题： * 有1亿个随机数，其范围在1到1亿之间。要求将1到1亿之间没有在随机数中的数求出来？ * * 方案： * Guava布隆过滤器（不在集合的一定不在，在的不一定在） * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class BloomFilterByGuava &#123; public static void main(String[] args) &#123; int length = 10; // 包含 minValue 和 maxValue int minValue = 1; int maxValue = 10; int[] arr = generateRandomArray(length, minValue, maxValue); // 打印 printArray(arr); BloomFilter&lt;Integer&gt; filter = BloomFilter.create( // 存放 Integer 类型数据 Funnels.integerFunnel(), // 预计长度 length, // 预计误报率 0.001); for (int i = 0; i &lt; length; i++) &#123; filter.put(arr[i]); &#125; // 获取不在随机数中的数 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int k = minValue; k &lt;= maxValue; k++) &#123; // 判断是否在随机数的数组中 if (!filter.mightContain(k)) &#123; result.add(k); &#125; &#125; System.out.println(minValue + \"~\" + maxValue + \"不在上述随机数中的数有：\" + result.size() + \"个\"); System.out.println(result); &#125; /** * 随机生成数组 * @param length * @param minValue * @param maxValue * @return */ public static int[] generateRandomArray(int length, int minValue, int maxValue) &#123; int[] arr = new int[length]; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; arr[i] = random.nextInt(maxValue - minValue + 1) + minValue; &#125; return arr; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 控制台输出1234 3 6 10 8 1 3 4 10 21~10不在上述随机数中的数有：3个[5, 7, 9] 2 BloomFilter VS BitSet 方式 优点 缺点 com.google.common.hash.BloomFilter 空间复杂度小 1.会误报（不在集合的一定不在，在的不一定在） 2.不能按单个元素清除 java.util.BitSet 空间复杂度超小 功能没 com.google.common.hash.BloomFilter 强大","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"BitSet的应用","slug":"BitSet的应用","date":"2020-05-31T12:56:36.000Z","updated":"2020-11-03T13:04:34.051Z","comments":false,"path":"2020/05/31/BitSet的应用/","link":"","permalink":"https://zhechu.github.io/2020/05/31/BitSet的应用/","excerpt":"","text":"java.util.BitSet的应用 示例代码 https://github.com/zhechu/algorithm-demo/tree/master/src/main/java/com/wise/algorithm/apply/bitmap 1 布隆过滤器问题：有1亿个随机数，其范围在1到1亿之间。要求将1到1亿之间没有在随机数中的数求出来？ 思路：将随机数存储到位图中，若对应的位为false，则表示对应的数不在随机数中，然后依次遍历即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.BitSet;import java.util.List;import java.util.Random;/** * 问题： * 有1亿个随机数，其范围在1到1亿之间。要求将1到1亿之间没有在随机数中的数求出来？ * * 方案： * 位图法 * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class BloomFilterByBitSet &#123; public static void main(String[] args) &#123; int length = 10; // 包含 minValue 和 maxValue int minValue = 1; int maxValue = 10; int[] arr = generateRandomArray(length, minValue, maxValue); // 打印 printArray(arr); // BitSet 索引从0开始，因此需浪费一个位 BitSet bitSet = new BitSet(maxValue + 1); for (int i = 0; i &lt; length; i++) &#123; bitSet.set(arr[i]); &#125; // 获取不在随机数中的数 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int k = minValue; k &lt;= maxValue; k++) &#123; // 判断是否在位图中 if (!bitSet.get(k)) &#123; result.add(k); &#125; &#125; System.out.println(minValue + \"~\" + maxValue + \"不在上述随机数中的数有：\" + result.size() + \"个\"); System.out.println(result); &#125; /** * 随机生成数组 * @param length * @param minValue * @param maxValue * @return */ public static int[] generateRandomArray(int length, int minValue, int maxValue) &#123; int[] arr = new int[length]; Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; arr[i] = random.nextInt(maxValue - minValue + 1) + minValue; &#125; return arr; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 控制台输出12310 10 7 4 4 4 2 9 2 21~10不在上述随机数中的数有：5个[1, 3, 5, 6, 8] 2 排序问题：有1亿个不同的数，其范围在1到1亿之间。要求将1到1亿之间的数进行有序输出？ 思路：将1亿个数存储到位图中，依次遍历相当于已排好序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.BitSet;import java.util.HashSet;import java.util.Random;import java.util.Set;/** * 问题： * 有1亿个不同的数，其范围在1到1亿之间。要求将1到1亿之间的数进行有序输出？ * * 方案： * 位图法 * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class LinearSortByBitSet &#123; public static void main(String[] args) &#123; int length = 10; // 包含 minValue 和 maxValue int minValue = 1; int maxValue = 20; int[] arr = generateRandomArray(length, minValue, maxValue); // 打印 printArray(arr); // BitSet 索引从0开始，因此需浪费一个位 BitSet bitSet = new BitSet(maxValue + 1); for (int i = 0; i &lt; length; i++) &#123; bitSet.set(arr[i]); &#125; System.out.println(\"有序输出：\"); for (int k = minValue; k &lt;= maxValue; k++) &#123; // 判断是否在位图中 if (bitSet.get(k)) &#123; System.out.print(k + \" \"); &#125; &#125; &#125; /** * 随机生成数组 * @param length * @param minValue * @param maxValue * @return */ public static int[] generateRandomArray(int length, int minValue, int maxValue) &#123; int[] arr = new int[length]; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(length); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; int temp; do &#123; temp = random.nextInt(maxValue - minValue + 1) + minValue; &#125; while (set.contains(temp)); set.add(temp); arr[i] = temp; &#125; return arr; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 控制台输出1231 20 12 2 6 16 15 14 10 7有序输出：1 2 6 7 10 12 14 15 16 20","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2020-05-31T01:45:15.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2020/05/31/拓扑排序/","link":"","permalink":"https://zhechu.github.io/2020/05/31/拓扑排序/","excerpt":"","text":"维基百科 https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F 平均时间复杂度 稳定性 备注 O(v+e) 不稳定 v 表示顶点个数，e 表示边的个数 TIPS：额外空间复杂度不同实现方式有差别 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Topo.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181import java.util.LinkedList;/** * 拓扑排序 * * @author lingyuwang * @date 2020-05-30 23:31 * @since 1.0.4 */public class Topo &#123; public static void main(String[] args) &#123; Graph graph = new Graph(10); // 0 -&gt; 1 -&gt; 3 -&gt; 4 // 1 -&gt; 4 -&gt; 5 -&gt; 7 // 2 -&gt; 3 -&gt; 8 -&gt; 9 graph.addEdge(0, 1); graph.addEdge(1, 3); graph.addEdge(1, 4); graph.addEdge(2, 3); graph.addEdge(3, 4); graph.addEdge(3, 8); graph.addEdge(4, 5); graph.addEdge(5, 7); graph.addEdge(8, 9); LinkedList&lt;Integer&gt; topoSortByKahnList = graph.topoSortByKahn(); System.out.println(\"基于Kahn算法拓扑排序后：\" + topoSortByKahnList); // 拓扑排序后：[0, 2, 6, 1, 3, 4, 8, 5, 9, 7] LinkedList&lt;Integer&gt; topoSortByDFSList = graph.topoSortByDFS(); System.out.println(\"基于DFS算法拓扑排序后：\" + topoSortByDFSList); // 拓扑排序后：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &#125; static class Graph &#123; /** 顶点的个数 */ private int v; /** 邻接表 */ private LinkedList&lt;Integer&gt;[] adj; public Graph(int v) &#123; this.v = v; adj = new LinkedList[v]; for (int i = 0; i &lt; v; ++i) &#123; adj[i] = new LinkedList&lt;&gt;(); &#125; &#125; /** * s先于t，边s-&gt;t * @param s * @param t */ public void addEdge(int s, int t) &#123; adj[s].add(t); &#125; /** * 基于Kahn算法拓扑排序 * * 思路： * 先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来）， * 并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。循环执行以上过程，直到所有的 * 顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序 * * 时间复杂度： * 每个顶点被访问了一次，每个边也都被访问了一次，时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数） */ public LinkedList&lt;Integer&gt; topoSortByKahn() &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); // 统计每个顶点的入度 int[] inDegree = new int[v]; for (int i = 0; i &lt; v; ++i) &#123; int adjSize = adj[i].size(); for (int j = 0; j &lt; adjSize; ++j) &#123; // i-&gt;w int w = adj[i].get(j); inDegree[w]++; &#125; &#125; // 将入度为0的顶点放入队列 LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; v; ++i) &#123; if (inDegree[i] == 0) &#123; queue.add(i); &#125; &#125; // 广度优先遍历 while (!queue.isEmpty()) &#123; int i = queue.remove(); result.add(i); int adjSize = adj[i].size(); for (int j = 0; j &lt; adjSize; ++j) &#123; int k = adj[i].get(j); inDegree[k]--; if (inDegree[k] == 0) &#123; queue.add(k); &#125; &#125; &#125; return result; &#125; /** * 基于DFS算法拓扑排序 * * 思路： * 1.通过邻接表构造逆邻接表 * 2.递归处理每个顶点：先将vertex依赖的所有顶点放入链表，然后再放入自身 * * 时间复杂度： * 每个顶点被访问两次，每条边都被访问一次，时间复杂度也是 O(V+E) */ public LinkedList&lt;Integer&gt; topoSortByDFS() &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); // 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s LinkedList&lt;Integer&gt;[] inverseAdj = new LinkedList[v]; for (int i = 0; i &lt; v; ++i) &#123; // 申请空间 inverseAdj[i] = new LinkedList&lt;&gt;(); &#125; // 通过邻接表生成逆邻接表 for (int i = 0; i &lt; v; ++i) &#123; int adjSize = adj[i].size(); for (int j = 0; j &lt; adjSize; ++j) &#123; // i-&gt;w int w = adj[i].get(j); // w-&gt;i inverseAdj[w].add(i); &#125; &#125; boolean[] visited = new boolean[v]; for (int i = 0; i &lt; v; ++i) &#123; if (visited[i]) &#123; continue; &#125; visited[i] = true; // 深度优先遍历 dfs(result, i, inverseAdj, visited); &#125; return result; &#125; /** * 深度优先遍历 * @param result 结果列表 * @param vertex 当前顶点 * @param inverseAdj 逆邻接表 * @param visited 是否访问过顶点的备忘录 */ private void dfs(LinkedList&lt;Integer&gt; result, int vertex, LinkedList&lt;Integer&gt;[] inverseAdj, boolean[] visited) &#123; int inverseAdjSize = inverseAdj[vertex].size(); for (int i = 0; i &lt; inverseAdjSize; ++i) &#123; int w = inverseAdj[vertex].get(i); if (visited[w]) &#123; continue; &#125; visited[w] = true; dfs(result, w, inverseAdj, visited); &#125; // 先将vertex依赖的所有顶点放入链表，然后再放入自身 result.add(vertex); &#125; &#125;&#125; 控制台输出12基于Kahn算法拓扑排序后：[0, 2, 6, 1, 3, 4, 8, 5, 9, 7]基于DFS算法拓扑排序后：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 总结 算法 优点 缺点 备注 Kahn 实际时间复杂度较低 推荐 DFS 实际时间复杂度和额外空间复杂度都较高","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"动态规划求最长递增子序列","slug":"动态规划求最长递增子序列","date":"2020-05-30T14:41:56.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2020/05/30/动态规划求最长递增子序列/","link":"","permalink":"https://zhechu.github.io/2020/05/30/动态规划求最长递增子序列/","excerpt":"","text":"有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/LongestIncrSubsequenceByDP.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import java.util.LinkedList;/** * 动态规划求最长递增子序列 * * @author lingyuwang * @date 2020-05-30 19:28 * @since 1.0.4 */public class LongestIncrSubsequenceByDP &#123; public static void main(String[] args) &#123; int[] sequence = &#123;2, 9, 3, 6, 5, 1, 7&#125;; LinkedList&lt;Integer&gt; longestSubsequenceList = dp(sequence); System.out.println(\"最长递增子序列长度：\" + longestSubsequenceList.size()); System.out.println(\"最长递增子序列：\" + longestSubsequenceList); &#125; /** * 状态转移方程法 * @param sequence 原序列 * @return 最长递增子序列 */ public static LinkedList&lt;Integer&gt; dp(int[] sequence) &#123; int len = sequence.length; int[] mem = new int[len]; // 回溯加备忘录 for (int i = 0; i &lt; len; i++) &#123; for (int j = i; j &gt;= 0; j--) &#123; rdp(i, j, sequence, mem); &#125; &#125; // 获取最长递增子序列备忘录索引（不包含本身节点） int index = 0; for (int i = 1; i &lt; len; i++) &#123; if (mem[i] &gt; mem[index]) &#123; index = i; &#125; &#125; // 推断最长子序列 LinkedList&lt;Integer&gt; longestSubsequenceList = new LinkedList&lt;&gt;(); longestSubsequenceList.addFirst(sequence[index]); int tempSequence = sequence[index]; int tempLen = mem[index] - 1; for (int k = index - 1; k &gt;=0; k--) &#123; if (sequence[k] &lt;= tempSequence &amp;&amp; mem[k] == tempLen) &#123; tempSequence = sequence[k]; tempLen = mem[k] - 1; longestSubsequenceList.addFirst(sequence[k]); &#125; &#125; return longestSubsequenceList; &#125; /** * 递归调用 * @param t 目标索引 * @param i 回溯索引 * @param sequence 原序列 * @param mem 备忘录 * @return 以 t 为参照节点，返回 0 到 i 的递增子序列的长度 */ public static int rdp(int t, int i, int[] sequence, int[] mem) &#123; if (i == 0) &#123; return 0; &#125; int result; if (sequence[i - 1] &lt;= sequence[t]) &#123; if (mem[i - 1] &gt; 0) &#123; result = mem[i - 1] + 1; &#125; else &#123; result = rdp(i - 1, i - 1, sequence, mem) + 1; &#125; &#125; else &#123; result = rdp(t,i - 1, sequence, mem); &#125; // 记录最长序列长度 if (result &gt; mem[t]) &#123; mem[t] = result; &#125; return result; &#125;&#125; 控制台输出12最长递增子序列长度：4最长递增子序列：[2, 3, 5, 7]","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"动态规划求矩阵两点间最短路径","slug":"动态规划求矩阵两点间最短路径","date":"2020-05-26T12:36:28.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2020/05/26/动态规划求矩阵两点间最短路径/","link":"","permalink":"https://zhechu.github.io/2020/05/26/动态规划求矩阵两点间最短路径/","excerpt":"","text":"假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少？ 1 回溯法示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/MatrixMinDistBT.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.LinkedList;/** * 问题： * 假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。 * 我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以 * 走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少？ * * 方案： * 回溯法 * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class MatrixMinDistBT &#123; public static void main(String[] args) &#123; int[][] w = &#123; &#123;1, 3, 5, 9&#125;, &#123;2, 1, 3, 4&#125;, &#123;5, 2, 6, 7&#125;, &#123;6, 8, 4, 3&#125; &#125;; ResultDTO resultDTO = minDist(w); System.out.println(resultDTO); &#125; public static ResultDTO minDist(int[][] w) &#123; ResultDTO resultDTO = new ResultDTO(); LinkedList&lt;Point&gt; routeList = new LinkedList&lt;&gt;(); minDistBT(resultDTO, routeList, 0, 0, 0, w, w.length); return resultDTO; &#125; /** * 回溯法 * @param resultDTO * @param routeList * @param i * @param j * @param dist * @param w * @param n */ public static void minDistBT(ResultDTO resultDTO, LinkedList&lt;Point&gt; routeList, int i, int j, int dist, int[][] w, int n) &#123; // 到达了 n-1, n-1 这个位置 if (i == (n - 1) &amp;&amp; j == (n - 1)) &#123; routeList.add(new Point(i, j)); dist += w[i][j]; if (dist &lt; resultDTO.minDist) &#123; resultDTO.minDist = dist; resultDTO.minRouteList.clear(); resultDTO.minRouteList.addAll(routeList); &#125; routeList.removeLast(); return; &#125; // 往下走，更新 i=i+1, j=j if (i &lt; n - 1) &#123; routeList.add(new Point(i, j)); minDistBT(resultDTO, routeList,i + 1, j, dist + w[i][j], w, n); routeList.removeLast(); &#125; // 往右走，更新 i=i, j=j+1 if (j &lt; n - 1) &#123; routeList.add(new Point(i, j)); minDistBT(resultDTO, routeList, i,j + 1, dist + w[i][j], w, n); routeList.removeLast(); &#125; &#125; /** * 结果 */ static class ResultDTO &#123; /** 最小距离 */ public int minDist = Integer.MAX_VALUE; /** 最优解路径 */ public LinkedList&lt;Point&gt; minRouteList = new LinkedList&lt;&gt;(); @Override public String toString() &#123; return \"ResultDTO&#123;\" + \"minDist=\" + minDist + \", minRouteList=\" + minRouteList + '&#125;'; &#125; &#125; /** * 定义点 */ static class Point &#123; public int x; public int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point&#123;\" + \"x=\" + x + \", y=\" + y + '&#125;'; &#125; &#125;&#125; 控制台输出1ResultDTO&#123;minDist=19, minRouteList=[Point&#123;x=0, y=0&#125;, Point&#123;x=1, y=0&#125;, Point&#123;x=1, y=1&#125;, Point&#123;x=2, y=1&#125;, Point&#123;x=2, y=2&#125;, Point&#123;x=3, y=2&#125;, Point&#123;x=3, y=3&#125;]&#125; 2 状态转移表法示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/MatrixMinDistDP.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import java.util.LinkedList;/** * 问题： * 假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。 * 我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以 * 走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少？ * * 方案： * 状态转移表法 * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class MatrixMinDistDP &#123; public static void main(String[] args) &#123; int[][] w = &#123; &#123;1, 3, 5, 9&#125;, &#123;2, 1, 3, 4&#125;, &#123;5, 2, 6, 7&#125;, &#123;6, 8, 4, 3&#125; &#125;; ResultDTO resultDTO = minDistDP(w); System.out.println(resultDTO); &#125; /** * 状态转移表法 * @param matrix */ public static ResultDTO minDistDP(int[][] matrix) &#123; ResultDTO resultDTO = new ResultDTO(); int len = matrix.length; int[][] states = new int[len][len]; int sum = 0; // 初始化states的第一行数据 for (int j = 0; j &lt; len; ++j) &#123; sum += matrix[0][j]; states[0][j] = sum; &#125; // 重置求和临时变量 sum = 0; // 初始化states的第一列数据 for (int i = 0; i &lt; len; ++i) &#123; sum += matrix[i][0]; states[i][0] = sum; &#125; for (int i = 1; i &lt; len; ++i) &#123; for (int j = 1; j &lt; len; ++j) &#123; states[i][j] = matrix[i][j] + Math.min(states[i][j - 1], states[i - 1][j]); &#125; &#125; // 最小距离 resultDTO.minDist = states[len - 1][len - 1]; // 从 states 状态数组推断 int i = len - 1; int j = len - 1; while (true) &#123; resultDTO.minRouteList.addFirst(new Point(i, j)); int tempDist = states[i][j] - matrix[i][j]; // 已回溯完毕 if (tempDist == 0) &#123; break; &#125; // 回溯到上一个节点 if (tempDist == states[i - 1][j]) &#123; i--; &#125; // 回溯到左一个节点 else &#123; j--; &#125; &#125; return resultDTO; &#125; /** * 结果 */ static class ResultDTO &#123; /** 最小距离 */ public int minDist = Integer.MAX_VALUE; /** 最优解路径 */ public LinkedList&lt;Point&gt; minRouteList = new LinkedList&lt;&gt;(); @Override public String toString() &#123; return \"ResultDTO&#123;\" + \"minDist=\" + minDist + \", minRouteList=\" + minRouteList + '&#125;'; &#125; &#125; /** * 定义点 */ static class Point &#123; public int x; public int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point&#123;\" + \"x=\" + x + \", y=\" + y + '&#125;'; &#125; &#125;&#125; 控制台输出1ResultDTO&#123;minDist=19, minRouteList=[Point&#123;x=0, y=0&#125;, Point&#123;x=1, y=0&#125;, Point&#123;x=1, y=1&#125;, Point&#123;x=2, y=1&#125;, Point&#123;x=2, y=2&#125;, Point&#123;x=3, y=2&#125;, Point&#123;x=3, y=3&#125;]&#125; 3 状态转移方程法状态转移方程：min_dist(i, j) = w[i][j] + min(min_dist(i, j - 1), min_dist(i - 1, j)) 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/MatrixMinDistDPByEquation.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import java.util.LinkedList;/** * 问题： * 假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。 * 我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以 * 走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少？ * * 方案： * 状态转移方程法 * * @author lingyuwang * @date 2020-05-26 20:47 * @since 1.0.4 */public class MatrixMinDistDPByEquation &#123; public static void main(String[] args) &#123; int[][] w = &#123; &#123;1, 3, 5, 9&#125;, &#123;2, 1, 3, 4&#125;, &#123;5, 2, 6, 7&#125;, &#123;6, 8, 4, 3&#125; &#125;; ResultDTO resultDTO = minDist(w); System.out.println(resultDTO); &#125; public static ResultDTO minDist(int[][] w) &#123; ResultDTO resultDTO = new ResultDTO(); int len = w.length; int[][] mem = new int[len][len]; resultDTO.minDist = minDistDP(len - 1, len - 1, w, mem); // 从备忘录数组推断 int i = len - 1; int j = len - 1; while (true) &#123; resultDTO.minRouteList.addFirst(new Point(i, j)); int tempDist = mem[i][j] - w[i][j]; // 已回溯完毕 if (tempDist == 0) &#123; break; &#125; // 回溯到上一个节点 if (tempDist == mem[i - 1][j]) &#123; i--; &#125; // 回溯到左一个节点 else &#123; j--; &#125; &#125; return resultDTO; &#125; /** * 状态转移方程法 * @param i * @param j * @param matrix * @param mem * @return */ public static int minDistDP(int i, int j, int[][] matrix, int[][] mem) &#123; // 备忘录已有，不需重复计算 if (mem[i][j] &gt; 0) &#123; return mem[i][j]; &#125; if (i == 0 &amp;&amp; j == 0) &#123; mem[i][j] = matrix[0][0]; return matrix[0][0]; &#125; int minLeft = Integer.MAX_VALUE; if (j - 1 &gt;= 0) &#123; minLeft = minDistDP(i, j - 1, matrix, mem); &#125; int minUp = Integer.MAX_VALUE; if (i - 1 &gt;= 0) &#123; minUp = minDistDP(i - 1, j, matrix, mem); &#125; int currMinDist = matrix[i][j] + Math.min(minLeft, minUp); mem[i][j] = currMinDist; return currMinDist; &#125; /** * 结果 */ static class ResultDTO &#123; /** 最小距离 */ public int minDist = Integer.MAX_VALUE; /** 最优解路径 */ public LinkedList&lt;Point&gt; minRouteList = new LinkedList&lt;&gt;(); @Override public String toString() &#123; return \"ResultDTO&#123;\" + \"minDist=\" + minDist + \", minRouteList=\" + minRouteList + '&#125;'; &#125; &#125; /** * 定义点 */ static class Point &#123; public int x; public int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point&#123;\" + \"x=\" + x + \", y=\" + y + '&#125;'; &#125; &#125;&#125; 控制台输出1ResultDTO&#123;minDist=19, minRouteList=[Point&#123;x=0, y=0&#125;, Point&#123;x=1, y=0&#125;, Point&#123;x=1, y=1&#125;, Point&#123;x=2, y=1&#125;, Point&#123;x=2, y=2&#125;, Point&#123;x=3, y=2&#125;, Point&#123;x=3, y=3&#125;]&#125; 4 总结 算法 优点 缺点 备注 回溯法 思路简单、清晰 重复计算，时间复杂度高 数据量不大时推荐 状态转移表法 时间复杂度较低 不容易建模且空间复杂度为O(n) 状态转移方程法 思路清晰且时间复杂度较低 空间复杂度为O(n) 数据量较大时推荐","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SonarQube使用手册","slug":"SonarQube使用手册","date":"2020-05-23T15:17:25.000Z","updated":"2020-11-03T13:04:34.187Z","comments":false,"path":"2020/05/23/SonarQube使用手册/","link":"","permalink":"https://zhechu.github.io/2020/05/23/SonarQube使用手册/","excerpt":"","text":"安装篇 Docker安装SonarQube 组件 版本 postgres 12.3 SonarQube 8.3.1-community 官方文档 https://docs.sonarqube.org/latest/user-guide/clean-as-you-code/ 1 基本使用推荐使用步骤 创建质量配置，为质量配置激活代码规则 创建质量阈，为质量阈添加检查指标 创建权限模板，方便项目授权 根据 maven 项目的 artifactId 创建项目，并配置质量配置、质量阈和权限 本地服务工程 pom.xml 加上 sonar 相关配置，并上传代码至 sonarqube 服务器 打开 sonarqube 仪表盘，进入项目详情页，查看具体问题，并线下进行修复。然后重新执行步骤5。直至质量阈显示为“正常”状态，才可将此项目打包上线 1.1 权限管理1.1.1 用户管理页面路径：配置 -&gt; 权限 -&gt; 用户 1.1.1.1 创建用户 1.1.1.2 生成令牌生成令牌的目的是：maven 执行 sonar 插件扫描程序时使用。生成后需要妥善保管 1.1.2 群组管理页面路径：配置 -&gt; 权限 -&gt; 群组 1.1.2.1 新建群组 1.1.2.2 添加成员 1.1.3 全局权限页面路径：配置 -&gt; 权限 -&gt; 全局权限 取消匿名用户的权限，提高安全性 1.1.3.1 分配群组权限搜索 java组，并给其授权 1.1.4 权限模板页面路径：配置 -&gt; 权限 -&gt; 权限模板 1.1.4.1 新建权限模板 1.2 项目管理页面路径：配置 -&gt; 项目 -&gt; 管理 1.2.1 新建项目 1.2.2 应用权限模板 1.2.3 查看项目问题 1.3 质量阈1.3.1 创建质量阈 1.3.2 管理质量阈 1.4 质量配置1.4.1 新建质量配置 1.4.2 继承父质量配置继承父质量配置，则会继承父质量配置的相应代码规则 1.4.3 加入控制项目 1.4.4 激活代码规则 2 规则插件2.1 安装插件 3 扫描项目3.1 基于 Maven 扫描qiaoku-cloud项目的 pom.xml 配置 123456789101112&lt;profiles&gt; &lt;profile&gt; &lt;!-- 代码质量 --&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;properties&gt; &lt;sonar.login&gt;0a010a369ab079398a80d315e62a4332d5942c43&lt;/sonar.login&gt; &lt;sonar.host.url&gt;http://192.168.163.21:9000&lt;/sonar.host.url&gt; &lt;sonar.projectKey&gt;$&#123;project.artifactId&#125;&lt;/sonar.projectKey&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 配置 说明 sonar.login 用户令牌，请参考 1.1.1.2 sonar.host.url sonarqube 地址 sonar.projectKey 项目键，通常设置为项目的 artifactId 到项目的根目录下执行如下命令上传项目到 sonarqube 1$ mvn clean install sonar:sonar -P sonar -DskipTests=true","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zhechu.github.io/tags/工具/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"CentOS7安装SonarQube","slug":"CentOS7安装SonarQube","date":"2020-05-22T17:32:47.000Z","updated":"2020-11-03T13:04:34.057Z","comments":false,"path":"2020/05/23/CentOS7安装SonarQube/","link":"","permalink":"https://zhechu.github.io/2020/05/23/CentOS7安装SonarQube/","excerpt":"","text":"组件 版本 JDK 1.8 Mysql 5.6 SonarQube 6.7.2 官方文档 https://docs.sonarqube.org/6.7/Documentation.html 1 准备1.1 安装 JDKCentOS7安装JDK 1.2 安装 MysqlCentOS7安装Mysql 1.3 CentOS7优化配置1234$ sysctl -w vm.max_map_count=262144$ sysctl -w fs.file-max=65536$ ulimit -n 65536$ ulimit -u 2048 2 安装 SonarQube-6.7.2历史版本安装包下载 https://binaries.sonarsource.com/Distribution/sonarqube/ 解压1$ unzip sonarqube-6.7.2.zip 修改配置文件 sonarqube-6.7.2/conf/sonar.properties12345$ vi sonarqube-6.7.2/conf/sonar.propertiessonar.jdbc.username=sonarsonar.jdbc.password=sonarsonar.jdbc.url=jdbc:mysql://192.168.163.31:3306/sonar?useUnicode=true&amp;characterEncoding=utf8&amp;rewriteBatchedStatements=true&amp;useConfigs=maxPerformance&amp;useSSL=falsesonar.web.port=9000 修改配置文件 sonarqube-6.7.2/conf/wrapper.conf12$ vi sonarqube-6.7.2/conf/wrapper.confwrapper.java.command=java 配置 Mysql1$ mysql -u root -p 12345mysql&gt; CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;mysql&gt; CREATE USER &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;%&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; GRANT ALL ON sonar.* TO &apos;sonar&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;sonar&apos;;mysql&gt; flush privileges; 添加 sonar 用户，并用其运行 sonarqube 服务12345$ adduser sonar$ passwd sonarsonar$ chown -R sonar /usr/local/src/sonar/sonarqube-6.7.2$ su sonar /usr/local/src/sonar/sonarqube-6.7.2/bin/linux-x86-64/sonar.sh start 查看日志1$ tail -f /usr/local/src/sonar/sonarqube-6.7.2/logs/sonar.log 浏览器访问 http://192.168.163.31:9000 默认账号和密码：admin/admin 3 配置为服务添加 sonar.service123456789101112131415$ vi /usr/lib/systemd/system/sonar.service[Unit]Description=SonarAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingEnvironment=\"JAVA_HOME=/usr/java/jdk1.8.0_11/\"ExecStart=/usr/local/src/sonar/sonarqube-6.7.2/bin/linux-x86-64/sonar.sh startExecReload=/usr/local/src/sonar/sonarqube-6.7.2/bin/linux-x86-64/sonar.sh restartPrivateTmp=trueUser=sonar[Install]WantedBy=multi-user.target 配置开机启动1$ systemctl enable sonar 重启 sonar1$ systemctl restart sonar 服务操作：查看状态/启动/停止123$ systemctl status sonar$ systemctl start sonar$ systemctl stop sonar 4 汉化下载汉化包12$ cd /usr/local/src/sonar/sonarqube-6.7.2/extensions/plugins$ wget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-1.19/sonar-l10n-zh-plugin-1.19.jar 重启 sonar1$ systemctl restart sonar","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"Docker安装SonarQube","slug":"Docker安装SonarQube","date":"2020-05-22T17:32:47.000Z","updated":"2020-11-03T13:04:34.072Z","comments":false,"path":"2020/05/23/Docker安装SonarQube/","link":"","permalink":"https://zhechu.github.io/2020/05/23/Docker安装SonarQube/","excerpt":"","text":"上篇 CentOS7安装SonarQube 组件 版本 postgres 12.3 SonarQube 8.3.1-community 部署文档 https://hub.docker.com/_/sonarqube 1 安装 postgres安装并启动 postgres 数据库123456789$ docker pull postgres:12.3$ mkdir -p /var/lib/postgresql/data$ docker run -d \\ --name postgres \\ -p 5432:5432 \\ -e POSTGRES_PASSWORD=123456 \\ -e PGDATA=/var/lib/postgresql/data/pgdata \\ -v /var/lib/postgresql/data:/var/lib/postgresql/data \\ postgres:12.3 进入 postgres 数据库创建 sonarqube db1CREATE DATABASE sonarqube WITH OWNER postgres ENCODING 'UTF8' 2 安装 sonarqube安装并启动 sonarqube12345678910111213$ docker pull sonarqube:8.3.1-community$ mkdir -p /opt/sonarqube/data$ mkdir -p /opt/sonarqube/extensions$ mkdir -p /opt/sonarqube/logs$ docker run -d --name sonarqube \\ -p 9000:9000 \\ -e SONAR_JDBC_URL=jdbc:postgresql://192.168.163.21:5432/sonarqube \\ -e SONAR_JDBC_USERNAME=postgres \\ -e SONAR_JDBC_PASSWORD=123456 \\ -v /opt/sonarqube/data:/opt/sonarqube/data \\ -v /opt/sonarqube/extensions:/opt/sonarqube/extensions \\ -v /opt/sonarqube/logs:/opt/sonarqube/logs \\ sonarqube:8.3.1-community 3 汉化下载汉化包123$ mkdir /opt/sonarqube/extensions/plugins$ cd /opt/sonarqube/extensions/plugins$ wget https://github.com/SonarQubeCommunity/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-8.3/sonar-l10n-zh-plugin-8.3.jar 重启 sonar1$ docker restart sonarqube 4 效果浏览器访问 sonarqube http://192.168.163.21:9000 admin/admin 5 安装插件笔者需扫描分析的是 Java 应用，故应安装 Java 相关的规则。否则会因找不到相关的语言包，导致扫描失败。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"Eureka客户端负载均衡配置","slug":"Eureka客户端负载均衡配置","date":"2020-05-18T13:57:07.000Z","updated":"2020-11-03T13:04:34.082Z","comments":false,"path":"2020/05/18/Eureka客户端负载均衡配置/","link":"","permalink":"https://zhechu.github.io/2020/05/18/Eureka客户端负载均衡配置/","excerpt":"","text":"环境 说明 spring-cloud-starter-netflix-eureka-client-2.1.1.RELEASE 注册中心 官方文档 https://cloud.spring.io/spring-cloud-netflix/reference/html/#service-discovery-eureka-clients 1 服务端配置1.1 eureka-011234567server.port = 8761eureka.instance.hostname = eureka-01.didong.svc.cluster.localeureka.server.enable-self-preservation = falseeureka.server.eviction-interval-timer-in-ms = 5000eureka.client.registerWithEureka = trueeureka.client.fetchRegistry = trueeureka.client.serviceUrl.defaultZone = http://eureka-01.didong.svc.cluster.local:8761/eureka/,http://eureka-02.didong.svc.cluster.local:8761/eureka/ 1.2 eureka-021234567server.port = 8761eureka.instance.hostname = eureka-02.didong.svc.cluster.localeureka.server.enable-self-preservation = falseeureka.server.eviction-interval-timer-in-ms = 5000eureka.client.registerWithEureka = trueeureka.client.fetchRegistry = trueeureka.client.serviceUrl.defaultZone = http://eureka-01.didong.svc.cluster.local:8761/eureka/,http://eureka-02.didong.svc.cluster.local:8761/eureka/ 2 客户端2.1 配置123eureka.client.serviceUrl.defaultZone = http://eureka-01.didong.svc.cluster.local:8761/eureka/,http://eureka-02.didong.svc.cluster.local:8761/eureka/eureka.instance.instance-id = $&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;eureka.instance.prefer-ip-address = true 2.2 覆盖配置问题：客户端与服务端默认是按eureka.client.serviceUrl.defaultZone配置的地址顺序优先选第一个来连接的，导致正常状态下，只有eureka-01被客户端使用，而eureka-02只起到热备作用 解决：将eureka.client.serviceUrl.defaultZone配置的地址顺序打散即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.springframework.cloud.netflix.eureka.EurekaClientConfigBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.ConfigurableEnvironment;import java.util.Collections;import java.util.List;/** * 覆盖 Eureka 默认配置 * * @author lingyuwang * @date 2020-05-18 0:37 * @since 1.1.0 */@Configurationpublic class EurekaClientEnhanceConfig &#123; /** * 将 eureka.client.serviceUrl.defaultZone 配置的多个地址顺序打乱 * 以达到负载均衡的目的（各个客户端均匀地连接到各个Eureka服务器） * * @param env * @return org.springframework.cloud.netflix.eureka.EurekaClientConfigBean * @author lingyuwang * @date 2020-05-18 14:23 * @since 1.1.0 */ @Bean public EurekaClientConfigBean eurekaClientConfigBean(ConfigurableEnvironment env) &#123; EurekaClientConfigBean client = new EurekaClientConfigBean() &#123; @Override public List&lt;String&gt; getEurekaServerServiceUrls(String myZone) &#123; List&lt;String&gt; eurekaServerServiceUrls = super.getEurekaServerServiceUrls(myZone); // 将顺序打乱 Collections.shuffle(eurekaServerServiceUrls); return eurekaServerServiceUrls; &#125; &#125;; if (\"bootstrap\".equals(env.getProperty(\"spring.config.name\"))) &#123; // We don't register during bootstrap by default, but there will be another // chance later. client.setRegisterWithEureka(false); &#125; return client; &#125;&#125; 3 效果","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"注册中心","slug":"注册中心","permalink":"https://zhechu.github.io/tags/注册中心/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"动态规划求解0-1背包问题","slug":"动态规划求解0-1背包问题","date":"2020-05-17T08:24:03.000Z","updated":"2020-11-03T13:04:34.284Z","comments":false,"path":"2020/05/17/动态规划求解0-1背包问题/","link":"","permalink":"https://zhechu.github.io/2020/05/17/动态规划求解0-1背包问题/","excerpt":"","text":"问题：假设购物车中有 n 个（n&gt;100）想买的商品，要求从里面选几个， 在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接 近满减条件（200 元），这样就可以极大限度地“薅羊毛” 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/KnapsackProbByDynamicProgram.java 上一篇 回溯法求解0-1背包问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 求解0-1背包问题（动态规划） * * 问题： * 假设购物车中有 n 个（n&gt;100）想买的商品，要求从里面选几个， * 在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接 * 近满减条件（200 元），这样就可以极大限度地“薅羊毛” * * @author lingyuwang * @date 2020-05-15 20:41 * @since 1.0.4 */public class KnapsackProbByDynamicProgram &#123; public static void main(String[] args) &#123; // 每个商品的价格 int[] itmes = new int[]&#123;120, 215, 140, 310, 65, 80, 35&#125;; // 满减价格 int weight = 200; knapsack(itmes, weight); &#125; /** * 求解 * @param items 每个商品的价格 * @param weight 满减价格 */ public static void knapsack(int[] items, int weight) &#123; int len = items.length; // 可承受价格上限 int maxWeight = weight * 3; boolean[][] states = new boolean[len][maxWeight + 1]; // 第一行的数据要特殊处理 states[0][0] = true; if (items[0] &lt;= maxWeight) &#123; states[0][items[0]] = true; &#125; // 动态规划 for (int i = 1; i &lt; len; ++i) &#123; // 不购买第i个商品（记录所有可能的组合值） for (int j = 0; j &lt;= maxWeight; ++j) &#123; if (states[i - 1][j] == true) &#123; states[i][j] = states[i - 1][j]; &#125; &#125; // 购买第i个商品（记录所有可能的组合值） for (int j = 0; j &lt;= maxWeight - items[i]; ++j) &#123; if (states[i - 1][j] == true) &#123; states[i][j + items[i]] = true; &#125; &#125; &#125; int j; for (j = weight; j &lt; maxWeight + 1; ++j) &#123; // 输出结果大于等于 weight 的最小值 if (states[len - 1][j] == true) &#123; break; &#125; &#125; // 没有可行解 if (j == maxWeight + 1) &#123; return; &#125; // i表示二维数组中的行，j表示列（从 states 状态数组推断） for (int i = len - 1; i &gt;= 1; --i) &#123; // j - items[i] &gt;= 0 是为了防止数组越界 if (j - items[i] &gt;= 0 &amp;&amp; states[i - 1][j - items[i]] == true) &#123; // 购买这个商品 System.out.print(items[i] + \" \"); j = j - items[i]; &#125; // else 没有购买这个商品，j不变 &#125; if (j != 0) &#123; System.out.print(items[0]); &#125; &#125;&#125; 控制台日志180 120","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"回溯法实现字符串匹配","slug":"回溯法实现字符串匹配","date":"2020-05-17T02:55:18.000Z","updated":"2020-11-03T13:04:34.284Z","comments":false,"path":"2020/05/17/回溯法实现字符串匹配/","link":"","permalink":"https://zhechu.github.io/2020/05/17/回溯法实现字符串匹配/","excerpt":"","text":"思路：类似 java.util.regex.Pattern 的功能，只不过用回溯法简单实现 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/Pattern.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 正则表达式匹配（回溯法） */public class Pattern &#123; public static void main(String[] args) &#123;// String regEx = \"http://*.html\"; String regEx = \"http://www.?aidu.com\"; Pattern pattern = new Pattern(regEx); boolean match = pattern.match(\"http://www.baidu.com\"); System.out.println(\"是否匹配：\" + match); match = pattern.match(\"http://www.baidu.com/index.html\"); System.out.println(\"是否匹配：\" + match); &#125; /** 是否匹配 */ private boolean matched = false; /** 正则表达式 */ private char[] pattern; /** 正则表达式长度 */ private int plen; public Pattern(String regEx) &#123; this.pattern = regEx.toCharArray(); this.plen = pattern.length; &#125; /** * 文本串 * @param textStr * @return */ public boolean match(String textStr) &#123; char[] text = textStr.toCharArray(); int tlen = text.length; matched = false; rmatch(0, 0, text, tlen); return matched; &#125; /** * 回溯法匹配 * @param ti 文本索引 * @param pj 正则索引 * @param text 文本 * @param tlen 文本长度 */ private void rmatch(int ti, int pj, char[] text, int tlen) &#123; // 若已匹配，则直接返回 if (matched) &#123; return; &#125; // 正则表达式已到结尾 if (pj == plen) &#123; // 文本串已到结尾 if (ti == tlen) &#123; matched = true; &#125; return; &#125; // *匹配任意个字符 if (pattern[pj] == '*') &#123; for (int k = 0; k &lt;= tlen - ti; ++k) &#123; rmatch(ti + k, pj + 1, text, tlen); &#125; &#125; // ?匹配0个或者1个字符 else if (pattern[pj] == '?') &#123; rmatch(ti, pj + 1, text, tlen); rmatch(ti + 1, pj + 1, text, tlen); &#125; // 纯字符匹配 else if (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; rmatch(ti + 1, pj + 1, text, tlen); &#125; &#125;&#125; 控制台日志12是否匹配：true是否匹配：false","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"回溯法求解0-1背包问题","slug":"回溯法求解0-1背包问题","date":"2020-05-15T14:44:42.000Z","updated":"2020-11-03T13:04:34.284Z","comments":false,"path":"2020/05/15/回溯法求解0-1背包问题/","link":"","permalink":"https://zhechu.github.io/2020/05/15/回溯法求解0-1背包问题/","excerpt":"","text":"0-1背包问题 https://zh.wikipedia.org/wiki/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/KnapsackProbByRecall.java 下一篇 动态规划求解0-1背包问题 1 简单回溯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * 求解0-1背包问题（回溯） * * @author lingyuwang * @date 2020-05-15 20:41 * @since 1.0.4 */public class KnapsackProbByRecall &#123; public static void main(String[] args) &#123; // 每个物品的重量 int[] itmes = new int[]&#123;20, 15, 40, 10, 65, 80, 35&#125;; // 背包可承受重量 int weight = 100; ResultDTO resultDTO = getResult(itmes, weight); System.out.println(resultDTO); &#125; /** * 获取能装入背包的物品结果 * @param items 每个物品的重量 * @param weight 背包可承受重量 * @return */ public static ResultDTO getResult(int[] items, int weight) &#123; int len = items.length; ResultDTO resultDTO = new ResultDTO(len); // 临时解 int[] tempAnswer = new int[len]; cal(resultDTO, tempAnswer, 0,0, items, len, weight); return resultDTO; &#125; /** * * @param resultDTO 结果 * @param i 物品索引 * @param cw 当前已经装进去的物品的重量和 * @param items 每个物品的重量 * @param n 物品个数 * @param w 背包重量 */ public static void cal(ResultDTO resultDTO, int[] tempAnswer, int i, int cw, int[] items, int n, int w) &#123; // cw==w 表示装满了; i==n 表示已经考察完所有的物品 if (cw == w || i == n) &#123; // 打印当前方案 print(items, tempAnswer); if (cw &gt; resultDTO.maxW) &#123; resultDTO.maxW = cw; for (int j = 0; j &lt; n; j++) &#123; resultDTO.bestAnswer[j] = tempAnswer[j]; &#125; &#125; return; &#125; // 回溯（回溯法的关键步骤，先调用，后计算） cal(resultDTO, tempAnswer, i + 1, cw, items, n, w); // 未超过背包可以承受的重量才继续装 if (cw + items[i] &lt;= w) &#123; // 装入背包的物品设置为 1 tempAnswer[i] = 1; cal(resultDTO, tempAnswer, i + 1,cw + items[i], items, n, w); &#125; // 清除已有状态，重新回到未设置状态 tempAnswer[i] = 0; &#125; private static void print(int[] items, int[] bestAnswer) &#123; int bestPrice = 0; System.out.print(\"路径为：\"); for (int i = 0; i &lt; bestAnswer.length; i++) &#123; bestPrice += bestAnswer[i] == 1 ? items[i] : 0; System.out.print(bestAnswer[i]); &#125; System.out.println(\" 价值为\" + bestPrice); &#125;&#125;/** * 结果 */class ResultDTO &#123; /** 存储背包中物品总重量的最大值 */ public int maxW = Integer.MIN_VALUE; /** 最优解 */ public int[] bestAnswer; public ResultDTO(int length) &#123; this.bestAnswer = new int[length]; &#125; @Override public String toString() &#123; return \"ResultDTO&#123;\" + \"maxW=\" + maxW + \", bestAnswer=\" + Arrays.toString(bestAnswer) + '&#125;'; &#125;&#125; 控制台日志123456789101112131415161718192021222324252627282930313233343536373839404142路径为：0000000 价值为0路径为：0000001 价值为35路径为：0000010 价值为80路径为：0000100 价值为65路径为：0000101 价值为100路径为：0001000 价值为10路径为：0001001 价值为45路径为：0001010 价值为90路径为：0001100 价值为75路径为：0010000 价值为40路径为：0010001 价值为75路径为：0011000 价值为50路径为：0011001 价值为85路径为：0100000 价值为15路径为：0100001 价值为50路径为：0100010 价值为95路径为：0100100 价值为80路径为：0101000 价值为25路径为：0101001 价值为60路径为：0101100 价值为90路径为：0110000 价值为55路径为：0110001 价值为90路径为：0111000 价值为65路径为：0111001 价值为100路径为：1000000 价值为20路径为：1000001 价值为55路径为：1000010 价值为100路径为：1000100 价值为85路径为：1001000 价值为30路径为：1001001 价值为65路径为：1001100 价值为95路径为：1010000 价值为60路径为：1010001 价值为95路径为：1011000 价值为70路径为：1100000 价值为35路径为：1100001 价值为70路径为：1100100 价值为100路径为：1101000 价值为45路径为：1101001 价值为80路径为：1110000 价值为75路径为：1111000 价值为85ResultDTO&#123;maxW=100, bestAnswer=[0, 0, 0, 0, 1, 0, 1]&#125; 2 回溯剪枝优点：效率更高 缺点：未列出所有可能的路径 TIPS：相同承重结果的不同路径会被跳过，不再计算。因此，效率也高 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** * 求解0-1背包问题（回溯） * * @author lingyuwang * @date 2020-05-15 20:41 * @since 1.0.4 */public class KnapsackProbByRecall &#123; public static void main(String[] args) &#123; // 每个物品的重量 int[] itmes = new int[]&#123;20, 15, 40, 10, 65, 80, 35&#125;; // 背包可承受重量 int weight = 100; ResultDTO resultDTO = getResult(itmes, weight); System.out.println(resultDTO); &#125; /** * 获取能装入背包的物品结果 * @param items 每个物品的重量 * @param weight 背包可承受重量 * @return */ public static ResultDTO getResult(int[] items, int weight) &#123; int len = items.length; ResultDTO resultDTO = new ResultDTO(len); // 临时解 int[] tempAnswer = new int[len]; // 备忘录 boolean[][] mem = new boolean[len][weight]; cal(resultDTO, tempAnswer, mem, 0,0, items, len, weight); return resultDTO; &#125; /** * * @param resultDTO 结果 * @param i 物品索引 * @param cw 当前已经装进去的物品的重量和 * @param items 每个物品的重量 * @param n 物品个数 * @param w 背包重量 */ public static void cal(ResultDTO resultDTO, int[] tempAnswer, boolean[][] mem, int i, int cw, int[] items, int n, int w) &#123; // cw==w 表示装满了; i==n 表示已经考察完所有的物品 if (cw == w || i == n) &#123; // 打印当前方案 print(items, tempAnswer); if (cw &gt; resultDTO.maxW) &#123; resultDTO.maxW = cw; for (int j = 0; j &lt; n; j++) &#123; resultDTO.bestAnswer[j] = tempAnswer[j]; &#125; &#125; return; &#125; // 重复状态 if (mem[i][cw]) &#123; return; &#125; // 记录(i, cw)这个状态 mem[i][cw] = true; // 回溯（回溯法的关键步骤，先调用，后计算） cal(resultDTO, tempAnswer, mem, i + 1, cw, items, n, w); // 未超过背包可以承受的重量才继续装 if (cw + items[i] &lt;= w) &#123; // 装入背包的物品设置为 1 tempAnswer[i] = 1; cal(resultDTO, tempAnswer, mem, i + 1,cw + items[i], items, n, w); &#125; // 清除已有状态，重新回到未设置状态 tempAnswer[i] = 0; &#125; private static void print(int[] items, int[] bestAnswer) &#123; int bestPrice = 0; System.out.print(\"路径为：\"); for (int i = 0; i &lt; bestAnswer.length; i++) &#123; bestPrice += bestAnswer[i] == 1 ? items[i] : 0; System.out.print(bestAnswer[i]); &#125; System.out.println(\" 价值为\" + bestPrice); &#125;&#125;/** * 结果 */class ResultDTO &#123; /** 存储背包中物品总重量的最大值 */ public int maxW = Integer.MIN_VALUE; /** 最优解 */ public int[] bestAnswer; public ResultDTO(int length) &#123; this.bestAnswer = new int[length]; &#125; @Override public String toString() &#123; return \"ResultDTO&#123;\" + \"maxW=\" + maxW + \", bestAnswer=\" + Arrays.toString(bestAnswer) + '&#125;'; &#125;&#125; 控制台日志1234567891011121314151617181920212223242526272829303132333435路径为：0000000 价值为0路径为：0000001 价值为35路径为：0000010 价值为80路径为：0000100 价值为65路径为：0000101 价值为100路径为：0001000 价值为10路径为：0001001 价值为45路径为：0001010 价值为90路径为：0001100 价值为75路径为：0010000 价值为40路径为：0010001 价值为75路径为：0011000 价值为50路径为：0011001 价值为85路径为：0100000 价值为15路径为：0100001 价值为50路径为：0100010 价值为95路径为：0101000 价值为25路径为：0101001 价值为60路径为：0110000 价值为55路径为：0110001 价值为90路径为：1000000 价值为20路径为：1000001 价值为55路径为：1000010 价值为100路径为：1000100 价值为85路径为：1001000 价值为30路径为：1001001 价值为65路径为：1010000 价值为60路径为：1010001 价值为95路径为：1011000 价值为70路径为：1100000 价值为35路径为：1100001 价值为70路径为：1100100 价值为100路径为：1101000 价值为45路径为：1101001 价值为80ResultDTO&#123;maxW=100, bestAnswer=[0, 0, 0, 0, 1, 0, 1]&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"分治法求解平面最接近点对","slug":"分治法求解平面最接近点对","date":"2020-05-12T15:47:19.000Z","updated":"2020-11-03T13:04:34.279Z","comments":false,"path":"2020/05/12/分治法求解平面最接近点对/","link":"","permalink":"https://zhechu.github.io/2020/05/12/分治法求解平面最接近点对/","excerpt":"","text":"思想 http://www.360doc.com/content/19/0303/18/32937624_818850914.shtml 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/MinDis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** * 求解平面最接近点对 * * @author lingyuwang * @date 2020-05-12 23:45 * @since 1.0.4 */public class MinDis &#123; public static void main(String[] args) &#123; // 测试用例 Point[] points = new Point[7]; points[0] = new Point(1, 1); points[1] = new Point(1, 9); points[2] = new Point(2, 5); points[3] = new Point(3, 1); points[4] = new Point(4, 4); points[5] = new Point(5, 8); points[6] = new Point(6, 2); // 预处理，基于x轴坐标排序，便于实施分治法 Arrays.sort(points, (p1, p2) -&gt; (p1.x &gt; p2.x) ? 1 : (p1.x == p2.x) ? 0 : -1); // 测试 System.out.println(cal(points)); &#125; /** * 计算 * @param points * @return */ public static PointResult cal(Point[] points) &#123; if (points == null) &#123; throw new NullPointerException(); &#125; return divide(0, points.length - 1, points); &#125; /** * 求平面上距离最近的两个点 */ private static PointResult divide(int left, int right, Point[] points) &#123; // 若只有一个点，则不存在最近两点距离，返回无穷大 if (left == right) &#123; return new PointResult(points[left], null, Double.MAX_VALUE); &#125; // 若只有两个点，则直接求解 if (left + 1 == right) &#123; return new PointResult(points[left], points[right], distance(points[left], points[right])); &#125; // 分治法：第一步：分区，并求取左右分区最小两点距离 // 通过右移运算除2，对区域进行合理的划分，使得左右两边保持大致相等个数点 int middle = (left + right) &gt;&gt; 1; PointResult leftPointResult = divide(left, middle, points); PointResult rightPointResult = divide(middle + 1, right, points); PointResult curMinPointResult = leftPointResult; if (rightPointResult.distance &lt; leftPointResult.distance) &#123; curMinPointResult = rightPointResult; &#125; // 分治法：第二步：假设距离最近的两点分别在左右分区中，x轴搜索范围[middle - curMinDis, middle + curMinDis] curMinPointResult = getMinPointResult(left, middle, right, curMinPointResult, points); return curMinPointResult; &#125; /** * 获取结果 * @param left * @param middle * @param right * @param curMinPointResult * @param points * @return */ private static PointResult getMinPointResult(int left, int middle, int right, PointResult curMinPointResult, Point[] points) &#123; // 记录搜索区间内的点的索引，便于进一步计算最小距离 List&lt;Integer&gt; validPointIndexList = new ArrayList&lt;&gt;(); for (int i = left; i &lt;= right; i++) &#123; if (Math.abs(points[middle].x - points[i].x) &lt;= curMinPointResult.distance) &#123; validPointIndexList.add(i); &#125; &#125; // 基于索引，进一步计算区间内最小两点距离 int size = validPointIndexList.size(); for (int i = 0; i &lt; size - 1; i++) &#123; for (int j = i + 1; j &lt; size; j++) &#123; // 若区间内的两点y轴距离大于curMinDis，则表明其距离肯定大于curMinDis if (Math.abs(points[validPointIndexList.get(i)].y - points[validPointIndexList.get(j)].y) &gt; curMinPointResult.distance) &#123; continue; &#125; Point pi = points[validPointIndexList.get(i)]; Point pj = points[validPointIndexList.get(j)]; double tempDis = distance(pi, pj); if (tempDis &lt; curMinPointResult.distance) &#123; curMinPointResult = new PointResult(pi, pj, tempDis); &#125; &#125; &#125; return curMinPointResult; &#125; /** * 计算两点间的距离 */ private static double distance(Point p1, Point p2) &#123; return Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2)); &#125;&#125;/** * 定义点 */class Point &#123; public int x; public int y; Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"Point&#123;\" + \"x=\" + x + \", y=\" + y + '&#125;'; &#125;&#125;/** * 结果 */class PointResult &#123; public Point p1; public Point p2; public double distance; public PointResult(Point p1, Point p2, double distance) &#123; this.p1 = p1; this.p2 = p2; this.distance = distance; &#125; @Override public String toString() &#123; return \"PointResult&#123;\" + \"p1=\" + p1 + \", p2=\" + p2 + \", distance=\" + distance + '&#125;'; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"统计数组逆序对个数","slug":"统计数组逆序对个数","date":"2020-05-10T15:19:03.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/05/10/统计数组逆序对个数/","link":"","permalink":"https://zhechu.github.io/2020/05/10/统计数组逆序对个数/","excerpt":"","text":"思路：基于归并排序，统计数组逆序对个数。所以额外空间复杂度和时间复杂度与归并排序一样。 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/apply/OrderPair.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 统计数组的正/逆序对个数 */public class OrderPair &#123; public static void main(String[] args) &#123; int[] arr = generateRandomArray(10, 10); int[] arr2 = copyArray(arr); int[] arrBak = copyArray(arr); printArray(arr); // 逆序对个数 int reverseOrderPairCount = getOrderPairCount(arr, true); System.out.println(\"数组长度为:\" + arrBak.length + \", 逆序对个数为:\" + reverseOrderPairCount + \"个\"); System.out.println(\"--------------------------------分割线-----------------------------------\"); // 正序对个数 int orderPairCount = getOrderPairCount(arr2, false); System.out.println(\"数组长度为:\" + arrBak.length + \", 正序对个数为:\" + orderPairCount + \"个\"); &#125; /** * 获取正/逆序对个数 * @param arr 数组 * @param reverse 是否获取逆序对 * @return */ public static int getOrderPairCount(int[] arr, boolean reverse) &#123; AtomicInteger count = new AtomicInteger(0); int len = arr.length; mergeSortCounting(arr, 0, len - 1, reverse, count); return count.get(); &#125; private static void mergeSortCounting(int[] arr, int p, int r, boolean reverse, AtomicInteger count) &#123; if (p &gt;= r) &#123; return; &#125; int q = (p + r) / 2; mergeSortCounting(arr, p, q, reverse, count); mergeSortCounting(arr, q + 1, r, reverse, count); merge(arr, p, q, r, reverse, count); &#125; private static void merge(int[] arr, int p, int q, int r, boolean reverse, AtomicInteger count) &#123; int i = p, j = q + 1, k = 0; int[] tmp = new int[r - p + 1]; while (i &lt;= q &amp;&amp; j &lt;= r) &#123; // 逆序对 if (reverse) &#123; if (arr[i] &lt;= arr[j]) &#123; tmp[k++] = arr[i++]; &#125; else &#123; // 统计 p - q 之间，比 a[j] 大的元素个数 count.addAndGet(q - i + 1); tmp[k++] = arr[j++]; &#125; &#125; // 正序对 else &#123; if (arr[i] &lt;= arr[j]) &#123; // 统计 r - q 之间，比 a[j] 大的元素个数 count.addAndGet(r - j + 1); tmp[k++] = arr[i++]; &#125; else &#123; tmp[k++] = arr[j++]; &#125; &#125; &#125; // 处理剩下的 while (i &lt;= q) &#123; tmp[k++] = arr[i++]; &#125; // 处理剩下的 while (j &lt;= r) &#123; tmp[k++] = arr[j++]; &#125; // 从 tmp 拷贝回 arr for (i = 0; i &lt;= r - p; ++i) &#123; arr[p + i] = tmp[i]; &#125; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 控制台日志 1234-2 -1 2 3 -2数组长度为:5, 逆序对个数为:3个--------------------------------分割线-----------------------------------数组长度为:5, 正序对个数为:7个","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"有限状态机","slug":"有限状态机","date":"2020-05-02T08:52:37.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2020/05/02/有限状态机/","link":"","permalink":"https://zhechu.github.io/2020/05/02/有限状态机/","excerpt":"","text":"1 定义有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。 2 结构 角色 说明 State 流程所处的节点状态，如：“待审核”，“审核通过”，“审核拒绝” Event 流程都是在节点上触发了某个事件才往下走更改状态的，如：“待审核”触发了“通过”事件才变成“审核通过”的 Transition 流程流转过程中具体的业务逻辑，如：“待审核”触发“通过”事件变成“审核通过”，这中间可能需要记录日志，持久化状态等操作 3 使用场景 OA 订单状态流转 4 示例4.1 内容审核示例代码 https://github.com/zhechu/design-pattern-demo/blob/master/src/main/java/com/wise/state/StateMachineClient.java 4.1.1 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159import com.wise.state.dto.DownDTO;import com.wise.state.dto.PassDTO;import com.wise.state.dto.RefuseDTO;import com.wise.state.dto.UpDTO;/** * 状态机客户端 */public class StateMachineClient &#123; public static void main(String[] args) &#123;// allDemo();// machineRefuseDemo(); manualRefuseDemo(); &#125; /** * 全流程通过示例 * 待审核 -&gt; 机审通过 -&gt; 人工审核通过 -&gt; 上架 -&gt; 下架 -&gt; 销毁 */ public static void allDemo() &#123; // 状态机 ContentAuditStateMachine contentAuditStateMachine = new ContentAuditStateMachine(); // TODO 可以将状态和事件提前定义好，交给 Spring 管理，然后通过状态标识和事件标识找到对应的实例，简化编程 // 审核通过参数 PassDTO passDTO = new PassDTO(); passDTO.setContentId(\"1\"); // 当前状态为待审核，即将执行机审通过事件 State state = contentAuditStateMachine.execute( contentAuditStateMachine.getState(ContentAuditStateMachine.StateCodeContents.PENDING), new ContentAuditStateMachine.MachineAuditPassEvent(passDTO) ); System.out.println(\"执行机审通过事件后状态:\" + state); // 当前状态为机审通过，即将执行人工审核通过事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.ManualAuditPassEvent(passDTO) ); System.out.println(\"执行人工审核通过事件后状态:\" + state); // 上架参数 UpDTO upDTO = new UpDTO(); upDTO.setContentId(\"1\"); // 当前状态为人工审核通过，即将执行上架事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.UpEvent(upDTO) ); System.out.println(\"执行上架事件后状态:\" + state); // 下架参数 DownDTO downDTO = new DownDTO(); downDTO.setContentId(\"1\"); downDTO.setReason(\"内容已过期\"); // 当前状态为上架，即将执行下架事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.DownEvent(downDTO) ); System.out.println(\"执行下架事件后状态:\" + state); // 当前状态为下架，即将执行删除内容事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.DeleteContentEvent(\"1\") ); System.out.println(\"最终状态:\" + state); &#125; /** * 机审拒绝示例 * 待审核 -&gt; 机审拒绝 -&gt; 销毁 */ public static void machineRefuseDemo() &#123; // 状态机 ContentAuditStateMachine contentAuditStateMachine = new ContentAuditStateMachine(); // TODO 可以将状态和事件提前定义好，交给 Spring 管理，然后通过状态标识和事件标识找到对应的实例，简化编程 // 审核拒绝参数 RefuseDTO refuseDTO = new RefuseDTO(); refuseDTO.setContentId(\"2\"); refuseDTO.setReason(\"涉政\"); // 当前状态为待审核，即将执行机审拒绝事件 State state = contentAuditStateMachine.execute( contentAuditStateMachine.getState(ContentAuditStateMachine.StateCodeContents.PENDING), new ContentAuditStateMachine.MachineAuditRefuseEvent(refuseDTO) ); System.out.println(\"执行机审拒绝事件后状态:\" + state); // 当前状态为机审不通过，即将执行删除内容事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.DeleteContentEvent(\"2\") ); System.out.println(\"最终状态:\" + state); &#125; /** * 人工审核拒绝示例 * 待审核 -&gt; 机审通过 -&gt; 人工审核不通过 -&gt; 销毁 */ public static void manualRefuseDemo() &#123; // 状态机 ContentAuditStateMachine contentAuditStateMachine = new ContentAuditStateMachine(); // TODO 可以将状态和事件提前定义好，交给 Spring 管理，然后通过状态标识和事件标识找到对应的实例，简化编程 // 审核通过参数 PassDTO passDTO = new PassDTO(); passDTO.setContentId(\"3\"); // 当前状态为待审核，即将执行机审通过事件 State state = contentAuditStateMachine.execute( contentAuditStateMachine.getState(ContentAuditStateMachine.StateCodeContents.PENDING), new ContentAuditStateMachine.MachineAuditPassEvent(passDTO) ); System.out.println(\"执行机审通过事件后状态:\" + state); // 审核拒绝参数 RefuseDTO refuseDTO = new RefuseDTO(); refuseDTO.setContentId(\"3\"); refuseDTO.setReason(\"涉黄\"); // 当前状态为机审通过，即将执行人工审核拒绝事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.ManualAuditRefuseEvent(refuseDTO) ); System.out.println(\"执行人工审核拒绝事件后状态:\" + state); // 当前状态为人工审核不通过，即将执行删除内容事件 state = contentAuditStateMachine.execute( state, new ContentAuditStateMachine.DeleteContentEvent(\"3\") ); System.out.println(\"最终状态:\" + state); &#125;&#125; 4.1.2 状态机基类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.Map;/** * 状态机基类 * 维护该状态机所有支持的状态，以及调用入口 */public abstract class StateMachine &#123; /** 定义的所有状态 */ private static Map&lt;String, State&gt; allStateMap = null; /** * 状态机执行事件 * @param state * @param event * @return */ public State execute(State state, Event event) &#123; Transition transition = state.getTransition(event.getEventCode()); if (transition != null) &#123; return transition.execute(event); &#125; System.out.println(String.format(\"StateMachine[%s] Can not find transition for stateCode[%s] eventCode[%s]\", this.getClass().getSimpleName(), state.getStateCode(), event.getEventCode())); return null; &#125; /** * 获取状态 * @param stateCode 状态编码 * @return */ public State getState(String stateCode) &#123; if (allStateMap == null) &#123; System.out.println(\"StateMachine declareAllStates\"); allStateMap = this.declareAllState(); &#125; return allStateMap.get(stateCode); &#125; /** * 由具体的状态机定义所有状态 * @return */ public abstract Map&lt;String, State&gt; declareAllState();&#125; 4.1.3 内容审核状态机123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302import com.wise.state.dto.DownDTO;import com.wise.state.dto.PassDTO;import com.wise.state.dto.RefuseDTO;import com.wise.state.dto.UpDTO;import java.util.HashMap;import java.util.Map;/** * 内容审核状态机 */public class ContentAuditStateMachine extends StateMachine &#123; @Override public Map&lt;String, State&gt; declareAllState() &#123; Map&lt;String, State&gt; stateMap = new HashMap&lt;&gt;(8); State pendingState = new State(StateCodeContents.PENDING); State machineAuditPassedState = new State(StateCodeContents.MACHINE_AUDIT_PASSED); State machineAuditRefusedState = new State(StateCodeContents.MACHINE_AUDIT_REFUSED); State manualAuditPassedState = new State(StateCodeContents.MANUAL_AUDIT_PASSED); State manualAuditRefusedState = new State(StateCodeContents.MANUAL_AUDIT_REFUSED); State upState = new State(StateCodeContents.UP); State downState = new State(StateCodeContents.DOWN); State destoryState = new State(StateCodeContents.DESTROY); // 待审核状态添加机审通过和机审拒绝行为 pendingState.addTransition(new MachineAuditPassTransition(pendingState, machineAuditPassedState)); pendingState.addTransition(new MachineAuditRefuseTransition(pendingState, machineAuditRefusedState)); // 机审通过状态添加人工审核通过和人工审核拒绝行为 machineAuditPassedState.addTransition(new ManualAuditPassTransition(machineAuditPassedState, manualAuditPassedState)); machineAuditPassedState.addTransition(new ManualAuditRefuseTransition(machineAuditPassedState, manualAuditRefusedState)); // 机审不通过状态添加删除内容行为 machineAuditRefusedState.addTransition(new DeleteContentTransition(machineAuditRefusedState, destoryState)); // 人工审核通过状态添加上架行为 manualAuditPassedState.addTransition(new UpTransition(manualAuditPassedState, upState)); // 人工审核不通过状态添加删除内容行为 manualAuditRefusedState.addTransition(new DeleteContentTransition(manualAuditRefusedState, destoryState)); // 上架状态添加下架行为 upState.addTransition(new DownTransition(upState, downState)); // 下架状态添加删除内容行为 downState.addTransition(new DeleteContentTransition(downState, destoryState)); stateMap.put(pendingState.getStateCode(), pendingState); stateMap.put(machineAuditPassedState.getStateCode(), machineAuditPassedState); stateMap.put(machineAuditRefusedState.getStateCode(), machineAuditRefusedState); stateMap.put(manualAuditPassedState.getStateCode(), manualAuditPassedState); stateMap.put(manualAuditRefusedState.getStateCode(), manualAuditRefusedState); stateMap.put(upState.getStateCode(), upState); stateMap.put(downState.getStateCode(), downState); stateMap.put(destoryState.getStateCode(), destoryState); return stateMap; &#125; /** 定义“机审通过”动作 */ public class MachineAuditPassTransition extends Transition&lt;MachineAuditPassEvent&gt; &#123; public MachineAuditPassTransition(State currState, State nextState) &#123; super(EventCodeContents.MACHINE_AUDIT_PASS, currState, nextState); &#125; @Override protected boolean doExecute(MachineAuditPassEvent event) &#123; System.out.println(\"执行机审通过操作开始...\"); PassDTO passDTO = event.getParam(); System.out.println(\"执行机审通过操作参数:\" + passDTO); System.out.println(\"执行机审通过操作结束...\"); return true; &#125; &#125; /** 定义“机审拒绝”动作 */ public class MachineAuditRefuseTransition extends Transition&lt;MachineAuditRefuseEvent&gt; &#123; public MachineAuditRefuseTransition(State currState, State nextState) &#123; super(EventCodeContents.MACHINE_AUDIT_REFUSE, currState, nextState); &#125; @Override protected boolean doExecute(MachineAuditRefuseEvent event) &#123; System.out.println(\"执行机审拒绝操作开始...\"); RefuseDTO refuseDTO = event.getParam(); System.out.println(\"执行机审拒绝操作参数:\" + refuseDTO); System.out.println(\"执行机审拒绝操作结束...\"); return true; &#125; &#125; /** 定义“人工审核通过”动作 */ public class ManualAuditPassTransition extends Transition&lt;ManualAuditPassEvent&gt; &#123; public ManualAuditPassTransition(State currState, State nextState) &#123; super(EventCodeContents.MANUAL_AUDIT_PASS, currState, nextState); &#125; @Override protected boolean doExecute(ManualAuditPassEvent event) &#123; System.out.println(\"执行人工审核通过操作开始...\"); PassDTO passDTO = event.getParam(); System.out.println(\"执行人工审核通过操作参数:\" + passDTO); System.out.println(\"执行人工审核通过操作结束...\"); return true; &#125; &#125; /** 定义“人工审核拒绝”动作 */ public class ManualAuditRefuseTransition extends Transition&lt;ManualAuditRefuseEvent&gt; &#123; public ManualAuditRefuseTransition(State currState, State nextState) &#123; super(EventCodeContents.MANUAL_AUDIT_REFUSE, currState, nextState); &#125; @Override protected boolean doExecute(ManualAuditRefuseEvent event) &#123; System.out.println(\"执行人工审核拒绝操作开始...\"); RefuseDTO refuseDTO = event.getParam(); System.out.println(\"执行人工审核拒绝操作参数:\" + refuseDTO); System.out.println(\"执行人工审核拒绝操作结束...\"); return true; &#125; &#125; /** 定义“上架”动作 */ public class UpTransition extends Transition&lt;UpEvent&gt; &#123; public UpTransition(State currState, State nextState) &#123; super(EventCodeContents.UP, currState, nextState); &#125; @Override protected boolean doExecute(UpEvent event) &#123; System.out.println(\"执行上架操作开始...\"); UpDTO upDTO = event.getParam(); System.out.println(\"执行上架操作参数:\" + upDTO); System.out.println(\"执行上架操作结束...\"); return true; &#125; &#125; /** 定义“下架”动作 */ public class DownTransition extends Transition&lt;DownEvent&gt; &#123; public DownTransition(State currState, State nextState) &#123; super(EventCodeContents.DOWN, currState, nextState); &#125; @Override protected boolean doExecute(DownEvent event) &#123; System.out.println(\"执行下架操作开始...\"); DownDTO downDTO = event.getParam(); System.out.println(\"执行下架操作参数:\" + downDTO); System.out.println(\"执行下架操作结束...\"); return true; &#125; &#125; /** 定义“删除内容”动作 */ public class DeleteContentTransition extends Transition&lt;DeleteContentEvent&gt; &#123; public DeleteContentTransition(State currState, State nextState) &#123; super(EventCodeContents.DELETE_CONTENT, currState, nextState); &#125; @Override protected boolean doExecute(DeleteContentEvent event) &#123; System.out.println(\"执行删除内容操作开始...\"); String contentId = event.getParam(); System.out.println(\"执行删除内容操作参数:\" + contentId); System.out.println(\"执行删除内容操作结束...\"); return true; &#125; &#125; /** * 机审通过事件 */ public static class MachineAuditPassEvent extends Event&lt;PassDTO&gt; &#123; public MachineAuditPassEvent(PassDTO bizParam) &#123; super(EventCodeContents.MACHINE_AUDIT_PASS, bizParam); &#125; &#125; /** * 机审拒绝事件 */ public static class MachineAuditRefuseEvent extends Event&lt;RefuseDTO&gt; &#123; public MachineAuditRefuseEvent(RefuseDTO refuseDTO) &#123; super(EventCodeContents.MACHINE_AUDIT_REFUSE, refuseDTO); &#125; &#125; /** * 人工审核通过事件 */ public static class ManualAuditPassEvent extends Event&lt;PassDTO&gt; &#123; public ManualAuditPassEvent(PassDTO bizParam) &#123; super(EventCodeContents.MANUAL_AUDIT_PASS, bizParam); &#125; &#125; /** * 人工审核拒绝事件 */ public static class ManualAuditRefuseEvent extends Event&lt;RefuseDTO&gt; &#123; public ManualAuditRefuseEvent(RefuseDTO refuseDTO) &#123; super(EventCodeContents.MANUAL_AUDIT_REFUSE, refuseDTO); &#125; &#125; /** * 上架事件 */ public static class UpEvent extends Event&lt;UpDTO&gt; &#123; public UpEvent(UpDTO upDTO) &#123; super(EventCodeContents.UP, upDTO); &#125; &#125; /** * 下架事件 */ public static class DownEvent extends Event&lt;DownDTO&gt; &#123; public DownEvent(DownDTO downDTO) &#123; super(EventCodeContents.DOWN, downDTO); &#125; &#125; /** * 删除内容事件 */ public static class DeleteContentEvent extends Event&lt;String&gt; &#123; public DeleteContentEvent(String contentId) &#123; super(EventCodeContents.DELETE_CONTENT, contentId); &#125; &#125; /** 事件编码 */ public class EventCodeContents &#123; public static final String MACHINE_AUDIT_PASS = \"机审通过\"; public static final String MACHINE_AUDIT_REFUSE = \"机审拒绝\"; public static final String MANUAL_AUDIT_PASS = \"人工审核通过\"; public static final String MANUAL_AUDIT_REFUSE = \"人工审核拒绝\"; public static final String UP = \"上架\"; public static final String DOWN = \"下架\"; public static final String DELETE_CONTENT = \"删除内容\"; &#125; /** 状态编码 */ public class StateCodeContents &#123; public static final String PENDING = \"待审核\"; public static final String MACHINE_AUDIT_PASSED = \"机审通过\"; public static final String MACHINE_AUDIT_REFUSED = \"机审不通过\"; public static final String MANUAL_AUDIT_PASSED = \"人工审核通过\"; public static final String MANUAL_AUDIT_REFUSED = \"人工审核不通过\"; public static final String UP = \"上架\"; public static final String DOWN = \"下架\"; public static final String DESTROY = \"销毁\"; &#125;&#125; 4.1.4 状态类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;/** * 状态节点 * 维护状态编码，以及该状态下可支持的动作 */public class State &#123; /** 状态编码 */ private String stateCode; /** * 当前状态下可允许执行的动作 * 状态与事件的关系：一对多 * 事件与行为的关系：一对一 * 状态与行为的间接关系：一对多 */ private Map&lt;String, Transition&gt; transitionMap = new HashMap&lt;&gt;(); public State(String stateCode, Transition... transitions) &#123; this.stateCode = stateCode; for (Transition transition : transitions) &#123; this.addTransition(transition); &#125; &#125; public String getStateCode() &#123; return stateCode; &#125; public Transition getTransition(String eventCode) &#123; return transitionMap.get(eventCode); &#125; /** * 添加动作 * @param transition */ public void addTransition(Transition transition) &#123; transitionMap.put(transition.getEventCode(), transition); &#125; @Override public String toString() &#123; return stateCode; &#125;&#125; 4.1.5 事件类12345678910111213141516171819202122232425262728import lombok.Getter;import lombok.Setter;/** * 触发的事件 * 维护事件编码，以及事件附属的业务参数信息 */public abstract class Event&lt;T&gt; &#123; /** 事件标识(编码) */ @Getter private String eventCode; /** 附属的业务参数 */ @Getter @Setter private T param; public Event(String eventCode) &#123; this.eventCode = eventCode; &#125; public Event(String eventCode, T param) &#123; this.eventCode = eventCode; this.param = param; &#125;&#125; 4.1.6 动作基类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import lombok.Getter;/** * 动作基类 * 维护触发该动作的事件，触发前状态，触发后状态，以及具体的动作内容 */public abstract class Transition&lt;E extends Event&gt; &#123; /** 触发事件 */ @Getter private String eventCode; /** 触发当前状态 */ @Getter private State currState; /** 触发后状态 */ @Getter private State nextState; public Transition(String eventCode, State currState, State nextState) &#123; this.eventCode = eventCode; this.currState = currState; this.nextState = nextState; &#125; /** * 执行动作 * @param event * @return */ public State execute(E event) &#123; System.out.println(String.format(\"当前是：%s 状态，执行：%s 操作后，流转成：%s 状态。\", currState, eventCode, nextState)); if (this.doExecute(event)) &#123; return this.nextState; &#125; else &#123; return null; &#125; &#125; /** * 执行动作的具体业务 * @param event * @return */ protected abstract boolean doExecute(E event);&#125; 4.1.7 传输对象类审核通过业务参数类123456789101112import lombok.Data;/** * 审核通过业务参数 */@Datapublic class PassDTO &#123; /** 内容ID */ private String contentId;&#125; 审核拒绝业务参数类123456789101112131415import lombok.Data;/** * 审核拒绝业务参数 */@Datapublic class RefuseDTO &#123; /** 内容ID */ private String contentId; /** 拒绝理由 */ private String reason;&#125; 上架业务参数类123456789101112import lombok.Data;/** * 上架业务参数 */@Datapublic class UpDTO &#123; /** 内容ID */ private String contentId;&#125; 下架业务参数类123456789101112131415import lombok.Data;/** * 下架业务参数 */@Datapublic class DownDTO &#123; /** 内容ID */ private String contentId; /** 拒绝理由 */ private String reason;&#125; 4.2 内容审核（基于spring-statemachine）示例代码 https://github.com/zhechu/spring-statemachine-starter-demo/tree/contentAudit 官方文档 https://docs.spring.io/spring-statemachine/docs/2.1.3.RELEASE/reference/#preface 官方示例 https://github.com/spring-projects/spring-statemachine/tree/v2.1.3.RELEASE/spring-statemachine-samples 月挂夜中央的详细教程及示例源码 https://gitee.com/wphmoon/statemachine 独钓寒江雪_520的订单流程实现 https://www.jianshu.com/p/20d7f7c37b03 4.2.1 入口类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169@SpringBootApplication@Slf4jpublic class Application implements CommandLineRunner &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Autowired private ContentAuditStateMachineBuilder contentAuditStateMachineBuilder; @Autowired @Qualifier(\"contentAuditPersister\") private StateMachinePersister&lt;States, Events, AuditContent&gt; contentAuditPersister; @Override public void run(String... args) throws Exception &#123;// machineAuditDemo();// manualAuditDemo(); reUpDemo(); &#125; /** * 恢复上架示例 * * @author lingyuwang * @date 2020-05-10 12:10 * @since 1.0.9 */ private void reUpDemo() throws Exception &#123; StateMachine&lt;States,Events&gt; stateMachine = contentAuditStateMachineBuilder.build(); // 参数 AuditContent auditContent = new AuditContent(); auditContent.setContentId(1L);// auditContent.setTextContent(\"肯定涉政啊\");// auditContent.setTextContent(\"肯定涉黄啊\"); auditContent.setTextContent(\"正常文本\"); // TODO 参数校验 // TODO 从数据库获取当前状态 auditContent.setStateCode(States.MACHINE_AUDIT_PASSED.getCode()); // 恢复 contentAuditPersister.restore(stateMachine, auditContent); Message&lt;Events&gt; message = MessageBuilder.withPayload(Events.MANUAL_AUDIT) .setHeader(\"auditContent\", auditContent).build(); stateMachine.sendEvent(message); // 异常处理 if (stateMachine.getExtendedState().getVariables().containsKey(\"hasError\")) &#123; throw (RuntimeException)stateMachine.getExtendedState().getVariables().get(\"error\"); &#125; log.info(\"人工审核后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.UP); log.info(\"上架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.DOWN); log.info(\"下架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.RE_UP); log.info(\"恢复上架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.DOWN); log.info(\"再次下架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.DELETE_CONTENT); log.info(\"删除内容后状态:&#123;&#125;\", stateMachine.getState()); &#125; /** * 人工审核示例 * * @author lingyuwang * @date 2020-05-10 12:10 * @since 1.0.9 */ private void manualAuditDemo() throws Exception &#123; StateMachine&lt;States,Events&gt; stateMachine = contentAuditStateMachineBuilder.build(); // 参数 AuditContent auditContent = new AuditContent(); auditContent.setContentId(1L);// auditContent.setTextContent(\"肯定涉政啊\");// auditContent.setTextContent(\"肯定涉黄啊\"); auditContent.setTextContent(\"正常文本\"); // TODO 参数校验 // TODO 从数据库获取当前状态 auditContent.setStateCode(States.MACHINE_AUDIT_PASSED.getCode()); // 恢复 contentAuditPersister.restore(stateMachine, auditContent); Message&lt;Events&gt; message = MessageBuilder.withPayload(Events.MANUAL_AUDIT) .setHeader(\"auditContent\", auditContent).build(); stateMachine.sendEvent(message); // 异常处理 if (stateMachine.getExtendedState().getVariables().containsKey(\"hasError\")) &#123; throw (RuntimeException)stateMachine.getExtendedState().getVariables().get(\"error\"); &#125; log.info(\"人工审核后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.UP); log.info(\"上架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.DOWN); log.info(\"下架后状态:&#123;&#125;\", stateMachine.getState()); stateMachine.sendEvent(Events.DELETE_CONTENT); log.info(\"删除内容后状态:&#123;&#125;\", stateMachine.getState()); &#125; /** * 机审状态示例 * * @author lingyuwang * @date 2020-05-10 12:05 * @since 1.0.9 */ private void machineAuditDemo() throws Exception &#123; StateMachine&lt;States,Events&gt; stateMachine = contentAuditStateMachineBuilder.build(); // 参数 AuditContent auditContent = new AuditContent(); auditContent.setContentId(1L); auditContent.setStateCode(States.PENDING.getCode());// auditContent.setTextContent(\"肯定涉政啊\");// auditContent.setTextContent(\"肯定涉黄啊\"); auditContent.setTextContent(\"正常文本\"); // TODO 参数校验 // 恢复 contentAuditPersister.restore(stateMachine, auditContent); // 查看恢复后状态机的状态 log.info(\"恢复后状态:&#123;&#125;\", stateMachine.getState()); Message&lt;Events&gt; message = MessageBuilder.withPayload(Events.MACHINE_AUDIT) .setHeader(\"auditContent\", auditContent).build(); stateMachine.sendEvent(message); // 异常处理 if (stateMachine.getExtendedState().getVariables().containsKey(\"hasError\")) &#123; throw (RuntimeException)stateMachine.getExtendedState().getVariables().get(\"error\"); &#125; log.info(\"机审后状态:&#123;&#125;\", stateMachine.getState()); &#125;&#125; 控制台日志123456789101112131415161718192021222324Starting Application on DESKTOP-T6KAIR0 with PID 25372 (E:\\java\\idea_workspace\\spring-statemachine-starter-demo\\target\\classes started by dell in E:\\java\\idea_workspace\\spring-statemachine-starter-demo)No active profile set, falling back to default profiles: defaultStarted Application in 1.088 seconds (JVM running for 1.75)started ObjectState [getIds()=[MACHINE_AUDIT_PASSED], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=2083854344, toString()=AbstractState [id=MACHINE_AUDIT_PASSED, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]started org.springframework.statemachine.support.DefaultStateMachineExecutor@410ae9a3started MACHINE_AUDIT_REFUSED UP PENDING DESTROY MACHINE_AUDIT_PASSED MANUAL_AUDIT_REFUSED MANUAL_AUDIT_PASSED DOWN MACHINE_AUDIT MANUAL_AUDIT / MACHINE_AUDIT_PASSED / uuid=5aa474d0-6b9c-4aeb-8858-0c1d85208ba5 / id=content_audit人工审核参数:AuditContent(contentId=1, textContent=正常文本, machineAuditResult=null, manualAuditResult=null, stateCode=3)人工审核持久化状态:AuditContent(contentId=1, textContent=正常文本, machineAuditResult=null, manualAuditResult=true, stateCode=5)人工审核通过参数:AuditContent(contentId=1, textContent=正常文本, machineAuditResult=null, manualAuditResult=true, stateCode=5)人工审核通过持久化状态:AuditContent(contentId=1, textContent=正常文本, machineAuditResult=null, manualAuditResult=true, stateCode=6)State change to MANUAL_AUDIT_PASSED, this:com.wise.listener.LogListener@64337702人工审核后状态:ObjectState [getIds()=[MANUAL_AUDIT_PASSED], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=788892554, toString()=AbstractState [id=MANUAL_AUDIT_PASSED, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]State change to UP, this:com.wise.listener.LogListener@64337702上架后状态:ObjectState [getIds()=[UP], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=2064883371, toString()=AbstractState [id=UP, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]State change to DOWN, this:com.wise.listener.LogListener@64337702下架后状态:ObjectState [getIds()=[DOWN], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=82275756, toString()=AbstractState [id=DOWN, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]State change to UP, this:com.wise.listener.LogListener@64337702恢复上架后状态:ObjectState [getIds()=[UP], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=2064883371, toString()=AbstractState [id=UP, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]State change to DOWN, this:com.wise.listener.LogListener@64337702再次下架后状态:ObjectState [getIds()=[DOWN], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=82275756, toString()=AbstractState [id=DOWN, pseudoState=null, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]]State change to DESTROY, this:com.wise.listener.LogListener@64337702stopped org.springframework.statemachine.support.DefaultStateMachineExecutor@410ae9a3stopped MACHINE_AUDIT_REFUSED UP PENDING DESTROY MACHINE_AUDIT_PASSED MANUAL_AUDIT_REFUSED MANUAL_AUDIT_PASSED DOWN MACHINE_AUDIT MANUAL_AUDIT / / uuid=5aa474d0-6b9c-4aeb-8858-0c1d85208ba5 / id=content_audit删除内容后状态:ObjectState [getIds()=[DESTROY], getClass()=class org.springframework.statemachine.state.ObjectState, hashCode()=1629353699, toString()=AbstractState [id=DESTROY, pseudoState=org.springframework.statemachine.state.DefaultPseudoState@5f2f577, deferred=[], entryActions=[], exitActions=[], stateActions=[], regions=[], submachine=null]] 4.2.2 更多精彩尽在示例源码","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"AC自动机算法实现","slug":"AC自动机算法实现","date":"2020-05-01T13:12:55.000Z","updated":"2020-11-03T13:04:34.051Z","comments":false,"path":"2020/05/01/AC自动机算法实现/","link":"","permalink":"https://zhechu.github.io/2020/05/01/AC自动机算法实现/","excerpt":"","text":"核心思想：自动机按照文本字符顺序，接受字符，并发生状态转移。这些状态缓存了“按照字符转移成功（但不是模式串的结尾）”、“按照字符转移成功（是模式串的结尾）”、“按照字符转移失败”三种情况下的跳转与输出情况，因而降低了复杂度，提高效率 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/strmatch/ACAutomaton.java 1 应用场景 统计词频 敏感词过滤 2 自定义实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191/** * AC自动机算法实现 */public class ACAutomaton &#123; public static void main(String[] args) &#123; String[] patterns = &#123;\"at\", \"art\", \"oars\", \"soar\"&#125;; String text = \"soarsoarsat\"; System.out.println(match(text, patterns)); /* 匹配起始下标0; 长度4 匹配起始下标1; 长度4 匹配起始下标4; 长度4 匹配起始下标5; 长度4 匹配起始下标9; 长度2 true */ String[] patterns2 = &#123;\"Fxtec Pro1\", \"谷歌Pixel\"&#125;; String text2 = \"一家总部位于伦敦的公司Fxtex在MWC上就推出了一款名为Fxtec Pro1的手机，该机最大的亮点就是采用了侧滑式全键盘设计。DxOMark年度总榜发布 华为P20 Pro/谷歌Pixel 3争冠\"; System.out.println(match(text2, patterns2)); /* 匹配起始下标29; 长度10 匹配起始下标88; 长度7 true */ &#125; public static boolean match(String text, String[] patterns) &#123; ACAutomaton acAutomaton = new ACAutomaton(); // 构建 Trie 树 for (String pattern: patterns) &#123; acAutomaton.insert(pattern); &#125; // 构建失效指针 acAutomaton.buildFailurePointer(); // 返回匹配结果 return acAutomaton.match(text); &#125; /** 存储无意义字符 */ private ACNode root; public ACAutomaton() &#123; this.root = new ACNode(\"/\"); &#125; /** * 将输入内容与多模式串匹配 * @param text 输入内容 * @return */ private boolean match (String text) &#123; boolean result = false; ACNode root = this.root; ACNode p = root; int n = text.length(); for (int i = 0; i &lt; n; i++) &#123; String c = String.valueOf(text.charAt(i)); while (Objects.isNull(p.children.get(c)) &amp;&amp; p != root) &#123; p = p.fail; &#125; p = p.children.get(c); if (Objects.isNull(p)) &#123; p = root; &#125; ACNode tmp = p; while ( tmp != root) &#123; if (tmp.isEndingChar == true) &#123; int pos = i - tmp.length + 1; System.out.println(\"匹配起始下标\" + pos + \"; 长度\" + tmp.length); result = true; &#125; tmp = tmp.fail; &#125; &#125; return result; &#125; /** * 构建 Trie 树 * @param pattern */ private void insert (String pattern) &#123; ACNode node = this.root; int len = pattern.length(); for (int i = 0; i &lt; len; i++) &#123; String c = String.valueOf(pattern.charAt(i)); if (Objects.isNull(node.children.get(c))) &#123; node.children.put(c, new ACNode(c)); &#125; node = node.children.get(c); &#125; node.isEndingChar = true; node.length = pattern.length(); &#125; /** * 构建失效指针 */ private void buildFailurePointer() &#123; ACNode root = this.root; // 按层遍历 Trie 树的辅助队列 LinkedList&lt;ACNode&gt; queue = new LinkedList&lt;&gt;(); // 初始时先加入 root 节点到队列 queue.add(root); // 按层遍历 while (!queue.isEmpty()) &#123; ACNode p = queue.pop(); // 循环遍历子节点 for (ACNode pc : p.children.values()) &#123; if (Objects.isNull(pc)) &#123; continue; &#125; // 若父节点是 root，则失败指针指向 root if (p == root) &#123; pc.fail = root; &#125; else &#123; // 获取父节点的失败指针 ACNode q = p.fail; // root 节点的失败指针指向 null，找不到失败指针则会退出循环 while (Objects.nonNull(q)) &#123; ACNode qc = q.children.get(pc.data); // 父节点的失败指针指向的节点的子节点值等于当前节点的值 if (Objects.nonNull(qc)) &#123; pc.fail = qc; break; &#125; q = q.fail; &#125; if (Objects.isNull(q)) &#123; pc.fail = root; &#125; &#125; // 将子节点放入队列，等待下一轮计算 queue.add(pc); &#125; &#125; &#125; /** * 节点类 */ public class ACNode &#123; /** 节点存储的数据 */ private String data; /** 子节点列表 */ private Map&lt;String, ACNode&gt; children; /** 是否为结尾字符 */ private boolean isEndingChar; /** 当 isEndingChar=true 时，记录模式串长度 */ private int length; /** 失效指针 */ private ACNode fail; public ACNode(String data) &#123; this.data = data; this.children = new HashMap&lt;&gt;(); this.isEndingChar = false; this.length = 0; this.fail = null; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"BM算法实现","slug":"BM算法实现","date":"2020-05-01T04:58:24.000Z","updated":"2020-11-03T13:04:34.051Z","comments":false,"path":"2020/05/01/BM算法实现/","link":"","permalink":"https://zhechu.github.io/2020/05/01/BM算法实现/","excerpt":"","text":"核心思想：利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/strmatch/BoyerMoore.java 1 应用场景 字符串匹配 2 自定义实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * BM 算法实现字符串匹配 */public class BoyerMoore &#123; public static void main(String[] args) &#123; // 主串 String a = \"ababaeabac\"; // 模式串 String b = \"abac\"; // 获取模式串匹配主串的第一个索引 int result = bm(a.toCharArray(), b.toCharArray()); System.out.println(result); // 6 // 等价于 result = a.indexOf(b); System.out.println(result); // 6 &#125; /** * BM 算法 * @param a 主串 * @param b 模式串 * @return */ public static int bm(char[] a, char[] b) &#123; // 主串长度 int n = a.length; // 模式串长度 int m = b.length; // 构建坏字符哈希表 int[] bc = generateBC(b); // 计算 suffix 和 prefix int[] suffix = new int[m]; boolean[] prefix = new boolean[m]; generateGS(b, suffix, prefix); // 表示主串与模式串对齐的第一个字符的下标 int i = 0; while (i &lt;= n - m) &#123; int j; // 模式串从后往前匹配 for (j = m - 1; j &gt;= 0; --j) &#123; if (a[i + j] != b[j]) &#123; // 坏字符对应模式串中的下标是 j break; &#125; &#125; // 匹配成功，返回主串与模式串匹配的第一个字符的下标 if (j &lt; 0) &#123; return i; &#125; // 通过坏字符计算移动长度 int x = j - bc[a[i + j]]; // 通过好后缀计算移动长度 int y = 0; if (j &lt; m - 1) &#123; y = moveByGS(j, m, suffix, prefix); &#125; // 往后滑动的位数 i = i + Math.max(x, y); &#125; return -1; &#125; /** * 获取模式串中的字符对应下标的散列表（坏字符哈希表） * @param b 模式串 * @return */ private static int[] generateBC(char[] b) &#123; // ASCII 字符数 int size = 256; int[] bc = new int[size]; // 初始化bc for (int i = 0; i &lt; size; ++i) &#123; bc[i] = -1; &#125; int m = b.length; for (int i = 0; i &lt; m; ++i) &#123; // 记录字符在模式串的下标 // 若在模式串有相同的字符，则后面的会覆盖前面的字符下标 // b[i] 为对应字符串的 ASCII 值 bc[b[i]] = i; &#125; return bc; &#125; /** * 计算 suffix 和 prefix * @param b 模式串 * @param suffix * @param prefix */ private static void generateGS(char[] b, int[] suffix, boolean[] prefix) &#123; // 模式串长度 int m = b.length; // 初始化 for (int i = 0; i &lt; m; ++i) &#123; suffix[i] = -1; prefix[i] = false; &#125; for (int i = 0; i &lt; m - 1; ++i) &#123; int j = i; // 公共后缀子串长度 int k = 0; // 与 b[0, m-1] 求公共后缀子串 while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 - k]) &#123; suffix[++k] = --j + 1; &#125; // 公共后缀子串也是模式串的前缀子串 if (j == -1) &#123; prefix[k] = true; &#125; &#125; &#125; /** * 通过好后缀计算移动长度 * @param j 坏字符对应的模式串中的字符下标 * @param m 模式串长度 * @param suffix * @param prefix * @return */ private static int moveByGS(int j, int m, int[] suffix, boolean[] prefix) &#123; // 好后缀长度 int k = m - 1 - j; // 存在好后缀匹配子串 if (suffix[k] != -1) &#123; return j - suffix[k] + 1; &#125; // 在好后缀的后缀子串中查找最长的能跟模式串前缀子串匹配的后缀子串 for (int r = j + 2; r &lt;= m - 1; r++) &#123; if (prefix[m - r] == true) &#123; return r; &#125; &#125; return m; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"KMP算法实现","slug":"KMP算法实现","date":"2020-04-30T14:47:23.000Z","updated":"2020-11-03T13:04:34.161Z","comments":false,"path":"2020/04/30/KMP算法实现/","link":"","permalink":"https://zhechu.github.io/2020/04/30/KMP算法实现/","excerpt":"","text":"核心思想：当一趟匹配过程中出现字符不匹配时，不需要回溯主串的指针，而是利用已经得到的“部分匹配”，将模式串尽可能多地向右“滑动”一段距离，然后继续比较 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/strmatch/Kmp.java 为什么 Java 的String.contains() 方法没有使用类似 KMP 字符串匹配算法进行优化？ https://www.zhihu.com/question/27852656 1 应用场景 字符串匹配 2 自定义实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * KMP 算法实现字符串匹配 */public class Kmp &#123; public static void main(String[] args) &#123; // 主串 String a = \"ababaeabac\"; // 模式串 String b = \"abac\"; // 获取模式串匹配主串的第一个索引 int result = kmp(a.toCharArray(), b.toCharArray()); System.out.println(result); // 6 // 等价于 result = a.indexOf(b); System.out.println(result); // 6 &#125; /** * a, b分别是主串和模式串 * @param a * @param b * @return */ public static int kmp(char[] a, char[] b) &#123; // 主串长度 int n = a.length; // 模式串长度 int m = b.length; // 计算 next 数组（存储模式串中每个前缀的最长可匹配前缀子串的结尾字符下标） int[] next = getNexts(b, m); int j = 0; for (int i = 0; i &lt; n; ++i) &#123; // 一直找到 a[i] 和 b[j] while (j &gt; 0 &amp;&amp; a[i] != b[j]) &#123; j = next[j - 1] + 1; &#125; if (a[i] == b[j]) &#123; ++j; &#125; // 找到匹配模式串的了 if (j == m) &#123; return i - m + 1; &#125; &#125; return -1; &#125; /** * b表示模式串，m表示模式串的长度 * @param b * @param m * @return */ private static int[] getNexts(char[] b, int m) &#123; int[] next = new int[m]; // 一个字符是不存在前缀和后缀的 next[0] = -1; // k 表示 next 的值 int k = -1; // 计算 next 值 for (int i = 1; i &lt; m; ++i) &#123; // 此时的 k 表示上一个 next 的值 // 若上一个 next 的值存在，则再检查是否有复用的可能 while (k != -1 &amp;&amp; b[k + 1] != b[i]) &#123; // 取上一个 next 的值作为此次 next 的参考值 k = next[k]; &#125; // 指针新字符检查是否匹配 if (b[k + 1] == b[i]) &#123; ++k; &#125; // 最终得到 next 的值 next[i] = k; &#125; return next; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Trie字典树","slug":"Trie字典树","date":"2020-04-29T14:34:44.000Z","updated":"2020-11-03T13:04:34.220Z","comments":false,"path":"2020/04/29/Trie字典树/","link":"","permalink":"https://zhechu.github.io/2020/04/29/Trie字典树/","excerpt":"","text":"示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/strmatch/PatriciaTrieDemo.java 1 应用场景 统计词频 搜索框提示 根据前缀范围搜索 2 自定义实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Trie &#123; /** 存储无意义字符 */ private TrieNode root = new TrieNode('/'); /** * 插入一个字符串 * @param text */ public void insert(char[] text) &#123; TrieNode p = root; for (int i = 0; i &lt; text.length; ++i) &#123; int index = text[i] - 'a'; if (p.children[index] == null) &#123; TrieNode newNode = new TrieNode(text[i]); p.children[index] = newNode; &#125; p = p.children[index]; &#125; p.isEndingChar = true; &#125; /** * 查找一个字符串 * @param pattern * @return */ public boolean find(char[] pattern) &#123; TrieNode p = root; for (int i = 0; i &lt; pattern.length; ++i) &#123; int index = pattern[i] - 'a'; // 不存在pattern if (p.children[index] == null) &#123; return false; &#125; p = p.children[index]; &#125; // 不能完全匹配，只是前缀 if (p.isEndingChar == false) &#123; return false; &#125; // 找到pattern else &#123; return true; &#125; &#125; /** * Trie 树节点 */ public class TrieNode &#123; public char data; public TrieNode[] children = new TrieNode[26]; public boolean isEndingChar = false; public TrieNode(char data) &#123; this.data = data; &#125; &#125;&#125; 3 Apache commons PatriciaTrie 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import org.apache.commons.collections4.trie.PatriciaTrie;import java.util.*;import java.util.stream.Collectors;/** * Trie树的应用 * 1.统计词频（PatriciaTrie 继承 AbstractMap，拥有 Map 特性） * 2.搜索框提示（prefixMap 方法） * 3.根据前缀范围搜索（subMap 方法） */public class PatriciaTrieDemo &#123; public static void main(String[] args) &#123; PatriciaTrie&lt;Double&gt; patriciaTrie = new PatriciaTrie&lt;Double&gt;(); // key 为字符串，value 为存储的值（非常适合存储词频） patriciaTrie.put(\"ronak\", 100.0); patriciaTrie.put(\"ronald\", 90.0); patriciaTrie.put(\"rat\", 50.0); patriciaTrie.put(\"robert\", 200.0); patriciaTrie.put(\"bat\", 44.0); patriciaTrie.put(\"batman\", 440.0); // 是否包含某前缀的字符 System.out.println(patriciaTrie.containsKey(\"ronak\")); // true System.out.println(patriciaTrie.containsKey(\"onak\")); // false // 根据 key 获取存储的值（需精确匹配） System.out.println(patriciaTrie.get(\"robert\")); // 200.0 // 获取按字典排序最接近的字符 System.out.println(patriciaTrie.selectKey(\"ro\")); // robert // 获取匹配前缀的所有字符（按字典排序） System.out.println(patriciaTrie.prefixMap(\"r\")); // &#123;rat=50.0, robert=200.0, ronak=100.0, ronald=90.0&#125; // 获取匹配前缀的所有字符（按值顺序排序） Map&lt;String, Double&gt; roMap = patriciaTrie.prefixMap(\"ro\").entrySet().stream().sorted(Map.Entry.comparingByValue()) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (o1, o2) -&gt; o2, LinkedHashMap::new)); System.out.println(roMap); // &#123;ronald=90.0, ronak=100.0, robert=200.0&#125; // 获取匹配前缀的所有字符（按值倒序排序） Map&lt;String, Double&gt; roReverseOrderMap = patriciaTrie.prefixMap(\"ro\").entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue())) .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (o1, o2) -&gt; o2, LinkedHashMap::new)); System.out.println(roReverseOrderMap); // &#123;robert=200.0, ronak=100.0, ronald=90.0&#125; System.out.println(patriciaTrie.prefixMap(\"ron\")); // &#123;ronak=100.0, ronald=90.0&#125; // 获取按字典顺序排序的第一个字符 System.out.println(patriciaTrie.firstKey()); // bat // 获取按字典顺序排序的最后一个字符 System.out.println(patriciaTrie.lastKey()); // ronald // 获取比 ro（不包含） 前缀小的字符 System.out.println(patriciaTrie.headMap(\"ro\")); // &#123;bat=44.0, batman=440.0, rat=50.0&#125; // 获取在 ra（包含） 和 ro（不包含） 前缀之间的字符 System.out.println(patriciaTrie.subMap(\"ra\", \"ro\")); // &#123;rat=50.0&#125; // 获取比 ra（包含） 前缀大的字符 System.out.println(patriciaTrie.tailMap(\"ra\")); // &#123;rat=50.0, robert=200.0, ronak=100.0, ronald=90.0&#125; // 按字典顺序列出所有 key Set&lt;String&gt; keySet = patriciaTrie.keySet(); for (String key : keySet) &#123; System.out.println(\"key ---&gt; \" + key); &#125; /* key ---&gt; bat key ---&gt; batman key ---&gt; rat key ---&gt; robert key ---&gt; ronak key ---&gt; ronald */ // 按 key 的字典顺序列出其所有 value Collection&lt;Double&gt; values = patriciaTrie.values(); for (Double value : values) &#123; System.out.println(\"value ---&gt; \" + value); &#125; /* value ---&gt; 44.0 value ---&gt; 440.0 value ---&gt; 50.0 value ---&gt; 200.0 value ---&gt; 100.0 value ---&gt; 90.0 */ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot实现兼容多版本API","slug":"SpringBoot实现兼容多版本API","date":"2020-04-17T14:38:55.000Z","updated":"2020-11-03T13:04:34.206Z","comments":false,"path":"2020/04/17/SpringBoot实现兼容多版本API/","link":"","permalink":"https://zhechu.github.io/2020/04/17/SpringBoot实现兼容多版本API/","excerpt":"","text":"组件 版本 spring-boot-starter-parent 2.1.3.RELEASE 缘由：App 接口需实现多版本兼容 思路：使用 RequestCondition 和 RequestMappingHandlerMapping 实现 示例代码 https://github.com/zhechu/spring-boot-api-version-demo 1 控制器内兼容示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 控制器内兼容示例 * * @author lingyuwang * @date 2020-04-17 21:59 * @since 1.0.9 */@RestControllerpublic class CommonController &#123; @Value(\"$&#123;spring.profiles.active:dev&#125;\") private String env; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:00 * @since 1.0.9 * @deprecated * @see CommonController#envV107 */ @GetMapping(\"/env\") @Deprecated public String env() &#123; return env; &#125; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:00 * @since 1.0.9 * @deprecated * @see CommonController#envV108 */ @GetMapping(\"/env\") @ApiVersion(value = \"1.0.7\") @Deprecated public String envV107() &#123; return String.format(\"%s_%s\", env, \"1.0.7\"); &#125; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:02 * @since 1.0.9 * @deprecated * @see CommonController#envV109 */ @GetMapping(\"/env\") @ApiVersion(value = \"1.0.8\") @Deprecated public String envV108() &#123; return String.format(\"%s_%s\", env, \"1.0.8\"); &#125; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:04 * @since 1.0.9 */ @GetMapping(\"/env\") @ApiVersion(value = \"1.0.9\") public String envV109() &#123; return String.format(\"%s_%s\", env, \"1.0.9\"); &#125;&#125; 2 控制器间兼容示例2.1 默认版本控制器1234567891011121314151617181920212223242526272829/** * 默认版本控制器 * * @author lingyuwang * @date 2020-04-17 22:07 * @since 1.0.9 */@RestController@RequestMapping(\"/common\")@Deprecatedpublic class CommonControllerVdefault &#123; @Value(\"$&#123;spring.profiles.active:dev&#125;\") private String env; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:07 * @since 1.0.9 */ @GetMapping(\"/env\") public String env() &#123; return String.format(\"%s_%s\", env, \"default\"); &#125;&#125; 2.2 1.0.5 版本控制器123456789101112131415161718192021222324252627282930/** * 1.0.5 版本控制器 * * @author lingyuwang * @date 2020-04-17 22:08 * @since 1.0.9 */@RestController@RequestMapping(\"/common\")@ApiVersion(value = \"1.0.5\")@Deprecatedpublic class CommonControllerV105 &#123; @Value(\"$&#123;spring.profiles.active:dev&#125;\") private String env; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:08 * @since 1.0.9 */ @GetMapping(\"/env\") public String env() &#123; return String.format(\"%s_%s\", env, \"1.0.5\"); &#125;&#125; 2.3 1.0.6 版本控制器（最新版）1234567891011121314151617181920212223242526272829/** * 1.0.6 版本控制器（最新版） * * @author lingyuwang * @date 2020-04-17 22:10 * @since 1.0.9 */@RestController@RequestMapping(\"/common\")@ApiVersion(value = \"1.0.6\")public class CommonControllerV106 &#123; @Value(\"$&#123;spring.profiles.active:dev&#125;\") private String env; /** * 获取服务环境 * * @return java.lang.String * @author lingyuwang * @date 2020-04-17 22:09 * @since 1.0.9 */ @GetMapping(\"/env\") public String env() &#123; return String.format(\"%s_%s\", env, \"1.0.6\"); &#125;&#125; 3 版本兼容一览表 访问 URL 版本号参数 返回内容 匹配版本 备注 /common/env 不传 dev_default 默认版本 没有匹配的版本，走没有配置版本号的接口 /common/env 0.0.1 dev_default 默认版本 没有等于或小于其的版本，走没有配置版本号的接口 /common/env 1.0.5 dev_1.0.5 1.0.5 精确匹配 /common/env 1.0.9 dev_1.0.6 1.0.6 匹配到最新的版本 /common/env 2.0.1 dev_1.0.6 1.0.6 匹配到最新的版本 TIPS：/env 同理 4 请求示例","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot使用GET请求实现多条件查询","slug":"SpringBoot使用GET请求实现多条件查询","date":"2020-04-16T14:54:39.000Z","updated":"2020-11-03T13:04:34.206Z","comments":false,"path":"2020/04/16/SpringBoot使用GET请求实现多条件查询/","link":"","permalink":"https://zhechu.github.io/2020/04/16/SpringBoot使用GET请求实现多条件查询/","excerpt":"","text":"组件 版本 spring-cloud-dependencies Greenwich.SR1 spring-boot-starter-parent 2.1.3.RELEASE 缘由：支持分页并支持多条件查询的接口，入参可能会多于3个，一般都用 POST 请求加 @RequestBody 注解实现。但对于接口调用端（App 或 Web）来说，并不友好，查询的接口应该统一用 GET 请求 思路：使用 @ModelAttribute 和 @SpringQueryMap 注解实现 1 使用示例服务端包含两层，上层为聚合层，下层为模块层 1.1 相关 POJO分页入参 POJO12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class PageBase &#123; public final static Integer DEFAULT_PAGE_INDEX = 1; public final static Integer DEFAULT_PAGE_SIZE = 10; /** 页码，默认是 1（pageIndex=-1&amp;pageSize=-1则不分页） */ private Integer pageIndex = DEFAULT_PAGE_INDEX; /** 每页条数，默认是 10（pageIndex=-1&amp;pageSize=-1则不分页） */ private Integer pageSize = DEFAULT_PAGE_SIZE; public void setPageIndex(Integer pageIndex) &#123; if (null == pageIndex) this.pageIndex = DEFAULT_PAGE_INDEX; else this.pageIndex = pageIndex; &#125; public void setPageSize(Integer pageSize) &#123; if (null == pageSize) this.pageSize = DEFAULT_PAGE_SIZE; else this.pageSize = pageSize; &#125; /** * 设置不分页 * * @author lingyuwang * @date 2020-01-11 10:48 * @since 1.0.4 */ public void setNoPage() &#123; this.pageIndex = -1; this.pageSize = -1; &#125; /** * 是否分页 * * @return boolean * @author lingyuwang * @date 2020-01-11 12:31 * @since 1.0.4 */ public boolean isNoPage() &#123; return this.pageIndex != null &amp;&amp; this.pageIndex == -1 &amp;&amp; this.pageSize != null &amp;&amp; this.pageSize == -1; &#125; public Integer getPageIndex() &#123; return pageIndex; &#125; public Integer getPageSize() &#123; return pageSize; &#125;&#125; TIPS：当分页入参 pageIndex=-1 和 pageSize=-1 时，则不按分页查询 测试多条件查询入参 POJO12345678910111213141516171819202122232425262728@Datapublic class TestQO extends PageBase &#123; /** * 用户名 */ private String userName; /** * 推荐状态 (0:不推荐，1:推荐) */ private Integer recommendStatus; /** * 上下架状态(0:下架 1:上架） */ private Integer upDownStatus; /** * 开始时间 */ private Date startTime; /** * 结束时间 */ private Date endTime;&#125; 测试多条件查询入参校验 POJO12345678910111213141516171819202122232425262728293031323334353637@Data@ScriptAssert( lang = \"javascript\", script = \"_this.startTime == null || _this.endTime == null || _this.startTime.getTime() &lt;= _this.endTime.getTime()\", message = \"开始时间不能大于结束时间\")public class TestDVO extends PageBase &#123; /** * 用户名 */ private String userName; /** * 推荐状态 (0:不推荐，1:推荐) */ @EnumValid(clazz = YesNoEnum.class, method = \"getKey\", message = \"若传参,参数值只能为0或1\") private Integer recommendStatus; /** * 上下架状态(0:下架 1:上架） */ @EnumValid(clazz = YesNoEnum.class, method = \"getKey\", message = \"若传参,参数值只能为0或1\") private Integer upDownStatus; /** * 开始时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date startTime; /** * 结束时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date endTime;&#125; TIPS：此 POJO 只位于聚合层。加上 @DateTimeFormat 是便于接收调用端传过来的日期参数，其原本格式为字符串 1.2 聚合层1.2.1 控制器123456789101112131415@RestController@RequestMapping(\"/test\")public class TestController &#123; @Autowired private TestService testService; @GetMapping(\"/list\") public Response&lt;List&lt;TestVO&gt;&gt; list(@Validated @ModelAttribute TestDVO testDVO) &#123; TestQO testQO = new TestQO(); BeanUtils.copyProperties(testDVO, testQO); return testService.list(testQO); &#125;&#125; TIPS：调用者可以通过 /test/list?pageIndex=1&amp;pageSize=10&amp;userName=zhangsan&amp;recommendStatus=1&amp;upDownStatus=1&amp;startTime=2020-04-15 23:25:12&amp;endTime=2020-04-16 21:22:01 格式发起请求 1.2.2 Feign 声明1234567@FeignClient(value = \"test-service\", fallbackFactory = TestServiceFallback.class, configuration = FeignConfiguration.class)public interface TestService &#123; @GetMapping(\"/test/list\") Response&lt;List&lt;TestVO&gt;&gt; list(@SpringQueryMap TestQO testQO);&#125; TIPS：@SpringQueryMap 会将 POJO 转为 Query 参数 1.3 模块层1.3.1 控制器1234567891011121314@RestController@RequestMapping(\"/test\")public class TestController &#123; @Autowired private TestService testService; @GetMapping(\"/list\") public Response&lt;List&lt;TestVO&gt;&gt; list(@ModelAttribute TestQO testQO) &#123; List&lt;TestVO&gt; list = testService.list(testQO); return Response.success(list); &#125;&#125; 2 @SpringQueryMap 注解 BUG 补丁@SpringQueryMap 注解的 POJO 不支持父类的属性，替换 FieldQueryMapEncoder 类即可。 原类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * Copyright 2012-2018 The Feign Authors * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except * in compliance with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software distributed under the License * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied. See the License for the specific language governing permissions and limitations under * the License. */package feign.querymap;import feign.QueryMapEncoder;import feign.codec.EncodeException;import java.lang.reflect.Field;import java.util.*;/** * the query map will be generated using member variable names as query parameter names. * * eg: \"/uri?name=&#123;name&#125;&amp;number=&#123;number&#125;\" * * order of included query parameters not guaranteed, and as usual, if any value is null, it will be * left out */public class FieldQueryMapEncoder implements QueryMapEncoder &#123; private final Map&lt;Class&lt;?&gt;, ObjectParamMetadata&gt; classToMetadata = new HashMap&lt;Class&lt;?&gt;, ObjectParamMetadata&gt;(); @Override public Map&lt;String, Object&gt; encode(Object object) throws EncodeException &#123; try &#123; ObjectParamMetadata metadata = getMetadata(object.getClass()); Map&lt;String, Object&gt; fieldNameToValue = new HashMap&lt;String, Object&gt;(); for (Field field : metadata.objectFields) &#123; Object value = field.get(object); if (value != null &amp;&amp; value != object) &#123; fieldNameToValue.put(field.getName(), value); &#125; &#125; return fieldNameToValue; &#125; catch (IllegalAccessException e) &#123; throw new EncodeException(\"Failure encoding object into query map\", e); &#125; &#125; private ObjectParamMetadata getMetadata(Class&lt;?&gt; objectType) &#123; ObjectParamMetadata metadata = classToMetadata.get(objectType); if (metadata == null) &#123; metadata = ObjectParamMetadata.parseObjectType(objectType); classToMetadata.put(objectType, metadata); &#125; return metadata; &#125; private static class ObjectParamMetadata &#123; private final List&lt;Field&gt; objectFields; private ObjectParamMetadata(List&lt;Field&gt; objectFields) &#123; this.objectFields = Collections.unmodifiableList(objectFields); &#125; private static ObjectParamMetadata parseObjectType(Class&lt;?&gt; type) &#123; List&lt;Field&gt; fields = new ArrayList&lt;Field&gt;(); for (Field field : type.getDeclaredFields()) &#123; if (!field.isAccessible()) &#123; field.setAccessible(true); &#125; fields.add(field); &#125; return new ObjectParamMetadata(fields); &#125; &#125;&#125; 替换类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * Copyright 2012-2018 The Feign Authors * * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except * in compliance with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software distributed under the License * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express * or implied. See the License for the specific language governing permissions and limitations under * the License. */package feign.querymap;import feign.QueryMapEncoder;import feign.codec.EncodeException;import java.lang.reflect.Field;import java.util.*;/** * 解决 @SpringQueryMap 注解的 POJO 不支持父类属性的 BUG * * the query map will be generated using member variable names as query parameter names. * * eg: \"/uri?name=&#123;name&#125;&amp;number=&#123;number&#125;\" * * order of included query parameters not guaranteed, and as usual, if any value is null, it will be * left out * * @author lingyuwang * @date 2020-04-16 15:01 * @since 1.0.9 */public class FieldQueryMapEncoder implements QueryMapEncoder &#123; private final Map&lt;Class&lt;?&gt;, ObjectParamMetadata&gt; classToMetadata = new HashMap&lt;Class&lt;?&gt;, ObjectParamMetadata&gt;(); @Override public Map&lt;String, Object&gt; encode(Object object) throws EncodeException &#123; try &#123; ObjectParamMetadata metadata = getMetadata(object.getClass()); Map&lt;String, Object&gt; fieldNameToValue = new HashMap&lt;String, Object&gt;(); for (Field field : metadata.objectFields) &#123; Object value = field.get(object); if (value != null &amp;&amp; value != object) &#123; fieldNameToValue.put(field.getName(), value); &#125; &#125; return fieldNameToValue; &#125; catch (IllegalAccessException e) &#123; throw new EncodeException(\"Failure encoding object into query map\", e); &#125; &#125; private ObjectParamMetadata getMetadata(Class&lt;?&gt; objectType) &#123; ObjectParamMetadata metadata = classToMetadata.get(objectType); if (metadata == null) &#123; metadata = ObjectParamMetadata.parseObjectType(objectType); classToMetadata.put(objectType, metadata); &#125; return metadata; &#125; private static class ObjectParamMetadata &#123; private final List&lt;Field&gt; objectFields; private ObjectParamMetadata(List&lt;Field&gt; objectFields) &#123; this.objectFields = Collections.unmodifiableList(objectFields); &#125; private static ObjectParamMetadata parseObjectType(Class&lt;?&gt; type) &#123; List&lt;Field&gt; fields = new ArrayList&lt;Field&gt;(); for (Field field : type.getDeclaredFields()) &#123; if (!field.isAccessible()) &#123; field.setAccessible(true); &#125; fields.add(field); &#125; // 获取父类字段 getFieldFromSupperclass(type, fields); return new ObjectParamMetadata(fields); &#125; private static void getFieldFromSupperclass(Class&lt;?&gt; type, List&lt;Field&gt; fields) &#123; if (type == null) &#123; return; &#125; Class superType = type.getSuperclass(); if (superType == null) &#123; return; &#125; for (Field field : type.getDeclaredFields()) &#123; if (!field.isAccessible()) &#123; field.setAccessible(true); &#125; fields.add(field); &#125; // 递归获取父类字段 getFieldFromSupperclass(superType, fields); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot集成Canal要点","slug":"SpringBoot集成Canal要点","date":"2020-04-15T15:37:03.000Z","updated":"2020-11-03T13:04:34.207Z","comments":false,"path":"2020/04/15/SpringBoot集成Canal要点/","link":"","permalink":"https://zhechu.github.io/2020/04/15/SpringBoot集成Canal要点/","excerpt":"","text":"组件 版本 canal 1.1.5-alpha-1 官方文档 https://github.com/alibaba/canal/wiki Spring boot canal 客户端 https://github.com/NormanGyllenhaal/canal-client Canal 其中的一种用途 TIPS：此实践中，MySQL 同步到 Redis 的一般为单表数据，达到读写分离的效果。 1 源数据库配置开启 binglog，并选择 ROW 模式12345$ vi /etc/my.cnf[mysqld]log-bin=mysql-bin # 开启 binlogbinlog-format=ROW # 选择 ROW 模式server_id=1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复 指定需要监听的数据库12$ vi /etc/my.cnfbinlog-do-db=test_canal # 需要同步的数据库名称 授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant1234CREATE USER canal IDENTIFIED BY &apos;canal&apos;;GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;canal&apos;@&apos;%&apos;;GRANT ALL PRIVILEGES ON canal_manager.* TO &apos;canal&apos;@&apos;%&apos; ;FLUSH PRIVILEGES; TIPS：canal_manager 是 canal admin 管理控制台的数据库 2 配置优化canal.properties 配置优化12canal.instance.filter.query.dcl = true # 忽略dcl语句（grant、revoke等）canal.instance.filter.query.ddl = true # 忽略ddl语句（create、drop、alter等） instance.properties 配置优化1canal.instance.filter.regex = ApolloConfigDB\\\\..* # 只监听 ApolloConfigDB schema（ApolloConfigDB\\\\.App.* 只监听 ApolloConfigDB 下的 App 表） 3 配置示例3.1 单机配置3.1.1 Server 配置管理控制台 Server 配置 canal.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105########################################################## common argument ############################################################### tcp bind ipcanal.ip =# register ip to zookeepercanal.register.ip =canal.port = 11111canal.metrics.pull.port = 11112# canal instance user/passwdcanal.user = canalcanal.passwd = E3619321C1A937C46A0D8BD1DAC39F93B27D4458canal.zkServers =# flush data to zkcanal.zookeeper.flush.period = 1000canal.withoutNetty = false# tcp, kafka, RocketMQcanal.serverMode = tcp# flush meta cursor/parse position to filecanal.file.data.dir = $&#123;canal.conf.dir&#125;canal.file.flush.period = 1000## memory store RingBuffer size, should be Math.pow(2,n)canal.instance.memory.buffer.size = 16384## memory store RingBuffer used memory unit size , default 1kbcanal.instance.memory.buffer.memunit = 1024## meory store gets mode used MEMSIZE or ITEMSIZEcanal.instance.memory.batch.mode = MEMSIZEcanal.instance.memory.rawEntry = true## detecing configcanal.instance.detecting.enable = false#canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()canal.instance.detecting.sql = select 1canal.instance.detecting.interval.time = 3canal.instance.detecting.retry.threshold = 3canal.instance.detecting.heartbeatHaEnable = false# support maximum transaction size, more than the size of the transaction will be cut into multiple transactions deliverycanal.instance.transaction.size = 1024# mysql fallback connected to new master should fallback timescanal.instance.fallbackIntervalInSeconds = 60# network configcanal.instance.network.receiveBufferSize = 16384canal.instance.network.sendBufferSize = 16384canal.instance.network.soTimeout = 30# binlog filter configcanal.instance.filter.druid.ddl = truecanal.instance.filter.query.dcl = falsecanal.instance.filter.query.dml = falsecanal.instance.filter.query.ddl = falsecanal.instance.filter.table.error = falsecanal.instance.filter.rows = falsecanal.instance.filter.transaction.entry = false# binlog format/image checkcanal.instance.binlog.format = ROW,STATEMENT,MIXEDcanal.instance.binlog.image = FULL,MINIMAL,NOBLOB# binlog ddl isolationcanal.instance.get.ddl.isolation = false# parallel parser configcanal.instance.parser.parallel = true## concurrent thread number, default 60% available processors, suggest not to exceed Runtime.getRuntime().availableProcessors()#canal.instance.parser.parallelThreadSize = 16## disruptor ringbuffer size, must be power of 2canal.instance.parser.parallelBufferSize = 256# table meta tsdb infocanal.instance.tsdb.enable = truecanal.instance.tsdb.dir = $&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;canal.instance.tsdb.url = jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;canal.instance.tsdb.dbUsername = canalcanal.instance.tsdb.dbPassword = canal# dump snapshot interval, default 24 hourcanal.instance.tsdb.snapshot.interval = 24# purge snapshot expire , default 360 hour(15 days)canal.instance.tsdb.snapshot.expire = 360# aliyun ak/sk , support rds/mqcanal.aliyun.accessKey =canal.aliyun.secretKey =########################################################## destinations ##############################################################canal.destinations =# conf root dircanal.conf.dir = ../conf# auto scan instance dir add/remove and start/stop instancecanal.auto.scan = truecanal.auto.scan.interval = 5canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml#canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xmlcanal.instance.global.mode = managercanal.instance.global.lazy = falsecanal.instance.global.manager.address = $&#123;canal.admin.manager&#125;#canal.instance.global.spring.xml = classpath:spring/memory-instance.xmlcanal.instance.global.spring.xml = classpath:spring/file-instance.xml#canal.instance.global.spring.xml = classpath:spring/default-instance.xml 3.1.2 Instance 配置管理控制台 Instance 配置 instance.propertios1234567891011121314151617181920212223242526272829303132333435363738394041424344454647################################################### mysql serverId , v1.0.26+ will autoGen# canal.instance.mysql.slaveId=0# enable gtid use true/falsecanal.instance.gtidon=false# position infocanal.instance.master.address=192.168.163.31:3306canal.instance.master.journal.name=canal.instance.master.position=canal.instance.master.timestamp=canal.instance.master.gtid=# rds oss binlogcanal.instance.rds.accesskey=canal.instance.rds.secretkey=canal.instance.rds.instanceId=# table meta tsdb infocanal.instance.tsdb.enable=true#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb#canal.instance.tsdb.dbUsername=canal#canal.instance.tsdb.dbPassword=canal#canal.instance.standby.address =#canal.instance.standby.journal.name =#canal.instance.standby.position =#canal.instance.standby.timestamp =#canal.instance.standby.gtid=# username/passwordcanal.instance.dbUsername=canalcanal.instance.dbPassword=canalcanal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==# table regexcanal.instance.filter.regex=.*\\\\..*# table black regexcanal.instance.filter.black.regex=# table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch# table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch 3.1.3 Canal admin 配置application.yml123456789101112131415161718192021server: port: 8089spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8spring.datasource: address: 192.168.163.31:3306 database: canal_manager username: canal password: canal driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://$&#123;spring.datasource.address&#125;/$&#123;spring.datasource.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false hikari: maximum-pool-size: 30 minimum-idle: 1canal: adminUser: admin adminPasswd: 123456 3.1.4 Canal deployer 配置canal.properties1234567891011# register ipcanal.register.ip = 192.168.163.31# canal admin configcanal.admin.manager = 192.168.163.31:8089canal.admin.port = 11110canal.admin.user = admincanal.admin.passwd = 6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9# admin auto registercanal.admin.register.auto = truecanal.admin.register.cluster = 3.2 单机 RabbitMQ 配置3.2.1 Server 配置管理控制台 Server 配置 canal.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133########################################################## common argument ############################################################### tcp bind ipcanal.ip =# register ip to zookeepercanal.register.ip =canal.port = 11111canal.metrics.pull.port = 11112# canal instance user/passwdcanal.user = canalcanal.passwd = E3619321C1A937C46A0D8BD1DAC39F93B27D4458canal.zkServers =# flush data to zkcanal.zookeeper.flush.period = 1000canal.withoutNetty = false# tcp, kafka, RocketMQcanal.serverMode = tcp# flush meta cursor/parse position to filecanal.file.data.dir = $&#123;canal.conf.dir&#125;canal.file.flush.period = 1000## memory store RingBuffer size, should be Math.pow(2,n)canal.instance.memory.buffer.size = 16384## memory store RingBuffer used memory unit size , default 1kbcanal.instance.memory.buffer.memunit = 1024## meory store gets mode used MEMSIZE or ITEMSIZEcanal.instance.memory.batch.mode = MEMSIZEcanal.instance.memory.rawEntry = true## detecing configcanal.instance.detecting.enable = false#canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()canal.instance.detecting.sql = select 1canal.instance.detecting.interval.time = 3canal.instance.detecting.retry.threshold = 3canal.instance.detecting.heartbeatHaEnable = false# support maximum transaction size, more than the size of the transaction will be cut into multiple transactions deliverycanal.instance.transaction.size = 1024# mysql fallback connected to new master should fallback timescanal.instance.fallbackIntervalInSeconds = 60# network configcanal.instance.network.receiveBufferSize = 16384canal.instance.network.sendBufferSize = 16384canal.instance.network.soTimeout = 30# binlog filter configcanal.instance.filter.druid.ddl = truecanal.instance.filter.query.dcl = truecanal.instance.filter.query.dml = falsecanal.instance.filter.query.ddl = truecanal.instance.filter.table.error = falsecanal.instance.filter.rows = falsecanal.instance.filter.transaction.entry = false# binlog format/image checkcanal.instance.binlog.format = ROW,STATEMENT,MIXEDcanal.instance.binlog.image = FULL,MINIMAL,NOBLOB# binlog ddl isolationcanal.instance.get.ddl.isolation = false# parallel parser configcanal.instance.parser.parallel = true## concurrent thread number, default 60% available processors, suggest not to exceed Runtime.getRuntime().availableProcessors()#canal.instance.parser.parallelThreadSize = 16## disruptor ringbuffer size, must be power of 2canal.instance.parser.parallelBufferSize = 256# table meta tsdb infocanal.instance.tsdb.enable = truecanal.instance.tsdb.dir = $&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;canal.instance.tsdb.url = jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;canal.instance.tsdb.dbUsername = canalcanal.instance.tsdb.dbPassword = canal# dump snapshot interval, default 24 hourcanal.instance.tsdb.snapshot.interval = 24# purge snapshot expire , default 360 hour(15 days)canal.instance.tsdb.snapshot.expire = 360# aliyun ak/sk , support rds/mqcanal.aliyun.accessKey =canal.aliyun.secretKey =########################################################## destinations ##############################################################canal.destinations =# conf root dircanal.conf.dir = ../conf# auto scan instance dir add/remove and start/stop instancecanal.auto.scan = truecanal.auto.scan.interval = 5canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml#canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xmlcanal.instance.global.mode = managercanal.instance.global.lazy = falsecanal.instance.global.manager.address = $&#123;canal.admin.manager&#125;#canal.instance.global.spring.xml = classpath:spring/memory-instance.xmlcanal.instance.global.spring.xml = classpath:spring/file-instance.xml#canal.instance.global.spring.xml = classpath:spring/default-instance.xml########################################################### MQ ###############################################################canal.serverMode = rabbitmqcanal.mq.servers = 192.168.163.31canal.mq.retries = 0canal.mq.batchSize = 16384canal.mq.maxRequestSize = 1048576canal.mq.lingerMs = 100canal.mq.bufferMemory = 33554432canal.mq.canalBatchSize = 50canal.mq.canalGetTimeout = 100canal.mq.parallelThreadSize = 8canal.mq.flatMessage = truecanal.mq.compressionType = nonecanal.mq.acks = all#canal.mq.properties. =canal.mq.producerGroup = Canal-Producer# Set this value to &quot;cloud&quot;, if you want open message trace feature in aliyun.canal.mq.accessChannel = local# aliyun mq namespacecanal.mq.namespace =canal.mq.vhost = /devcanal.mq.exchange = mysql-binlog-exchangecanal.mq.username = admincanal.mq.password = admincanal.mq.instanceId = 3.2.2 Instance 配置管理控制台 Instance 配置 instance.propertios123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657################################################### mysql serverId , v1.0.26+ will autoGen# canal.instance.mysql.slaveId=0# enable gtid use true/falsecanal.instance.gtidon=false# position infocanal.instance.master.address=192.168.163.31:3306canal.instance.master.journal.name=canal.instance.master.position=canal.instance.master.timestamp=canal.instance.master.gtid=# rds oss binlogcanal.instance.rds.accesskey=canal.instance.rds.secretkey=canal.instance.rds.instanceId=# table meta tsdb infocanal.instance.tsdb.enable=true#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb#canal.instance.tsdb.dbUsername=canal#canal.instance.tsdb.dbPassword=canal#canal.instance.standby.address =#canal.instance.standby.journal.name =#canal.instance.standby.position =#canal.instance.standby.timestamp =#canal.instance.standby.gtid=# username/passwordcanal.instance.dbUsername=canalcanal.instance.dbPassword=canalcanal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==# table regexcanal.instance.filter.regex=test_canal\\\\.user# table black regexcanal.instance.filter.black.regex=# table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch# table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch# mq configcanal.mq.topic=mysql-binlog# dynamic topic route by schema or table regex#canal.mq.dynamicTopic=mytest1.user,mytest2\\\\..*,.*\\\\..*canal.mq.partition=0# hash partition config#canal.mq.partitionsNum=3#canal.mq.partitionHash=test.table:id^name,.*\\\\..*################################################# 3.2.3 Canal admin 配置同 3.1.3 章节 3.2.4 Canal deployer 配置同 3.1.4 章节 3.3 Zookeeper &amp; RDS &amp; 阿里云 AMQP 配置3.3.1 集群配置管理控制台集群配置 canal.properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131########################################################## common argument ############################################################### tcp bind ipcanal.ip =# register ip to zookeepercanal.register.ip =canal.port = 11111canal.metrics.pull.port = 11112# canal instance user/passwdcanal.user = xxxcanal.passwd = xxxcanal.zkServers = xxx.aliyuncs.com:2181# flush data to zkcanal.zookeeper.flush.period = 1000canal.withoutNetty = false# tcp, kafka, RocketMQcanal.serverMode = tcp# flush meta cursor/parse position to filecanal.file.data.dir = $&#123;canal.conf.dir&#125;canal.file.flush.period = 1000## memory store RingBuffer size, should be Math.pow(2,n)canal.instance.memory.buffer.size = 16384## memory store RingBuffer used memory unit size , default 1kbcanal.instance.memory.buffer.memunit = 1024## meory store gets mode used MEMSIZE or ITEMSIZEcanal.instance.memory.batch.mode = MEMSIZEcanal.instance.memory.rawEntry = true## detecing configcanal.instance.detecting.enable = false#canal.instance.detecting.sql = insert into retl.xdual values(1,now()) on duplicate key update x=now()canal.instance.detecting.sql = select 1canal.instance.detecting.interval.time = 3canal.instance.detecting.retry.threshold = 3canal.instance.detecting.heartbeatHaEnable = false# support maximum transaction size, more than the size of the transaction will be cut into multiple transactions deliverycanal.instance.transaction.size = 1024# mysql fallback connected to new master should fallback timescanal.instance.fallbackIntervalInSeconds = 60# network configcanal.instance.network.receiveBufferSize = 16384canal.instance.network.sendBufferSize = 16384canal.instance.network.soTimeout = 30# binlog filter configcanal.instance.filter.druid.ddl = truecanal.instance.filter.query.dcl = truecanal.instance.filter.query.dml = falsecanal.instance.filter.query.ddl = truecanal.instance.filter.table.error = falsecanal.instance.filter.rows = falsecanal.instance.filter.transaction.entry = false# binlog format/image checkcanal.instance.binlog.format = ROW,STATEMENT,MIXEDcanal.instance.binlog.image = FULL,MINIMAL,NOBLOB# binlog ddl isolationcanal.instance.get.ddl.isolation = false# parallel parser configcanal.instance.parser.parallel = true## concurrent thread number, default 60% available processors, suggest not to exceed Runtime.getRuntime().availableProcessors()#canal.instance.parser.parallelThreadSize = 16## disruptor ringbuffer size, must be power of 2canal.instance.parser.parallelBufferSize = 256# table meta tsdb infocanal.instance.tsdb.enable = truecanal.instance.tsdb.dir = $&#123;canal.file.data.dir:../conf&#125;/$&#123;canal.instance.destination:&#125;canal.instance.tsdb.url = jdbc:h2:$&#123;canal.instance.tsdb.dir&#125;/h2;CACHE_SIZE=1000;MODE=MYSQL;canal.instance.tsdb.dbUsername = canalcanal.instance.tsdb.dbPassword = canal# dump snapshot interval, default 24 hourcanal.instance.tsdb.snapshot.interval = 24# purge snapshot expire , default 360 hour(15 days)canal.instance.tsdb.snapshot.expire = 360# aliyun ak/sk , support rds/mqcanal.aliyun.accessKey = xxxcanal.aliyun.secretKey = xxx########################################################## destinations ##############################################################canal.destinations =# conf root dircanal.conf.dir = ../conf# auto scan instance dir add/remove and start/stop instancecanal.auto.scan = truecanal.auto.scan.interval = 5canal.instance.tsdb.spring.xml = classpath:spring/tsdb/h2-tsdb.xml#canal.instance.tsdb.spring.xml = classpath:spring/tsdb/mysql-tsdb.xmlcanal.instance.global.mode = managercanal.instance.global.lazy = falsecanal.instance.global.manager.address = $&#123;canal.admin.manager&#125;#canal.instance.global.spring.xml = classpath:spring/memory-instance.xml#canal.instance.global.spring.xml = classpath:spring/file-instance.xmlcanal.instance.global.spring.xml = classpath:spring/default-instance.xml########################################################### MQ ###############################################################canal.serverMode = rabbitmqcanal.mq.servers = xxx.aliyuncs.comcanal.mq.retries = 0canal.mq.batchSize = 16384canal.mq.maxRequestSize = 1048576canal.mq.lingerMs = 100canal.mq.bufferMemory = 33554432canal.mq.canalBatchSize = 50canal.mq.canalGetTimeout = 100canal.mq.parallelThreadSize = 8canal.mq.flatMessage = truecanal.mq.compressionType = nonecanal.mq.acks = all#canal.mq.properties. =canal.mq.producerGroup = Canal-Producer# Set this value to &quot;cloud&quot;, if you want open message trace feature in aliyun.canal.mq.accessChannel = cloud# aliyun mq namespacecanal.mq.namespace = xxxcanal.mq.vhost = procanal.mq.exchange = mysql-binlog-exchangecanal.mq.instanceId = xxx 3.3.2 Instance 配置管理控制台 Instance 配置 instance.propertios123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657################################################### mysql serverId , v1.0.26+ will autoGen# canal.instance.mysql.slaveId=0# enable gtid use true/falsecanal.instance.gtidon=false# position infocanal.instance.master.address=xxx.mysql.rds.aliyuncs.com:3306canal.instance.master.journal.name=canal.instance.master.position=canal.instance.master.timestamp=canal.instance.master.gtid=# rds oss binlogcanal.instance.rds.accesskey=canal.instance.rds.secretkey=canal.instance.rds.instanceId=# table meta tsdb infocanal.instance.tsdb.enable=true#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb#canal.instance.tsdb.dbUsername=canal#canal.instance.tsdb.dbPassword=canal#canal.instance.standby.address =#canal.instance.standby.journal.name =#canal.instance.standby.position =#canal.instance.standby.timestamp =#canal.instance.standby.gtid=# username/passwordcanal.instance.dbUsername=xxxcanal.instance.dbPassword=xxxcanal.instance.connectionCharset = UTF-8# enable druid Decrypt database passwordcanal.instance.enableDruid=false#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==# table regexcanal.instance.filter.regex=test_canal\\\\.user# table black regexcanal.instance.filter.black.regex=# table field filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch# table field black filter(format: schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch# mq configcanal.mq.topic=mysql-binlog# dynamic topic route by schema or table regex#canal.mq.dynamicTopic=mytest1.user,mytest2\\\\..*,.*\\\\..*canal.mq.partition=0# hash partition config#canal.mq.partitionsNum=3#canal.mq.partitionHash=test.table:id^name,.*\\\\..*################################################# 3.3.3 Canal admin 配置同 3.1.3 章节 3.3.4 Canal deployer 配置同 3.1.4 章节 4 注意点Canal 订阅的数据库的数据结构变更时，需删除 /canal/canal.deployer/conf/mysql-to-rabbitmq 下的文件并重启，以重新同步结构数据，否则会一直订阅失败。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot集成Sentinel要点","slug":"SpringBoot集成Sentinel要点","date":"2020-04-15T14:33:59.000Z","updated":"2020-11-03T13:04:34.208Z","comments":false,"path":"2020/04/15/SpringBoot集成Sentinel要点/","link":"","permalink":"https://zhechu.github.io/2020/04/15/SpringBoot集成Sentinel要点/","excerpt":"","text":"组件 版本 spring-cloud-starter-alibaba-sentinel 2.1.1.RELEASE 官方文档 https://github.com/alibaba/Sentinel/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97 官方示例 https://github.com/alibaba/Sentinel/tree/master/sentinel-demo 扩展资料 https://github.com/sentinel-group/sentinel-awesome 1 拉取源码克隆指定版本代码12git clone --branch 1.7.0 https://github.com/alibaba/Sentinel.gitgit clone --branch v2.1.1.RELEASE https://github.com/alibaba/spring-cloud-alibaba.git 2 支持 Restful 风格 URL过滤器执行顺序需调整1spring.cloud.sentinel.filter.order = 1 TIPS：需待DispatcherServlet解析完成，不然拿不到@RequestMapping声明的URL 应用端加上如下配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import com.alibaba.csp.sentinel.adapter.servlet.callback.WebCallbackManager;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.AnnotatedElementUtils;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.DispatcherServlet;import org.springframework.web.servlet.HandlerExecutionChain;import org.springframework.web.servlet.HandlerMapping;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import javax.annotation.PostConstruct;import javax.servlet.http.HttpServletRequest;/** * Sentinel全局配置 * * @author lingyuwang * @date 2020-3-28 09:41:01 * @since 1.0.9 */@Configuration@Slf4jpublic class SentinelConfiguration &#123; /** * 用于获取请求路径并进行清洗 * 限流的过滤器启动顺序需按如下配置 * spring.cloud.sentinel.filter.order = 1 * * @author lingyuwang * @date 2020-04-07 11:35 * @since 1.0.9 */ @Autowired private DispatcherServlet dispatcherServlet; private final static String ROOT_PATH = \"/\"; @PostConstruct private void setUrlCleaner() &#123; // 清洗URL WebCallbackManager.setUrlCleaner(originUrl -&gt; &#123; if (originUrl == null || originUrl.isEmpty()) &#123; return originUrl; &#125; for (HandlerMapping mapping : dispatcherServlet.getHandlerMappings()) &#123; if (mapping instanceof RequestMappingHandlerMapping) &#123; HandlerExecutionChain handler = null; try &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes != null) &#123; HttpServletRequest request = attributes.getRequest(); handler = mapping.getHandler(request); &#125; &#125; catch (Exception e) &#123; log.error(\"限流清洗URL异常\", e); &#125; // handler hit, then resolve resource name from Controller and it's Controller method if (handler != null) &#123; Object handlerObject = handler.getHandler(); if (handlerObject instanceof HandlerMethod) &#123; HandlerMethod handlerMethod = (HandlerMethod)handlerObject; String pattern = resolveResourceNameHandlerMethod(handlerMethod); if (StringUtils.isNotEmpty(pattern)) &#123; return pattern; &#125; &#125; &#125; &#125; &#125; return originUrl; &#125;); &#125; /** * 解析 Controller 声明的 @RequestMapping 注解的路径 * * @param handlerMethod * @return java.lang.String * @author lingyuwang * @date 2020-04-07 11:36 * @since 1.0.9 */ private String resolveResourceNameHandlerMethod(HandlerMethod handlerMethod) &#123; String typeMapping = \"\"; RequestMapping typeRequestMapping = AnnotatedElementUtils.findMergedAnnotation(handlerMethod.getBeanType(), RequestMapping.class); if (typeRequestMapping!=null &amp;&amp; typeRequestMapping.value().length &gt; 0) &#123; typeMapping = typeRequestMapping.value()[0]; &#125; RequestMapping methodRequestMapping = AnnotatedElementUtils.findMergedAnnotation(handlerMethod.getMethod(), RequestMapping.class); String methodMapping = methodRequestMapping.value()[0]; if (typeMapping.length() &gt; 1 &amp;&amp; typeMapping.endsWith(ROOT_PATH)) &#123; typeMapping = typeMapping.substring(0, typeMapping.length() - 1); &#125; return typeMapping + methodMapping; &#125;&#125; TIPS：详情参考 https://blog.csdn.net/u010349169/article/details/91633042，但笔者认为上述方案更加优雅 3 降级从 Hystrix 迁移到 Sentinel http://www.itmuch.com/spring-cloud-alibaba-migration/spring-cloud-alibaba-2/ 4 规则持久化4.1 Apollo 规则持久化集成 Apollo 规则持久化 https://blog.csdn.net/hosaos/article/details/96305016 https://github.com/zhechu/apollo-sentinel-dashboard 4.1.1 Zuul 配置示例12345678910111213141516171819202122232425# 监控数据日志路径spring.cloud.sentinel.log.dir = $&#123;logging.path&#125;/csp/$&#123;spring.application.name&#125;/# 是否开启限流spring.cloud.sentinel.enabled = true# 限流过滤器执行顺序spring.cloud.sentinel.zuul.order.pre = 2000spring.cloud.sentinel.zuul.order.post = 500spring.cloud.sentinel.zuul.order.error = -100# 网关限流API端口spring.cloud.sentinel.transport.port = 8802# 系统规则spring.cloud.sentinel.datasource.ds1.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds1.apollo.flow-rules-key = zuul-service-system-rulesspring.cloud.sentinel.datasource.ds1.apollo.rule-type = systemzuul-service-system-rules = []# 网关API管理spring.cloud.sentinel.datasource.ds2.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds2.apollo.flow-rules-key = zuul-service-gw-api-groupspring.cloud.sentinel.datasource.ds2.apollo.rule-type = gw-api-groupzuul-service-gw-api-group = []# 网关流控规则spring.cloud.sentinel.datasource.ds3.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds3.apollo.flow-rules-key = zuul-service-gw-flow-rulesspring.cloud.sentinel.datasource.ds3.apollo.rule-type = gw-flowzuul-service-gw-flow-rules = [] 4.1.2 普通服务配置示例1234567891011121314151617181920212223242526272829303132333435# 监控数据日志路径spring.cloud.sentinel.log.dir = $&#123;logging.path&#125;/csp/$&#123;spring.application.name&#125;/# 是否开启限流spring.cloud.sentinel.enabled = true# 服务启动后立即给限流控制台发心跳spring.cloud.sentinel.eager = true# 限流过滤器顺序，因需处理 restful 风格路径spring.cloud.sentinel.filter.order = 1# 限流API端口spring.cloud.sentinel.transport.port = 8812# 系统规则spring.cloud.sentinel.datasource.ds1.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds1.apollo.flow-rules-key = app-http-system-rulesspring.cloud.sentinel.datasource.ds1.apollo.rule-type = systemapp-http-system-rules = []# 流控规则spring.cloud.sentinel.datasource.ds2.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds2.apollo.flow-rules-key = app-http-flow-rulesspring.cloud.sentinel.datasource.ds2.apollo.rule-type = flowapp-http-flow-rules = []# 降级规则spring.cloud.sentinel.datasource.ds3.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds3.apollo.flow-rules-key = app-http-degrade-rulesspring.cloud.sentinel.datasource.ds3.apollo.rule-type = degradeapp-http-degrade-rules = []# 热点规则spring.cloud.sentinel.datasource.ds4.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds4.apollo.flow-rules-key = app-http-param-flow-rulesspring.cloud.sentinel.datasource.ds4.apollo.rule-type = param-flowapp-http-param-flow-rules = []# 授权规则spring.cloud.sentinel.datasource.ds5.apollo.namespace-name = sentinelspring.cloud.sentinel.datasource.ds5.apollo.flow-rules-key = app-http-authority-rulesspring.cloud.sentinel.datasource.ds5.apollo.rule-type = authorityapp-http-authority-rules = [] 5 Sentinel transport 模块 BUG 修复官方 issues https://github.com/alibaba/Sentinel/issues/1349 笔者描述：Sentinel 的 1.7.0 版本的 transport 模块存在通讯 BUG（官方却声称是 FastJson 版本的问题，其在 Sentinel 的高版本已解决）。 具体 BUG 解决方案","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"求图中两节点间的有效路径","slug":"求图中两节点间的有效路径","date":"2020-04-01T14:25:34.000Z","updated":"2020-11-03T13:04:34.289Z","comments":false,"path":"2020/04/01/求图中两节点间的有效路径/","link":"","permalink":"https://zhechu.github.io/2020/04/01/求图中两节点间的有效路径/","excerpt":"","text":"图的广度优先搜索比较适合求解两节点间的最短路径，而深度优先搜索适合快速求解两节点间的有效路径（但不保证其为最短路径） 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/graph/GraphOfAdjacency.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import java.util.LinkedList;import java.util.List;import java.util.Queue;/** * 求图中两节点间的有效路径 */public class GraphOfAdjacency &#123; public static void main(String[] args) &#123; GraphOfAdjacency graphOfAdjacency = new GraphOfAdjacency(8); graphOfAdjacency.addEdge(0,1); graphOfAdjacency.addEdge(0,3); graphOfAdjacency.addEdge(1,2); graphOfAdjacency.addEdge(1,4); graphOfAdjacency.addEdge(2,5); graphOfAdjacency.addEdge(4,5); graphOfAdjacency.addEdge(4,6); graphOfAdjacency.addEdge(5,7); graphOfAdjacency.addEdge(6,7); // 广度优先（最短路径） graphOfAdjacency.bfs(0,6); System.out.println(); // 深度优先（不保证最短路径） graphOfAdjacency.dfs(0, 6); &#125; /** 顶点个数 */ private int vertexSize; /** 邻接表 */ private List&lt;Integer&gt;[] adj; public GraphOfAdjacency(int vertexSize) &#123; this.vertexSize = vertexSize; adj = new LinkedList[vertexSize]; for (int i = 0; i &lt; vertexSize; ++i) &#123; adj[i] = new LinkedList&lt;&gt;(); &#125; &#125; /** * 添加边 * * @param s 顶点 * @param t 顶点 */ public void addEdge(int s, int t) &#123; // 无向图一条边存两次 adj[s].add(t); adj[t].add(s); &#125; /** * 广度优先搜索 * @param s * @param t */ public void bfs(int s, int t) &#123; if (s == t) &#123; return; &#125; // 记录已经被访问的顶点，避免顶点被重复访问 boolean[] visited = new boolean[vertexSize]; visited[s] = true; // 存储已经被访问、但相连的顶点还没有被访问的顶点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); queue.add(s); // 记录搜索路径 int[] prev = new int[vertexSize]; for (int i = 0; i &lt; vertexSize; ++i) &#123; prev[i] = -1; &#125; while (queue.size() != 0) &#123; int w = queue.poll(); for (int q : adj[w]) &#123; if (visited[q]) &#123; continue; &#125; prev[q] = w; if (q == t) &#123; print(prev, s, t); return; &#125; visited[q] = true; queue.add(q); &#125; &#125; &#125; /** * 递归打印 s-&gt;t 的路径 * @param prev * @param s * @param t */ private void print(int[] prev, int s, int t) &#123; if (prev[t] != -1 &amp;&amp; t != s) &#123; print(prev, s, prev[t]); &#125; System.out.print(t + \" \"); &#125; /** 全局变量或者类成员变量 */ private boolean found = false; /** * 深度优先搜索 * @param s * @param t */ public void dfs(int s, int t) &#123; found = false; boolean[] visited = new boolean[vertexSize]; int[] prev = new int[vertexSize]; for (int i = 0; i &lt; vertexSize; ++i) &#123; prev[i] = -1; &#125; recurDfs(s, t, visited, prev); print(prev, s, t); &#125; /** * 深度递归 * @param w * @param t * @param visited * @param prev */ private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123; if (found == true) &#123; return; &#125; visited[w] = true; if (w == t) &#123; found = true; return; &#125; for (int q : adj[w]) &#123; if (!visited[q]) &#123; prev[q] = w; recurDfs(q, t, visited, prev); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"},{"name":"图","slug":"图","permalink":"https://zhechu.github.io/tags/图/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"JMeter使用教程","slug":"JMeter使用教程","date":"2020-03-29T04:09:43.000Z","updated":"2020-11-03T13:04:34.104Z","comments":false,"path":"2020/03/29/JMeter使用教程/","link":"","permalink":"https://zhechu.github.io/2020/03/29/JMeter使用教程/","excerpt":"","text":"JMeter安装及配置 JMeter性能测试用例.zip 1 聚合报告收集平均响应时间和吞吐率等重要测试指标 参数 说明 Label 每个JMeter的element都有一个Name属性，这里显示的就是Name属性的值 #Samples 表示此次测试中一共发出了多少个请求，若模拟10个用户，每个用户迭代10次，则显示100 Average 平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以 Transaction 为单位显示平均响应时间 Median 中位数，也就是 50％ 用户的响应时间 90% Line 90％ 用户的响应时间 95% Line 95％ 用户的响应时间 99% Line 99％ 用户的响应时间 Min 最小响应时间 Max 最大响应时间 Error% 此次测试中出现错误的请求的数量/请求的总数 Throughput 吞吐量——默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数 接收 KB/sec 每秒从服务器端接收到的数据量，相当于 LoadRunner 中的 Throughput/Sec 发送 KB/sec 每秒从客户端发送到服务器的数据量 2 测试计划2.1 保存 TIPS：若不保存，关闭 JMeter 后则会丢失 2.2 打开 3 测试用例3.1 无状态接口 TIPS：无状态即为不需登录，或不需带上 Session 等保持状态的参数 添加线程组并命名为获取服务状态 添加 HTTP 请求配置 添加聚合报告 清除上一次测试数据（否则会累计） 添加察看结果树（查看请求详细过程） TIPS：可以清除察看结果树，类似聚合报告。 启动测试 查看测试结果 3.2 有状态接口3.2.1 获取用户凭证接口添加线程组并命名为获取用户凭证 添加 HTTP 信息头管理器（HTTP Header） TIPS：随便一个 token 即可，只是接口要求，其实并没有用处。 添加 HTTP 请求配置 添加察看结果树（查看请求详细过程） 3.2.2 推荐视频列表接口添加线程组并命名为推荐视频列表 添加获取 token HTTP 请求 获取 token HTTP 请求添加请求头 添加 token 提取器 添加推荐视频列表 HTTP 请求 推荐视频列表 HTTP 请求添加请求头 添加察看结果树（查看请求详细过程） 3.3 引用外部文件数据3.3.1 批量用户查询推荐视频列表接口添加线程组并命名为批量用户查询推荐视频列表 添加获取 token HTTP 请求 添加 CSV 数据文件设置（引用外部文件数据） CSV 文件内容为待测试的用户手机号（每行一个手机号，测试时线程数需跟用户数一致；若线程数大于用户数，则会在其中的用户中循环获取） TIPS：后续步骤请参考 3.2.2 章 添加察看结果树（查看请求详细过程） 3.4 集合点3.4.1 集合用户查询推荐视频列表接口添加线程组并命名为集合用户查询推荐视频列表 TIPS：后续步骤请参考 3.3.1 章 CSV 文件内容为待测试的用户手机号（每行一个手机号，测试时线程数需跟用户数一致；若线程数大于用户数，则会在其中的用户中循环获取） 添加固定定时器（防止获取 token 的请求影响后续接口的测试） 添加集合同步定时器（集合点关键） 查看测试结果 3.5 分布式官方文档 https://jmeter.apache.org/usermanual/jmeter_distributed_testing_step_by_step.html 角色 IP RMI 端口 控制机（同时为负载机） 10.113.248.63 1099 负载机 10.113.248.63 2099 负载机 10.113.248.63 3099 TIPS：集合点只能是单机内部集合，JMeter 无法做到多节点集合。 3.5.1 控制机创建密钥文件rmi_keystore.jks（RMI 的默认传输机制需使用 SSL） 控制机 jmeter 的 bin 目录下 jmeter.properties 配置12remote_hosts=10.113.248.63:1099,10.113.248.63:2099,10.113.248.63:3099server_port=1099 启动完负载机后，再启动控制机 3.5.2 负载机复制控制机生成的rmi_keystore.jks文件到每一台负载机 jmeter 的 bin 目录下 负载机 jmeter 的 bin 目录下 jmeter.properties 修改端口为 20991server_port=2099 启动负载机1$ jmeter-server -Djava.rmi.server.hostname=10.113.248.63 TIPS：10.113.248.63:3099 同理。 3.5.3 使用效果使用单台负载机测试 使用所有负载机测试 TIPS：使用察看结果树查看响应结果时为空，是正常的。","categories":[{"name":"Test","slug":"Test","permalink":"https://zhechu.github.io/categories/Test/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://zhechu.github.io/tags/性能测试/"},{"name":"JMeter","slug":"JMeter","permalink":"https://zhechu.github.io/tags/JMeter/"}],"keywords":[{"name":"Test","slug":"Test","permalink":"https://zhechu.github.io/categories/Test/"}]},{"title":"JMeter安装及配置","slug":"JMeter安装及配置","date":"2020-03-29T03:09:34.000Z","updated":"2020-11-03T13:04:34.133Z","comments":false,"path":"2020/03/29/JMeter安装及配置/","link":"","permalink":"https://zhechu.github.io/2020/03/29/JMeter安装及配置/","excerpt":"","text":"官方文档 http://jmeter.apache.org 1 简介Apache JMeter 应用程序是开源软件，100%纯 Java 应用程序，用于测试功能行为和测量性能。它最初是为测试 Web 应用程序而设计的，但后来扩展到其他测试功能。 在多数情况下，可以使用 JMeter 代替 LoadRunner 进行功能测试和性能测试，提高测试效率，降低学习成本。 2 安装2.1 Windows 安装 JMeter-5.2.12.1.1 准备安装前需安装并配置Jdk1.8环境变量。 2.1.2 下载并启动进入 http://jmeter.apache.org/download_jmeter.cgi 页面点击下载（可以理解为绿色版） 解压后进入 apache-jmeter-5.2.1\\bin 双击 jmeter.bat 文件启动程序 启动成功界面 2.1.3 设置临时设置语言（这里选择中文简体） 永久设置语言（关闭后重启仍然生效）打开 apache-jmeter-5.2.1\\bin\\jmeter.properties 修改 language 配置为 language=zh_CN 设置界面风格为 System（这是永久生效的，跟操作系统的界面风格一样，默认是 Darcula） 重启后的效果","categories":[{"name":"Test","slug":"Test","permalink":"https://zhechu.github.io/categories/Test/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"https://zhechu.github.io/tags/性能测试/"},{"name":"JMeter","slug":"JMeter","permalink":"https://zhechu.github.io/tags/JMeter/"}],"keywords":[{"name":"Test","slug":"Test","permalink":"https://zhechu.github.io/categories/Test/"}]},{"title":"双堆求解中位数","slug":"双堆求解中位数","date":"2020-03-27T14:58:09.000Z","updated":"2020-11-03T13:04:34.284Z","comments":false,"path":"2020/03/27/双堆求解中位数/","link":"","permalink":"https://zhechu.github.io/2020/03/27/双堆求解中位数/","excerpt":"","text":"思路 建立一个大根堆和一个小根堆，用一个临时变量（count）来统计数据流的个数 当插入的数字个数为奇数时，使小根堆的个数比大根堆多1；当插入的数字个数为偶数时，使大根堆和小根堆的个数一样多 当总的个数为奇数时，中位数就是小根堆的堆顶；当总的个数为偶数时，中位数就是两个堆顶的值相加除以2 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/heap/MedianFinder.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.List;import java.util.PriorityQueue;import java.util.stream.Collectors;import java.util.stream.Stream;/** * 1.建立一个大根堆和一个小根堆，用一个临时变量（count）来统计数据流的个数 * 2.当插入的数字个数为奇数时，使小根堆的个数比大根堆多1；当插入的数字个数为偶数时，使大根堆和小根堆的个数一样多 * 3.当总的个数为奇数时，中位数就是小根堆的堆顶；当总的个数为偶数时，中位数就是两个堆顶的值相加除以2 */public class MedianFinder &#123; public static void main(String[] args) &#123; // 构造一个 范围为 [0, 2^8] 的 Integer 流，通过limit可以控制大小 final int upLimit = 1 &lt;&lt; 8; List&lt;Integer&gt; originList = Stream.generate(Math::random) .map(d -&gt; d * upLimit) .map(d -&gt; (int) Math.round(d)) .limit(9) .collect(Collectors.toList()); MedianFinder medianFinder = new MedianFinder(); originList.forEach(medianFinder::add); originList.sort((o1, o2) -&gt; (o1 - o2)); System.out.println(\"originList: \" + originList); double median = medianFinder.getMedian(); System.out.println(\"median: \" + median); &#125; private PriorityQueue&lt;Integer&gt; min = new PriorityQueue&lt;&gt;((o1, o2) -&gt; (o1 - o2)); private PriorityQueue&lt;Integer&gt; max = new PriorityQueue&lt;&gt;((o1, o2) -&gt; (o2 - o1)); /** 统计数据流的个数 */ private int count = 0; /** * 确保小根堆里面的数 &gt; 大根堆里面的数 * @param num */ public void add(int num) &#123; count++; if (count % 2 == 1) &#123; // 若小于大根堆的堆顶，则先从大根堆过滤一遍 if (max.peek() != null &amp;&amp; num &lt; max.peek()) &#123; max.add(num); min.add(max.poll()); &#125; // 直接放入小根堆 else &#123; min.add(num); &#125; &#125; else &#123; // 若大于小根堆的堆顶，则先从小顶堆过滤一遍 if (min.peek() != null &amp;&amp; num &gt; min.peek() ) &#123; min.add(num); max.add(min.poll()); &#125; // 直接放入大根堆 else &#123; max.add(num); &#125; &#125; &#125; /** * 获取中位数 * @return */ public double getMedian() &#123; if (count == 0) &#123; throw new RuntimeException(\"队列大小为空\"); &#125; if (count % 2 == 0) &#123; return (min.peek() + max.peek()) / 2.0; &#125; return min.peek(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"TopK问题求解","slug":"TopK问题求解","date":"2020-03-27T13:26:31.000Z","updated":"2020-11-03T13:04:34.220Z","comments":false,"path":"2020/03/27/TopK问题求解/","link":"","permalink":"https://zhechu.github.io/2020/03/27/TopK问题求解/","excerpt":"","text":"求解一组 int 数据中最小的前 10 个整数 示例代码 https://github.com/zhechu/algorithm-demo/tree/master/src/main/java/com/wise/algorithm/heap 1 基于 PriorityQueue 求解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import java.util.*;import java.util.stream.Collectors;import java.util.stream.Stream;/** * 通过 PriorityQueue 求解 TopK 问题 * @param &lt;T&gt; */public class PriorityQueueTopK&lt;T&gt; &#123; public static void main(String[] args) &#123; // 对数器检查通过 PriorityQueue 实现的算法是否正确// check(); // 构造一个 范围为 [0, 2^30] 的 Integer 流，通过limit可以控制大小 final int upLimit = 1 &lt;&lt; 30; List&lt;Integer&gt; originList = Stream.generate(Math::random) .map(d -&gt; d * upLimit) .map(d -&gt; (int) Math.round(d)) .limit(100000000) .collect(Collectors.toList()); // 将 (o1, o2) -&gt; (o1 - o2) 换成 (o1, o2) -&gt; (o2 - o1) 可以求解 top K 小 PriorityQueueTopK&lt;Integer&gt; priorityQueueTopK = new PriorityQueueTopK&lt;&gt;(10, (o1, o2) -&gt; (o2 - o1)); long startTime = System.currentTimeMillis(); List&lt;Integer&gt; results = priorityQueueTopK.getTopK(originList); long endTime = System.currentTimeMillis();// System.out.println(\"origin: \" + originList); System.out.println(\"results: \" + results); System.out.println(\"cost: \" + (endTime - startTime)); // 510 655 518 513 667 // average: 572 &#125; /** * 检查通过 PriorityQueue 实现的算法是否正确 */ public static void check() &#123; // 对数器 int testTime = 100; boolean succeed = true; List&lt;Comparator&lt;Integer&gt;&gt; comparatorList = new ArrayList&lt;&gt;(2); comparatorList.add((o1, o2) -&gt; (o1 - o2)); comparatorList.add((o1, o2) -&gt; (o2 - o1)); for (int i = 0; i &lt; testTime; i++) &#123; // 构造一个 范围为 [0, 2^30] 的 Integer 流，通过limit可以控制大小 final int upLimit = 1 &lt;&lt; 20; List&lt;Integer&gt; originList = Stream.generate(Math::random) .map(d -&gt; d * upLimit) .map(d -&gt; (int) Math.round(d)) .limit(100000) .collect(Collectors.toList()); int boundary = 10; Comparator&lt;Integer&gt; comparator = comparatorList.get(testTime % 2); HeapTopK&lt;Integer&gt; heapTopK = new HeapTopK&lt;&gt;(boundary, comparator); List&lt;Integer&gt; headTopKResult = heapTopK.getTopK(originList); PriorityQueueTopK&lt;Integer&gt; priorityQueueTopK = new PriorityQueueTopK&lt;&gt;(boundary, comparator); List&lt;Integer&gt; priorityQueueTopKResult = priorityQueueTopK.getTopK(originList); if (headTopKResult.size() != boundary || headTopKResult.size() != priorityQueueTopKResult.size()) &#123; System.out.println(\"size check fail, origin: \" + originList); System.out.println(\"size check fail, headTopKResult: \" + headTopKResult); System.out.println(\"size check fail, priorityQueueTopKResult: \" + priorityQueueTopKResult); succeed = false; break; &#125; for (int j = 0; j &lt; boundary; j++) &#123; if (!headTopKResult.get(j).equals(priorityQueueTopKResult.get(j))) &#123; System.out.println(\"result check fail, origin: \" + originList); System.out.println(\"result check fail, headTopKResult: \" + headTopKResult); System.out.println(\"result check fail, priorityQueueTopKResult: \" + priorityQueueTopKResult); succeed = false; break; &#125; &#125; if (!succeed) &#123; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); &#125; /** 堆的边界，Top K 问题中的 K */ private final int boundary; /** 优先队列，构造一个有界的堆 */ private final PriorityQueue&lt;T&gt; boundaryHeap; /** 比较器 */ private final Comparator&lt;T&gt; comparator; /** * 求解 top K 问题 * @param boundary 边界 K * @param comparator 数据比较器 */ public PriorityQueueTopK(int boundary, Comparator&lt;T&gt; comparator) &#123; this.boundary = boundary; boundaryHeap = new PriorityQueue&lt;&gt;(boundary, comparator); this.comparator = comparator; &#125; /** * 求解数据流中的 top K * @param originList 原始数据 * @return top K 结果 */ public List&lt;T&gt; getTopK(List&lt;T&gt; originList) &#123; int size = originList.size(); if (size &lt;= boundary) &#123; return originList; &#125; List&lt;T&gt; result = new ArrayList&lt;&gt;(boundary); // 堆化 for (int i = 0; i &lt; boundary; i++) &#123; buildHeap(originList.get(i)); &#125; // 向已经堆化的堆插入数据 for (int i = boundary; i &lt; size; i++) &#123; add(originList.get(i)); &#125; while (!boundaryHeap.isEmpty()) &#123; result.add(boundaryHeap.poll()); &#125; return result; &#125; /** * 堆化 * @param t */ private void buildHeap(T t) &#123; boundaryHeap.add(t); &#125; /** * 向有界堆中添加元素的帮助方法 * @param t 待添加数据 */ private void add(T t) &#123; if (comparator.compare(t, boundaryHeap.peek()) &gt; 0) &#123; boundaryHeap.poll(); boundaryHeap.add(t); &#125; &#125;&#125; 2 构建堆自定义算法求解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215import java.util.*;import java.util.stream.Collectors;import java.util.stream.Stream;/** * 通过构建堆结构求解 TopK 问题 * * @param &lt;E&gt; */public class HeapTopK&lt;E&gt; &#123; public static void main(String[] args) &#123; // 对数器检查自定义算法是否正确// check(); // 构造一个 范围为 [0, 2^30] 的 Integer 流，通过limit可以控制大小 final int upLimit = 1 &lt;&lt; 30; List&lt;Integer&gt; originList = Stream.generate(Math::random) .map(d -&gt; d * upLimit) .map(d -&gt; (int) Math.round(d)) .limit(100000000) .collect(Collectors.toList()); // 将 (o1, o2) -&gt; (o1 - o2) 换成 (o1, o2) -&gt; (o2 - o1) 可以求解 top K 小 HeapTopK&lt;Integer&gt; heapTopK = new HeapTopK&lt;&gt;(10, (o1, o2) -&gt; (o2 - o1)); long startTime = System.currentTimeMillis(); List&lt;Integer&gt; results = heapTopK.getTopK(originList); long endTime = System.currentTimeMillis();// System.out.println(\"origin: \" + originList); System.out.println(\"results: \" + results); System.out.println(\"cost: \" + (endTime - startTime)); // 747 483 603 629 565 // average: 605 &#125; /** * 检查自定义算法是否正确 */ public static void check() &#123; // 对数器 int testTime = 100; boolean succeed = true; List&lt;Comparator&lt;Integer&gt;&gt; comparatorList = new ArrayList&lt;&gt;(2); comparatorList.add((o1, o2) -&gt; (o1 - o2)); comparatorList.add((o1, o2) -&gt; (o2 - o1)); for (int i = 0; i &lt; testTime; i++) &#123; // 构造一个 范围为 [0, 2^30] 的 Integer 流，通过limit可以控制大小 final int upLimit = 1 &lt;&lt; 20; List&lt;Integer&gt; originList = Stream.generate(Math::random) .map(d -&gt; d * upLimit) .map(d -&gt; (int) Math.round(d)) .limit(100000) .collect(Collectors.toList()); int boundary = 10; Comparator&lt;Integer&gt; comparator = comparatorList.get(testTime % 2); HeapTopK&lt;Integer&gt; heapTopK = new HeapTopK&lt;&gt;(boundary, comparator); List&lt;Integer&gt; headTopKResult = heapTopK.getTopK(originList); PriorityQueueTopK&lt;Integer&gt; priorityQueueTopK = new PriorityQueueTopK&lt;&gt;(boundary, comparator); List&lt;Integer&gt; priorityQueueTopKResult = priorityQueueTopK.getTopK(originList); if (headTopKResult.size() != boundary || headTopKResult.size() != priorityQueueTopKResult.size()) &#123; System.out.println(\"size check fail, origin: \" + originList); System.out.println(\"size check fail, headTopKResult: \" + headTopKResult); System.out.println(\"size check fail, priorityQueueTopKResult: \" + priorityQueueTopKResult); succeed = false; break; &#125; for (int j = 0; j &lt; boundary; j++) &#123; if (!headTopKResult.get(j).equals(priorityQueueTopKResult.get(j))) &#123; System.out.println(\"result check fail, origin: \" + originList); System.out.println(\"result check fail, headTopKResult: \" + headTopKResult); System.out.println(\"result check fail, priorityQueueTopKResult: \" + priorityQueueTopKResult); succeed = false; break; &#125; &#125; if (!succeed) &#123; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); &#125; /** 堆的边界，Top K 问题中的 K */ private final int boundary; /** TopK 数据 */ transient Object[] queue; /** 比较器 */ private final Comparator&lt;E&gt; comparator; public HeapTopK(int boundary, Comparator&lt;E&gt; comparator) &#123; this.boundary = boundary; this.queue = new Object[boundary]; this.comparator = comparator; &#125; /** * 求解数据流中的 top K * @param originList 原始数据 * @return top K 结果 */ public List&lt;E&gt; getTopK(List&lt;E&gt; originList) &#123; int size = originList.size(); if (size &lt;= boundary) &#123; return originList; &#125; for (int i = 0; i &lt; boundary; i++) &#123; queue[i] = originList.get(i); &#125; // 堆化 buildHeap(queue); for (int j = boundary; j &lt; size; j++) &#123; add(originList.get(j)); &#125; List&lt;E&gt; result = new ArrayList&lt;&gt;(boundary); Object[] es = queue; int len = boundary; while (len &gt; 0) &#123; result.add((E) es[0]); es[0] = es[--len]; heapify(es, 0, len); &#125; return result; &#125; /** * 自上往下堆化 * @param array * @param index * @param length */ private void heapify(Object[] array, int index, int length) &#123; do &#123; // 左节点指针 int left = (index &lt;&lt; 1) + 1; // 右节点指针 int right = (index &lt;&lt; 1) + 2; // 最小节点指针 int least = index; // 检查左节点 if (left &lt; length &amp;&amp; comparator.compare((E) array[left], (E) array[least]) &lt; 0) &#123; least = left; &#125; // 检查右节点 if (right &lt; length &amp;&amp; comparator.compare((E) array[right], (E) array[least]) &lt; 0) &#123; least = right; &#125; // 若最小节点不是父节点，则交换并继续调整 if (index != least) &#123; swap(array, least, index); // 继续向下调整 index = least; &#125; else &#123; break; &#125; &#125; while (true); &#125; /** * 两数交换 * @param array * @param i * @param j */ public static void swap(Object[] array, int i, int j) &#123; if (i == j) &#123; return; &#125; Object temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; /** * 建立堆 * @param array */ private void buildHeap(Object[] array) &#123; int length = array.length; // 自最后一个非叶子节点开始堆化 for (int i = (length - 2) &gt;&gt; 1; i &gt;= 0; i--) &#123; heapify(array, i, length); &#125; &#125; /** * 向有界堆中添加元素的帮助方法 * @param t 待添加数据 */ private void add(Object t) &#123; if (comparator.compare((E) t, (E) queue[0]) &gt; 0) &#123; queue[0] = t; heapify(queue, 0, boundary); &#125; &#125;&#125; 3 总结 方案1比较高效，且实现难度比较低，一般场景，推荐使用 方案2虽然测试结果不是很理想，但比较灵活，扩展性强，适用更多场景","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"跳表","slug":"跳表","date":"2020-03-11T17:00:15.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/03/12/跳表/","link":"","permalink":"https://zhechu.github.io/2020/03/12/跳表/","excerpt":"","text":"跳跃表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218/** * 跳表中存储的是正整数，并且存储的是不重复的 */public class SkipList &#123; public static void main(String[] args) &#123; /** * 示例： * null:15------- * null:14------- * null:13------- * null:12------- * null:11------- * null:10------- * 5:9------- * 5:8------- * 5:7------- * 5:6------- * 5:5------- * 5:4------- 8:4------- * 4:3-------5:3-------6:3-------7:3-------8:3------- * 1:2-------2:2------- 4:2-------5:2-------6:2-------7:2-------8:2------- * 1:1-------2:1-------3:1-------4:1-------5:1-------6:1-------7:1-------8:1------- * 1:0-------2:0-------3:0-------4:0-------5:0-------6:0-------7:0-------8:0------- * &#123; data: 1; levels: 3 &#125; &#123; data: 2; levels: 3 &#125; &#123; data: 3; levels: 2 &#125; &#123; data: 4; levels: 4 &#125; * &#123; data: 5; levels: 10 &#125; &#123; data: 6; levels: 4 &#125; &#123; data: 7; levels: 4 &#125; &#123; data: 8; levels: 5 &#125; */ SkipList list = new SkipList(); list.insert(1); list.insert(2); list.insert(6); list.insert(7); list.insert(8); list.insert(3); list.insert(4); list.insert(5); System.out.println(); list.printAllWithBeautiful(); System.out.println(); list.printAll(); int targetValue = 4; Node targetNode = list.find(targetValue); System.out.println(targetValue + \"的节点是：\" + targetNode); list.delete(targetValue); System.out.println(\"===================删除节点\" + targetValue + \"=====================\"); list.printAllWithBeautiful(); System.out.println(); list.printAll(); int newValue = 6; System.out.println(\"===================添加节点\" + newValue + \"=====================\"); list.insert(newValue); list.printAllWithBeautiful(); System.out.println(); list.printAll(); &#125; /** 每层晋升概率 */ private static final double SKIPLIST_P = 0.5d; /** 最大层 */ private static final int MAX_LEVEL = 16; /** 当前层数 */ private int levelCount = 1; /** 带头链表 */ private Node head = new Node(MAX_LEVEL); /** * 查找数据所在的节点 * @param value * @return */ public Node find(int value) &#123; Node p = head; // 从最大层开始查找，找到前一节点，通过--i，移动到下层再开始查找 for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; value &gt; p.forwards[i].data) &#123; // 找到前一节点 p = p.forwards[i]; &#125; &#125; if (p.forwards[0] != null &amp;&amp; p.forwards[0].data == value) &#123; return p.forwards[0]; &#125; return null; &#125; /** * 插入 * * @param value 值 */ public void insert(int value) &#123; int level = head.forwards[0] == null ? 1 : randomLevel(); // 每次只增加一层，如果条件满足 if (level &gt; levelCount) &#123; level = ++levelCount; &#125; Node newNode = new Node(level); newNode.data = value; Node p = head; // 从最大层开始查找，找到前一节点，通过--i，移动到下层再开始查找 for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; value &gt; p.forwards[i].data) &#123; // 找到前一节点 p = p.forwards[i]; &#125; if (i &lt; level) &#123; if (p.forwards[i] == null) &#123; p.forwards[i] = newNode; &#125; else &#123; Node next = p.forwards[i]; p.forwards[i] = newNode; newNode.forwards[i] = next; &#125; &#125; &#125; &#125; /** * 删除 * @param value */ public void delete(int value) &#123; Node[] update = new Node[levelCount]; Node p = head; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; while (p.forwards[i] != null &amp;&amp; value &gt; p.forwards[i].data) &#123; p = p.forwards[i]; &#125; update[i] = p; &#125; // 不存在则直接返回 if (p.forwards[0] == null || p.forwards[0].data != value) &#123; return; &#125; for (int i = levelCount - 1; i &gt;= 0; --i) &#123; if (update[i].forwards[i] != null &amp;&amp; update[i].forwards[i].data == value) &#123; update[i].forwards[i] = update[i].forwards[i].forwards[i]; &#125; &#125; &#125; /** * 理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。 * 该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ： * 50%的概率返回 1 * 25%的概率返回 2 * 12.5%的概率返回 3 ... * @return */ private int randomLevel() &#123; int level = 1; while (Math.random() &lt; SKIPLIST_P &amp;&amp; level &lt; MAX_LEVEL) &#123; level++; &#125; return level; &#125; public void printAll() &#123; Node p = head; while (p.forwards[0] != null) &#123; System.out.print(p.forwards[0] + \" \"); p = p.forwards[0]; &#125; System.out.println(); &#125; /** * 打印所有数据 */ public void printAllWithBeautiful() &#123; int maxLevel = head.forwards.length; for (int i = maxLevel - 1; i &gt;= 0; i--) &#123; Node[] d = head.forwards; do &#123; System.out.print((d[i] != null ? d[i].data : null) + \":\" + i + \"-------\"); &#125; while (d[i] != null &amp;&amp; (d = d[i].forwards)[i] != null); System.out.println(); &#125; &#125; /** * 跳表的节点，每个节点记录了当前节点数据和所在层数数据 */ public class Node &#123; private int data = -1; /** * 表示当前节点位置的下一个节点所有层的数据，从上层切换到下层，就是数组下标-1， * forwards[3]表示当前节点在第三层的下一个节点。 */ private Node[] forwards; public Node(int level) &#123; forwards = new Node[level]; &#125; @Override public String toString() &#123; StringBuilder builder = new StringBuilder(); builder.append(\"&#123; data: \"); builder.append(data); builder.append(\" &#125;\"); return builder.toString(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-03-10T13:34:31.000Z","updated":"2020-11-03T13:04:34.275Z","comments":false,"path":"2020/03/10/二分查找/","link":"","permalink":"https://zhechu.github.io/2020/03/10/二分查找/","excerpt":"","text":"1 查找第一个值等于给定值的元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 二分查找 * @author lingyuwang * @date 2019-07-13 11:01 */public class Binary &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 2, 3, 3, 4, 5, 6&#125;; int target = 3; int targetIndex = searchFirst(arr, target); System.out.println(\"第一个值等于给定值的索引：\" + targetIndex); // 2 targetIndex = searchFirstForOptimize(arr, target); System.out.println(\"第一个值等于给定值的索引：\" + targetIndex); // 2 &#125; /** * 查找第一个值等于给定值的元素 * @param arr * @param value * @return */ public static int searchFirst(int[] arr, int value) &#123; // 数组长度 int len = arr.length; int low = 0; int high = len - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] &gt; value) &#123; high = mid - 1; &#125; else if (arr[mid] &lt; value) &#123; low = mid + 1; &#125; else &#123; if ((mid == 0) || (arr[mid - 1] != value)) &#123; return mid; &#125; else &#123; high = mid - 1; &#125; &#125; &#125; return -1; &#125; /** * 查找第一个值等于给定值的元素（优化） * @param arr * @param value * @return */ public static int searchFirstForOptimize(int[] arr, int value) &#123; // 数组长度 int len = arr.length; int low = 0; int high = len - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); // 若目标值在右边，则指针不断往左移 if (arr[mid] &gt;= value) &#123; high = mid - 1; &#125; // 若刚好错过目标值，已跑到左边去检索，在后面的检索中指针也会移回来 else &#123; low = mid + 1; &#125; &#125; // 检查 if (low &lt; len &amp;&amp; arr[low] == value) &#123; return low; &#125; return -1; &#125;&#125; 2 循环有序数组二分查找思路：与简单的二分查找思路一致，但多出边界判断。若首元素小于 mid，则前半部分是有序的，后半部分是循环有序数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 循环有序数组二分查找 * @author lingyuwang * @date 2019-07-13 11:01 */public class BinaryFromCircleArray &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 10, 11, 12, 13, 3, 4, 5, 6&#125;; int target = 3; int targetIndex = search(arr, target); System.out.println(\"目标索引：\" + targetIndex); // 6 target = 8; targetIndex = search(arr, target); System.out.println(\"目标索引：\" + targetIndex); // 0 target = 6; targetIndex = search(arr, target); System.out.println(\"目标索引：\" + targetIndex); // 9 &#125; /** * 循环有序数组二分查找 * @param arr * @param value * @return */ public static int search(int[] arr, int value) &#123; // 数组长度 int len = arr.length; int low = 0; int high = len - 1; while (low &lt;= high) &#123; int mid = low + ((high - low) &gt;&gt; 1); if (arr[mid] == value) &#123; return mid; &#125; // 转折点在右边 if (arr[mid] &gt; arr[low]) &#123; if (arr[low] == value) &#123; return low; &#125; if (arr[low] &lt; value &amp;&amp; value &lt; arr[mid]) &#123; high = mid - 1; // low 已被检查过，不需再次检查 low++; &#125; else &#123; low = mid + 1; &#125; &#125; // 转折点在左边 else &#123; if (arr[high] == value) &#123; return high; &#125; if (arr[mid] &lt; value &amp;&amp; value &lt; arr[high]) &#123; low = mid + 1; // hight 已被检查过，不需再次检查 high--; &#125; else &#123; high = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"基数排序","slug":"基数排序","date":"2020-03-08T12:27:32.000Z","updated":"2020-11-03T13:04:34.284Z","comments":false,"path":"2020/03/08/基数排序/","link":"","permalink":"https://zhechu.github.io/2020/03/08/基数排序/","excerpt":"","text":"原理：将整数按位数切割成不同的数字，然后基于计数排序逐步使其有序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数 平均时间复杂度 额外空间复杂度 稳定性 备注 O(n) O(n) 稳定 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202/** * 基数排序 * @author lingyuwang * @date 2019-07-13 11:01 */public class Radix &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 100; int maxSize = 100; int maxValue = 10000; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); radixSort(arr1); Arrays.sort(arr2); // 检查经基数排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 基数排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 radixSort(arr); // 排序后 printArray(arr); &#125; /** * 随机数排序 * @param arr */ public static void radixSort(int[] arr) &#123; // 数组长度 int len = arr.length; if (len &lt; 2) &#123; return; &#125; int mod = 10; int dev = 1; // 计数数组长度 int countLen = 19; // 计数数组索引填充 int countAppend = 9; // 最大位数 int maxDigit = getMaxDigit(arr); for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; // 申请一个计数数组，考虑负数的情况，下标大小[0, 19] int[] countArr = new int[countLen]; // 计算每个元素的个数，放入计数数组中 for (int j = 0; j &lt; len; j++) &#123; int bucket = ((arr[j] % mod) / dev) + countAppend; countArr[bucket]++; &#125; // 求小于或等于自身的元素个数并记录到对应的索引位置 for (int k = 1; k &lt; countLen; k++) &#123; countArr[k] = countArr[k - 1] + countArr[k]; &#125; int[] result = new int[len]; // 从后往前扫描原数组并将结果记录到结果数组 for (int r = len - 1; r &gt;= 0; r--) &#123; int bucket = ((arr[r] % mod) / dev) + countAppend; // 计数数组对应的计数值即为元素排序后的位置 int index = countArr[bucket] - 1; result[index] = arr[r]; // 原数组元素进入结果数组后计数数组对应的计数值需要-1 countArr[bucket]--; &#125; // 将结果拷贝到原始数组 for (int r = 0; r &lt; len; r++) &#123; arr[r] = result[r]; &#125; &#125; &#125; /** * 获取最高位数 */ public static int getMaxDigit(int[] arr) &#123; int maxAbsValue = getMaxAbsValue(arr); return getNumLenght(maxAbsValue); &#125; /** * 获取绝对值的最大值 * @param arr * @return */ public static int getMaxAbsValue(int[] arr) &#123; int maxAbsValue = Math.abs(arr[0]); for (int value : arr) &#123; int absValue = Math.abs(value); if (maxAbsValue &lt; absValue) &#123; maxAbsValue = absValue; &#125; &#125; return maxAbsValue; &#125; /** * 获取数值的长度 * @param num * @return */ public static int getNumLenght(int num) &#123; if (num == 0) &#123; return 1; &#125; int lenght = 0; for (int temp = num; temp != 0; temp /= 10) &#123; lenght++; &#125; return lenght; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"计数排序","slug":"计数排序","date":"2020-03-08T08:27:50.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/03/08/计数排序/","link":"","permalink":"https://zhechu.github.io/2020/03/08/计数排序/","excerpt":"","text":"原理：一种特殊的桶排序算法 平均时间复杂度 额外空间复杂度 稳定性 备注 O(n) O(n) 稳定 数据范围分布均匀且数据规模较小时较好 1 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * 计数排序（假设数组中存储的都是非负整数） * @author lingyuwang * @date 2019-07-13 11:01 */public class Counting &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 100; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); countingSort(arr1); Arrays.sort(arr2); // 检查经计数排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 计数排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 countingSort(arr); // 排序后 printArray(arr); &#125; /** * 计数排序 * @param arr */ public static void countingSort(int[] arr) &#123; int len = arr.length; if (len &lt;= 1) &#123; return; &#125; // 查找数组中数据的范围 int max = arr[0]; for (int i = 1; i &lt; len; ++i) &#123; if (max &lt; arr[i]) &#123; max = arr[i]; &#125; &#125; // 申请一个计数数组，下标大小[0, max] int[] countArr = new int[max + 1]; for (int i = 0; i &lt;= max; ++i) &#123; countArr[i] = 0; &#125; // 计算每个元素的个数，放入计数数组中 for (int i = 0; i &lt; len; ++i) &#123; countArr[arr[i]]++; &#125; // 求小于或等于自身的元素个数并记录到对应的索引位置 for (int i = 1; i &lt;= max; ++i) &#123; countArr[i] = countArr[i-1] + countArr[i]; &#125; int[] result = new int[len]; // 从后往前扫描原数组并将结果记录到结果数组 for (int i = len - 1; i &gt;= 0; --i) &#123; // 计数数组对应的计数值即为元素排序后的位置 int index = countArr[arr[i]] - 1; result[index] = arr[i]; // 原数组元素进入结果数组后计数数组对应的计数值需要-1 countArr[arr[i]]--; &#125; // 将结果拷贝到原始数组 for (int i = 0; i &lt; len; ++i) &#123; arr[i] = result[i]; &#125; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 2 应用示例2.1 学生按成绩排序2.2 订单按金额排序","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"递归","slug":"递归","date":"2020-03-03T14:54:23.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/03/03/递归/","link":"","permalink":"https://zhechu.github.io/2020/03/03/递归/","excerpt":"","text":"递归需满足的条件 一个问题的解可以分解为几个子问题的解 问题的解与分解之后的子问题，除了数据规模不同，求解思路一样 存在递归终止条件 TIPS：解题关键：写出递推公式，找到终止条件 示例有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，计算其有多少种走法 递推公式：f(n) = f(n-1) + f(n-2)终止条件：f(1) = 1, f(2) = 2 递归求解1234567891011121314151617181920212223242526272829303132/** * 有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，计算其有多少种走法 * 递推公式：f(n) = f(n-1) + f(n-2) * 终止条件：f(1) = 1, f(2) = 2 */public class StepWalkMethod &#123; public static void main(String[] args) &#123; int n = 7; int result = method(n); System.out.println(n + \"个台阶一共有\" + result + \"种走法\"); // 21 &#125; /** * 计算台阶走法 * @param n * @return */ public static int method(int n) &#123; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; return method(n - 1) + method(n -2); &#125;&#125; TIPS：体现出回溯法和分治算法 递归求解优化缓存已求解的子结果123456789101112131415161718192021222324252627282930313233343536373839404142/** * 有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，计算其有多少种走法 * 递推公式：f(n) = f(n-1) + f(n-2) * 终止条件：f(1) = 1, f(2) = 2 */public class StepWalkMethod &#123; public static void main(String[] args) &#123; int n = 7; int result = optimizeMethod(n, new HashMap&lt;&gt;()); System.out.println(n + \"个台阶一共有\" + result + \"种走法\"); // 21 &#125; /** * 计算台阶走法（缓存已求解的子结果） * @param n * @return */ public static int optimizeMethod(int n, Map&lt;Integer, Integer&gt; cacheMap) &#123; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; Integer resultTemp = cacheMap.get(n); if (resultTemp != null) &#123; return resultTemp; &#125; int result = method(n - 1) + method(n -2); cacheMap.put(n, result); return result; &#125;&#125; 非递归方法12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 有 n 个台阶，每次可以跨 1 个台阶或者 2 个台阶，计算其有多少种走法 * 递推公式：f(n) = f(n-1) + f(n-2) * 终止条件：f(1) = 1, f(2) = 2 */public class StepWalkMethod &#123; public static void main(String[] args) &#123; int n = 7; int result = nonRecursiveMethod(n); System.out.println(n + \"个台阶一共有\" + result + \"种走法\"); // 21 &#125; /** * 计算台阶走法（非递归） * @param n * @return */ public static int nonRecursiveMethod(int n) &#123; if (n == 1) &#123; return 1; &#125; if (n == 2) &#123; return 2; &#125; int result = 0; int pre = 2; int prepre = 1; for (int i = 3; i &lt;= n; i++) &#123; result = pre + prepre; prepre = pre; pre = result; &#125; return result; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"利用数组实现循环队列","slug":"利用数组实现循环队列","date":"2020-03-02T15:58:11.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2020/03/02/利用数组实现循环队列/","link":"","permalink":"https://zhechu.github.io/2020/03/02/利用数组实现循环队列/","excerpt":"","text":"思路：使用 count 变量统计当前队列元素，简化边界条件判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * 循环队列 */public class LoopQueue&lt;E&gt; &#123; public static void main(String[] args) &#123; int capacity = 5; LoopQueue&lt;String&gt; loopQueue = new LoopQueue&lt;&gt;(capacity); // 入队 System.out.println(loopQueue.enqueue(\"张三\")); // true System.out.println(loopQueue.enqueue(\"李四\")); // true System.out.println(loopQueue.enqueue(\"王五\")); // true System.out.println(loopQueue.enqueue(\"赵六\")); // true System.out.println(loopQueue.enqueue(\"牛七\")); // true System.out.println(loopQueue.enqueue(\"三八\")); // false // 出队 for (int i = 0; i &lt; capacity; i++) &#123; System.out.println(loopQueue.dequeue()); &#125; System.out.println(\"==============================\"); // 入队 System.out.println(loopQueue.enqueue(\"张三\")); // true System.out.println(loopQueue.enqueue(\"李四\")); // true System.out.println(loopQueue.enqueue(\"王五\")); // true System.out.println(loopQueue.enqueue(\"赵六\")); // true System.out.println(loopQueue.enqueue(\"牛七\")); // true System.out.println(loopQueue.enqueue(\"三八\")); // false // 出队 System.out.println(loopQueue.dequeue()); // 张三 // 入队 System.out.println(loopQueue.enqueue(\"洪九\")); // true // 出队 for (int i = 0; i &lt; capacity; i++) &#123; System.out.println(loopQueue.dequeue()); &#125; &#125; /** 数据 */ private Object[] items; /** 容量 */ private int capacity; /** 现有元素个数 */ private int count; /** 头指针 */ private int head; /** 尾指针 */ private int tail; public LoopQueue() &#123; this(10); &#125; public LoopQueue(int capacity) &#123; this.capacity = capacity; items = new Object[capacity]; head = tail = 0; count = 0; &#125; /** * 入队 * @param e * @return */ public boolean enqueue(E e) &#123; if (count == capacity) &#123; return false; &#125; items[tail++] = e; if (tail == capacity) &#123; tail = 0; &#125; count++; return true; &#125; /** * 出队 * @return */ public E dequeue() &#123; if (count == 0) &#123; return null; &#125; E e = (E) items[head++]; if (head == capacity) &#123; head = 0; &#125; count--; return e; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhechu.github.io/tags/数据结构/"},{"name":"队列","slug":"队列","permalink":"https://zhechu.github.io/tags/队列/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"利用栈结构求解表达式","slug":"利用栈结构求解表达式","date":"2020-03-01T13:22:57.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2020/03/01/利用栈结构求解表达式/","link":"","permalink":"https://zhechu.github.io/2020/03/01/利用栈结构求解表达式/","excerpt":"","text":"求解简单的加减乘除四则运算表达式 从左向右遍历表达式 遇到数字，直接压入操作数栈 遇到运算符，则与运算符栈的栈顶元素进行比较 若比运算符栈顶元素的优先级高，则将当前运算符压入栈 若比运算符栈顶元素的优先级低或者相等，则从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数 将取出的操作数和运算符结合进行计算，再把计算完的结果压入操作数栈，然后将还未入栈的运算符回到第3步执行 最后计算还在栈中的操作数即可 如：输入 11+14-26+42/224/2+1232 ，结果为 1497 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * 求解简单的加减乘除四则运算表达式 * 1.从左向右遍历表达式 * 2.遇到数字，直接压入操作数栈 * 3.遇到运算符，则与运算符栈的栈顶元素进行比较 * 4.若比运算符栈顶元素的优先级高，则将当前运算符压入栈 * 5.若比运算符栈顶元素的优先级低或者相等，则从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数 * 6.将取出的操作数和运算符结合进行计算，再把计算完的结果压入操作数栈，然后将还未入栈的运算符回到第3步执行 * 7.最后计算还在栈中的操作数即可 */public class StackExpression &#123; /** * 运算符之间的优先级,其顺序是 #、+、-、*、/，其中大于号表示优先级高， * 小于号表示优先级低，等号表示优先级相同。 * #不参与运算，用作哨兵，简化编程 */ public static final char[][] relation = &#123; &#123;'=','&lt;','&lt;','&lt;','&lt;'&#125;, &#123;'&gt;','=','=','&lt;','&lt;'&#125;, &#123;'&gt;','=','=','&lt;','&lt;'&#125;, &#123;'&gt;','&gt;','&gt;','=','='&#125;, &#123;'&gt;','&gt;','&gt;','=','='&#125; &#125;; /** 连续几个字符是否是数字，用于支持多位数运算 */ public static boolean flag = false; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); while (true) &#123; flag = false; System.out.println(\"请输入要计算的表达式：\"); try &#123; String exp = input.next(); System.out.println(calc(exp)); &#125; catch(ArithmeticException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 解析并运算 * @param exp * @return */ private static int calc(String exp) &#123; // 操作数栈 Stack&lt;Integer&gt; num = new Stack&lt;&gt;(); // 操作符栈 Stack&lt;Character&gt; op = new Stack&lt;&gt;(); // 用作哨兵，简化编程 op.push('#'); int len = exp.length(); for (int i = 0; i &lt; len; i++) &#123; calcDetail(num, op, exp.charAt(i)); &#125; // 最后一个运算符运算 calcAndPushNum(num, op); return num.peek(); &#125; public static void calcDetail(Stack&lt;Integer&gt; num, Stack&lt;Character&gt; op, char ch) &#123; // 操作数 if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; if (flag) &#123; int tmp = num.pop(); num.push(tmp * 10 + Integer.valueOf(String.valueOf(ch))); &#125; else &#123; num.push(Integer.valueOf(String.valueOf(ch))); &#125; flag = true; &#125; // 运算符 else &#123; flag = false; switch (getRelation(ch, op.peek())) &#123; // 当前运算符比栈顶运算符优先级低 case '&lt;': calcAndPushNum(num, op); // 递归回溯计算 calcDetail(num, op, ch); break; // 当前运算符与栈顶运算符优先级相等 case '=': calcAndPushNum(num, op); // 递归回溯计算 calcDetail(num, op, ch); break; // 当前运算符比栈顶运算符优先级高 case '&gt;': op.push(ch); break; default: throw new ArithmeticException(\"输入的表达式格式错误\"); &#125; &#125; &#125; /** * 计算和计算结果入栈 * @param num * @param op */ private static void calcAndPushNum(Stack&lt;Integer&gt; num, Stack&lt;Character&gt; op) &#123; int num2 = num.pop(); int num1 = num.pop(); num.push(operate(num1, op.pop(), num2)); &#125; /** * 获取运算符优先关系 * @param ch1 运算符符1 * @param ch2 运算符符2 * @return */ private static char getRelation(char ch1, char ch2) &#123; return relation[getIndex(ch1)][getIndex(ch2)]; &#125; /** * 获取运算符索引 * @param ch * @return */ private static int getIndex(char ch) &#123; int index = -1; switch (ch) &#123; case '#': index = 0; break; case '+': index = 1; break; case '-': index = 2; break; case '*': index = 3; break; case '/': index = 4; break; &#125; return index; &#125; /** * 运算 * @param num1 操作数1 * @param ch 运算符 * @param num2 操作数2 * @return */ private static int operate(int num1, char ch, int num2) &#123; int result = 0; switch (ch) &#123; case '+': result = num1 + num2; break; case '-': result = num1 - num2; break; case '*': result = num1 * num2; break; case '/': result = num1 / num2; break; &#125; return result; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhechu.github.io/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"链表环检测","slug":"链表环检测","date":"2020-02-29T14:33:34.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/02/29/链表环检测/","link":"","permalink":"https://zhechu.github.io/2020/02/29/链表环检测/","excerpt":"","text":"思路：定义两指针，慢指针步长为1，快指针步长为2，若两指针相遇，则表示存在环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 链表环检测：定义两指针，慢指针步长为1，快指针步长为2，若两指针相遇，则表示存在环 * * @author lingyuwang * @date 2020-02-29 22:21 * @since 1.0.4 **/public class CycleList &#123; public static void main(String[] args) &#123; System.out.println(\"是否存在环:\" + hascycle(test1())); // true System.out.println(\"是否存在环:\" + hascycle(test2())); // false &#125; /** * 是否存在环 * @param head * @return */ public static boolean hascycle(Node head)&#123; // 快慢指针 Node slow, fast; slow = fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (fast == slow) &#123; return true; &#125; &#125; return false; &#125; /** * 节点 */ static class Node &#123; /** 节点数据 */ int data; /** 下一个节点指针 */ Node next = null; Node(int data) &#123; this.data = data; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; @Override public String toString() &#123; return \"ListNode&#123;\" + \"val=\" + data + \", next=\" + next + '&#125;'; &#125; &#125; public static Node test1() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node4 = new Node(4); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node7.setNext(node3); node6.setNext(node7); node5.setNext(node6); node4.setNext(node5); node3.setNext(node4); node2.setNext(node3); node1.setNext(node2); return node1; &#125; public static Node test2() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node3.setNext(node5); node2.setNext(node3); node1.setNext(node2); return node1; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhechu.github.io/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"利用哨兵优化循环判断","slug":"利用哨兵优化循环判断","date":"2020-02-28T15:39:12.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2020/02/28/利用哨兵优化循环判断/","link":"","permalink":"https://zhechu.github.io/2020/02/28/利用哨兵优化循环判断/","excerpt":"","text":"在大数据量时，可以使用哨兵优化循环判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 利用哨兵优化循环判断 * **/public class LoopFind &#123; public static void main(String[] args) &#123; int[] array = &#123;4, 2, 3, 5, 9, 6&#125;; int result1 = find(array, 9); System.out.println(result1); // 4 int result2 = find(array, 3); System.out.println(result2); // 2 System.out.println(\"=======================================\"); int result3 = findByGuard(array, 9); System.out.println(result3); // 4 int result4 = findByGuard(array, 3); System.out.println(result4); // 2 &#125; /** * 在数组array中，查找key，返回key所在的位置 * @param array * @param key * @return */ public static int find(int[] array, int key) &#123; int len; // 边界条件处理，如果array为空，或者len&lt;=0，说明数组中没有数据，就不用while循环比较了 if (array == null || (len = array.length) &lt;= 0) &#123; return -1; &#125; int i = 0; // 这里有两个比较操作：i&lt;len 和 array[i]==key. while (i &lt; len) &#123; if (array[i] == key) &#123; return i; &#125; ++i; &#125; return -1; &#125; /** * 在数组array中，查找key，返回key所在的位置（使用哨兵优化） * @param array * @param key * @return */ public static int findByGuard(int[] array, int key) &#123; int len; // 边界条件处理，如果array为空，或者len&lt;=0，说明数组中没有数据，就不用while循环比较了 if (array == null || (len = array.length) &lt;= 0) &#123; return -1; &#125; // 这里因为要将array[len-1]的值替换成key，所以要特殊处理这个值 if (array[len-1] == key) &#123; return len - 1; &#125; // 把array[len-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。 // 之所以这样做的目的是：希望findByGuard()代码不要改变array数组中的内容 int tmp = array[len - 1]; // 把key的值放到array[len-1]中 array[len - 1] = key; int i = 0; // while 循环比起代码一，少了i&lt;len这个比较操作 while (array[i] != key) &#123; ++i; &#125; // 恢复array[len-1]原来的值 array[len-1] = tmp; if (i == len - 1) &#123; // 如果i == len-1说明，在0...len-2之间都没有key，所以返回-1 return -1; &#125; // 否则，返回i，就是等于key值的元素的下标 return i; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zhechu.github.io/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"链表回文检测","slug":"链表回文检测","date":"2020-02-27T15:40:21.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/02/27/链表回文检测/","link":"","permalink":"https://zhechu.github.io/2020/02/27/链表回文检测/","excerpt":"","text":"1 会改变原结构，时间复杂度O(n)，空间复杂度O(1)思路 将前半部分翻转并找到中点 分两指针以中间节点为中心分别向前和向后移动 依次比较两指针的节点是否相等，若有节点不等，则为非回文链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187/** * 判断链表是否为回文链表（会改变原结构，时间复杂度O(n)，空间复杂度O(1)） * * 1.将前半部分翻转并找到中点 * 2.分两指针以中间节点为中心分别向前和向后移动 * 3.依次比较两指针的节点是否相等，若有节点不等，则为非回文链 */public class PalindromeListInPlace &#123; public static void main(String[] args) &#123; System.out.println(\"是否为回文链表:\" + isPalindrome(test1())); // true System.out.println(\"是否为回文链表:\" + isPalindrome(test2())); // true System.out.println(\"是否为回文链表:\" + isPalindrome(test3())); // false System.out.println(\"是否为回文链表:\" + isPalindrome(test4())); // false System.out.println(\"是否为回文链表:\" + isPalindrome(test5())); // false &#125; public static boolean isPalindrome(Node head) &#123; if (head == null || head.next == null) &#123; return true; &#125; if (head.next.next == null) &#123; return head.data == head.next.data; &#125; // pre 前一个节点 Node prepre = null; // 慢指针前一个节点 Node pre = head; // 慢指针 Node slow = pre.next; // 快指针 Node fast = pre.next.next; // 慢指针前一个节点翻转 pre.next = prepre; // 找到中间节点 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; prepre = pre; pre = slow; slow = slow.next; fast = fast.next.next; pre.next = prepre; &#125; // 链表总节点数为偶数 if (fast.next != null) &#123; // 后半部分头指针 fast = slow.next; // 前半部分头指针，需做最后一个翻转（此时原半部分队列已翻转） slow.next = pre; &#125; // 链表总节点数为奇数 else &#123; // 后半部分头指针 fast = slow.next; // 前半部分头指针（此时原半部分队列已翻转） slow = pre; &#125; // 头尾两部分节点依次比较 while (slow != null) &#123; if (slow.data != fast.data) &#123; return false; &#125; slow = slow.next; fast = fast.next; &#125; return true; &#125; /** * 节点 */ static class Node &#123; /** 节点数据 */ int data; /** 下一个节点指针 */ Node next = null; Node(int data) &#123; this.data = data; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; @Override public String toString() &#123; return \"ListNode&#123;\" + \"val=\" + data + \", next=\" + next + '&#125;'; &#125; &#125; public static Node test1() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node4 = new Node(4); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node4.setNext(node5); node3.setNext(node4); node2.setNext(node3); node1.setNext(node2); return node1; &#125; public static Node test2() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node3.setNext(node5); node2.setNext(node3); node1.setNext(node2); return node1; &#125; public static Node test3() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node2 = new Node(1); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node2.setNext(node5); node1.setNext(node2); return node1; &#125; public static Node test4() &#123; Node node7 = new Node(1); Node node6 = new Node(1); Node node5 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node2.setNext(node5); node1.setNext(node2); return node1; &#125; public static Node test5() &#123; Node node7 = new Node(2); Node node6 = new Node(1); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node2.setNext(node6); node1.setNext(node2); return node1; &#125;&#125; 2 不会改变原结构，时间复杂度O(n)，空间复杂度O(n)思路 前半部分缓存在栈中 分两指针以中间节点为中心分别向前（栈）和向后（原链表）移动 依次比较两指针的节点是否相等，若有节点不等，则为非回文链 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210import java.util.Stack;/** * 判断链表是否为回文链表（不会改变原结构，时间复杂度O(n)，空间复杂度O(n)） * * 1.前半部分缓存在栈中 * 2.分两指针以中间节点为中心分别向前（栈）和向后（原链表）移动 * 3.依次比较两指针的节点是否相等，若有节点不等，则为非回文链 */public class PalindromeListInCache &#123; public static void main(String[] args) &#123; Node head = test1(); System.out.println(\"是否为回文链表:\" + isPalindrome(head)); // true printList(head); head = test2(); System.out.println(\"是否为回文链表:\" + isPalindrome(head)); // true printList(head); head = test3(); System.out.println(\"是否为回文链表:\" + isPalindrome(head)); // false printList(head); head = test4(); System.out.println(\"是否为回文链表:\" + isPalindrome(head)); // false printList(head); head = test5(); System.out.println(\"是否为回文链表:\" + isPalindrome(head)); // false printList(head); &#125; public static boolean isPalindrome(Node head) &#123; if (head == null || head.next == null) &#123; return true; &#125; if (head.next.next == null) &#123; return head.data == head.next.data; &#125; // 栈，用于存储队列前半部分节点 Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(head); // 慢指针 Node slow = head.next; // 快指针 Node fast = head.next.next; // 找到中间节点 while (fast.next != null &amp;&amp; fast.next.next != null) &#123; stack.push(slow); slow = slow.next; fast = fast.next.next; &#125; // 链表总节点数为偶数 if (fast.next != null) &#123; // 后半部分头指针 fast = slow.next; // 前半部分头指针为当前 slow 指针 &#125; // 链表总节点数为奇数 else &#123; // 后半部分头指针 fast = slow.next; // 前半部分头指针（此时原半部分队列已翻转） slow = stack.pop(); &#125; // 头尾两部分节点依次比较 while (true) &#123; if (slow.data != fast.data) &#123; return false; &#125; if (stack.empty()) &#123; break; &#125; slow = stack.pop(); fast = fast.next; &#125; return true; &#125; /** * 节点 */ static class Node &#123; /** 节点数据 */ int data; /** 下一个节点指针 */ Node next = null; Node(int data) &#123; this.data = data; &#125; public int getData() &#123; return data; &#125; public void setData(int data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125; @Override public String toString() &#123; return \"ListNode&#123;\" + \"val=\" + data + \", next=\" + next + '&#125;'; &#125; &#125; public static Node test1() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node4 = new Node(4); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node4.setNext(node5); node3.setNext(node4); node2.setNext(node3); node1.setNext(node2); return node1; &#125; public static Node test2() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node3 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node3.setNext(node5); node2.setNext(node3); node1.setNext(node2); return node1; &#125; public static Node test3() &#123; Node node7 = new Node(1); Node node6 = new Node(2); Node node5 = new Node(3); Node node2 = new Node(1); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node2.setNext(node5); node1.setNext(node2); return node1; &#125; public static Node test4() &#123; Node node7 = new Node(1); Node node6 = new Node(1); Node node5 = new Node(3); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node5.setNext(node6); node2.setNext(node5); node1.setNext(node2); return node1; &#125; public static Node test5() &#123; Node node7 = new Node(2); Node node6 = new Node(1); Node node2 = new Node(2); Node node1 = new Node(1); node6.setNext(node7); node2.setNext(node6); node1.setNext(node2); return node1; &#125; public static void printList(Node head) &#123; System.out.println(\"=============================================\"); while (head != null) &#123; System.out.println(head); head = head.next; &#125; System.out.println(\"=============================================\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zhechu.github.io/tags/数据结构/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"实现无锁非阻塞队列","slug":"实现无锁非阻塞队列","date":"2020-02-23T14:59:05.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2020/02/23/实现无锁非阻塞队列/","link":"","permalink":"https://zhechu.github.io/2020/02/23/实现无锁非阻塞队列/","excerpt":"","text":"原理：基于循环队列和Java 的 CAS 机制实现 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/queue/LockFreeQueue.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 无锁非阻塞队列 */public class LockFreeQueue &#123; public static void main(String[] args) throws InterruptedException &#123; LockFreeQueue lockFreeQueue = new LockFreeQueue(15); // 生产者 Thread product1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; lockFreeQueue.add(i); &#125; &#125;); Thread product2 = new Thread(() -&gt; &#123; for (int i = 100; i &lt; 200; i++) &#123; lockFreeQueue.add(i); &#125; &#125;); Thread product3 = new Thread(() -&gt; &#123; for (int i = 200; i &lt; 300; i++) &#123; lockFreeQueue.add(i); &#125; &#125;); // 消费者 Thread customer1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; lockFreeQueue.poll(); &#125; &#125;); Thread customer2 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; lockFreeQueue.poll(); &#125; &#125;); Thread customer3 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 100; i++) &#123; lockFreeQueue.poll(); &#125; &#125;); product1.start(); product2.start(); product3.start(); customer1.start(); customer2.start(); customer3.start(); TimeUnit.SECONDS.sleep(5); lockFreeQueue.print(); &#125; /** 存储数据 */ private AtomicReferenceArray&lt;Integer&gt; atomicReferenceData; /** 数组长度 */ private int len; /** 代表为空，没有元素 */ private static final Integer EMPTY = null; /** 头指针 */ AtomicInteger head; /** 尾指针 */ AtomicInteger tail; public LockFreeQueue(int size) &#123; // 数组需要多出一个空元素，方便判断队列是否已满 atomicReferenceData = new AtomicReferenceArray(new Integer[size + 1]); len = atomicReferenceData.length(); head = new AtomicInteger(0); tail = new AtomicInteger(0); &#125; /** * 入队 * @param element * @return */ public boolean add(Integer element) &#123; int index; do &#123; index = (tail.get() + 1) % len; if (index == head.get() % len) &#123; System.out.println(\"当前队列已满,\" + element + \"无法入队!\"); return false; &#125; &#125; while (!atomicReferenceData.compareAndSet(index, EMPTY, element)); // 移动尾指针 tail.incrementAndGet(); System.out.println(element + \"入队成功!\"); return true; &#125; /** * 出队 * @return */ public Integer poll() &#123; int index; Integer element; do &#123; if (head.get() == tail.get()) &#123; System.out.println(\"当前队列为空!\"); return null; &#125; index = (head.get() + 1) % len; element = atomicReferenceData.get(index); &#125; while (element == null || !atomicReferenceData.compareAndSet(index, element, EMPTY)); // 移动头指针 head.incrementAndGet(); System.out.println(element + \"出队成功!\"); return element; &#125; /** * 打印队列存储状态 * @return */ public void print() &#123; StringBuffer buffer = new StringBuffer(\"[\"); for (int i = 0; i &lt; len ; i++)&#123; if (i == head.get() || atomicReferenceData.get(i) == null)&#123; continue; &#125; buffer.append(atomicReferenceData.get(i) + \",\"); &#125; buffer.deleteCharAt(buffer.length() - 1); buffer.append(\"]\"); System.out.println(\"队列内容:\" + buffer); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://zhechu.github.io/tags/队列/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"堆排序","slug":"堆排序","date":"2020-02-23T04:13:59.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2020/02/23/堆排序/","link":"","permalink":"https://zhechu.github.io/2020/02/23/堆排序/","excerpt":"","text":"原理：一种利用堆的概念来排序的选择排序。先建堆，然后最后一个元素与堆顶交换，并继续堆化，直到堆中只剩一个元素 平均时间复杂度 额外空间复杂度 稳定性 备注 O(nlogn) O(1) 不稳定 n 大时较好 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Heap.java 堆排序比快速排序性能差 堆排序数据访问的方式没有快速排序友好。不是按数组顺序访问节点，无法充分利用CPU缓存 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/** * 堆排序（大根堆） * @author lingyuwang * @date 2019-07-13 11:01 */public class Heap &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); heapSort(arr1); Arrays.sort(arr2); // 检查经冒泡排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 堆排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 heapSort(arr); // 排序后 printArray(arr); &#125; /** * 大根堆排序 * @param arr */ public static void heapSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; int len = arr.length; // 建立大根堆 buildMaxHeap(arr, len); // 最后一个元素与堆顶交换，并堆化，直到堆中只剩一个元素（i == 0） for (int i = len - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); // 堆元素-1 len--; heapify(arr, 0, len); &#125; &#125; /** * 建立大根堆 * @param arr * @param len */ public static void buildMaxHeap(int[] arr, int len) &#123; // 自最后一个非叶子节点开始堆化 for (int i = (len - 2) &gt;&gt; 1; i &gt;= 0; i--) &#123; heapify(arr, i, len); &#125; &#125; /** * 自上往下堆化 * @param arr * @param index * @param len */ public static void heapify(int[] arr, int index, int len) &#123; // 左节点指针 int left = (index &lt;&lt; 1) + 1; // 右节点指针 int right = (index &lt;&lt; 1) + 2; // 最大节点指针 int largest = index; // 检查左节点是否大于父节点 if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; // 检查右节点是否大于最大节点 if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; // 若最大节点不是父节点，则交换并继续调整 if (largest != index) &#123; swap(arr, index, largest); heapify(arr, largest, len); &#125; &#125; /** * 两数交换 * @param arr * @param i * @param j */ public static void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"快速排序","slug":"快速排序","date":"2020-02-23T01:52:31.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2020/02/23/快速排序/","link":"","permalink":"https://zhechu.github.io/2020/02/23/快速排序/","excerpt":"","text":"原理：先从数列中取出一个数作为基准数，分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边，再对左右区间重复第二步，直到各区间只有一个数 平均时间复杂度 额外空间复杂度 稳定性 备注 O(nlogn) O(1) 不稳定 n 大时较好 1 示例代码https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Quick.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176/** * 快速排序 * @author lingyuwang * @date 2019-07-13 10:55 */public class Quick &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); quickSort(arr1); Arrays.sort(arr2); // 检查经冒泡排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 快速排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 quickSort(arr); // 排序后 printArray(arr); &#125; /** * 快速排序主入口 * @param arr */ public static void quickSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; quickSort(arr, 0, arr.length - 1); &#125; /** * 快速排序算法骨架方法，用于递归 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) &#123; if (left &gt;= right)&#123; return; &#125; int p = partition(arr, left, right); quickSort(arr, left, p-1); quickSort(arr, p + 1, right); &#125; /** * 以最后一个元素作为分区点进行分区 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) &#123; // 记录分区指针所在的位置 int p = left; for (int j = left; j &lt; right; j++) &#123; if (arr[j] &lt; arr[right]) &#123; if (p != j) &#123; swap(arr, p, j); &#125; p++; &#125; &#125; // 此时，p 要么是与 right 相等（原数组已有序），要么是右边第一个比 right 元素值大的数的指针 if (p != right) &#123; swap(arr, p, right); &#125; return p; &#125; /** * 两数交换 * @param arr * @param i * @param j */ public static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 2 应用示例2.1 荷兰国旗问题给定一个数组arr和一个数num，请将小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边，并返回等于num区域的索引区间 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Quick.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 快速排序使用示例：荷兰国旗问题，给定一个数组arr和一个数num，请将小于num的数放在数组的左边， * 等于num的数放在数组的中间，大于num的数放在数组的右边，并返回等于num区域的索引区间 * @author lingyuwang * @date 2019-07-13 10:59 */public class QuickHollandFlag &#123; public static void main(String[] args) &#123; // 生成数组 int[] test = generateArray(); printArray(test); // num 必须在数组中 int[] res = partition(test, 0, test.length - 1, 1); printArray(test); // 返回等于区域的索引区间 System.out.println(res[0]); System.out.println(res[1]); &#125; /** * 分区 * @param arr * @param left * @param right * @param num * @return */ public static int[] partition(int[] arr, int left, int right, int num) &#123; // 分区左指针 int pLeft = left - 1; // 分区右指针 int pRight = right + 1; // 当前指针 int current = left; while (current &lt; pRight) &#123; // current 应进入左分区（小于num） if (arr[current] &lt; num) &#123; pLeft++; swap(arr, pLeft, current); current++; &#125; // current 应进入右分区（大于num） else if (arr[current] &gt; num) &#123; pRight--; swap(arr, pRight, current); &#125; // current 应进入中间分区 else &#123; current++; &#125; &#125; return new int[] &#123; pLeft + 1, pRight - 1 &#125;; &#125; /** * 两数交换 * @param arr * @param i * @param j */ public static void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 生成数组 * @return */ public static int[] generateArray() &#123; int[] arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 3); &#125; return arr; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 2.2 求解第 k 大元素时间复杂度：O(n) 空间复杂度：O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * 快速排序（求解第 k 大元素） * @author lingyuwang * @date 2019-07-13 10:55 */public class QuickTopK &#123; public static void main(String[] args) &#123; // 查找第 3 大的数 int k = 3; // 对数器 int testTime = 100; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); int resultIndex = findByQuickSort(arr1, k); Arrays.sort(arr2); arr2 = reserve(arr2); // 检查结果是否相等 if (arr1.length &gt;= k &amp;&amp; (resultIndex &lt; 0 || arr1[resultIndex] != arr2[resultIndex])) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); int[] arr = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr); Arrays.sort(arr2); arr2 = reserve(arr2); // 查找前 printArray(arr); // 排序后 printArray(arr2); // 开始查找 int result = findByQuickSort(arr, k); if (result &gt;= 0) &#123; System.out.println(\"第\" + k + \"大的元素是：\" + arr[result] + \", 索引是：\" + result); &#125; else &#123; System.out.println(\"不存在第\" + k + \"大的元素\"); &#125; &#125; /** * 通过快速排序查找 * @param arr */ public static int findByQuickSort(int[] arr, int k) &#123; if (arr == null || k &lt; 1) &#123; return -1; &#125; if (arr.length == 1) &#123; return k == 1 ? 0 : -1; &#125; if (arr.length &lt; k) &#123; return -1; &#125; return findByQuickSort(arr, k, 0, arr.length - 1); &#125; /** * 快速排序算法骨架方法，用于递归 * @param arr * @param left * @param right */ public static int findByQuickSort(int[] arr, int k, int left, int right) &#123; if (left == right) &#123; return left; &#125; int p = partition(arr, left, right); // 目标已查到 if (p == k - 1) &#123; return p; &#125; // 目标在左边 if (p &gt; k - 1) &#123; return findByQuickSort(arr, k, left, p-1); &#125; // 目标在右边 return findByQuickSort(arr, k, p + 1, right); &#125; /** * 以最后一个元素作为分区点进行分区 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) &#123; // 记录分区指针所在的位置 int p = left; for (int j = left; j &lt; right; j++) &#123; if (arr[j] &gt; arr[right]) &#123; swap(arr, p, j); p++; &#125; &#125; // 此时，p 要么是与 right 相等（原数组已有序），要么是右边第一个比 right 元素值小的数的指针 swap(arr, p, right); return p; &#125; /** * 两数交换 * @param arr * @param i * @param j */ public static void swap(int[] arr, int i, int j) &#123; if (i == j) &#123; return; &#125; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 数组反转 * @param arr * @return */ public static int[] reserve(int[] arr)&#123; int[] temp = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++)&#123; temp[i] = arr[arr.length - i - 1]; &#125; return temp ; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"归并排序","slug":"归并排序","date":"2020-02-23T01:35:36.000Z","updated":"2020-11-03T13:04:34.286Z","comments":false,"path":"2020/02/23/归并排序/","link":"","permalink":"https://zhechu.github.io/2020/02/23/归并排序/","excerpt":"","text":"原理：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序 平均时间复杂度 额外空间复杂度 稳定性 备注 O(nlogn) O(n) 稳定 n 大时较好 1 示例代码https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Merge.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/** * 归并排序 * @author lingyuwang * @date 2019-07-13 10:48 */public class Merge &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); mergeSort(arr1); Arrays.sort(arr2); // 检查经冒泡排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 归并排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 mergeSort(arr); // 排序后 printArray(arr); &#125; /** * 归并排序主入口 * @param arr */ public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1); &#125; /** * 归并排序算法骨架方法，用于递归 * @param arr * @param left * @param right */ public static void mergeSort(int[] arr, int left, int right) &#123; // 序列中只有一个元素，表示默认已排好序，不需处理，直接返回 if (left == right) &#123; return; &#125; // 使用加减法和位运算以避免乘除法运算，提高效率 int mid = left + ((right - left) &gt;&gt; 1); // 左边序列排序 mergeSort(arr, left, mid); // 右边序列排序 mergeSort(arr, mid + 1, right); // 两序列归并 merge(arr, left, mid, right); &#125; /** * 合并局部有序的两段序列 * @param arr * @param left * @param mid * @param right */ public static void merge(int[] arr, int left, int mid, int right) &#123; // 两序列合并后的辅助数组 int[] help = new int[right - left + 1]; int i = 0; // 左序列当前指针 int p1 = left; // 右序列当前指针 int p2 = mid + 1; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; // 若左边序列当前指针的值比右序列当前指针的值小，则前者进入辅助数组，反之则反 help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; &#125; // 检查左边序列是否还有元素未进入辅助数组 while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; // 检查右边序列是否还有元素未进入辅助数组 while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; // 将辅助数组整理到原数组 for (i = 0; i &lt; help.length; i++) &#123; arr[left + i] = help[i]; &#125; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 2 哨兵优化示例使用哨兵减少合并时的比较次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/** * 归并排序（使用哨兵优化） * @author lingyuwang * @date 2019-07-13 10:48 */public class MergeWithSentinal &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); mergeSort(arr1); Arrays.sort(arr2); // 检查经冒泡排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 归并排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 mergeSort(arr); // 排序后 printArray(arr); &#125; /** * 归并排序主入口 * @param arr */ public static void mergeSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; mergeSort(arr, 0, arr.length - 1); &#125; /** * 归并排序算法骨架方法，用于递归 * @param arr * @param left * @param right */ public static void mergeSort(int[] arr, int left, int right) &#123; // 序列中只有一个元素，表示默认已排好序，不需处理，直接返回 if (left == right) &#123; return; &#125; // 使用加减法和位运算以避免乘除法运算，提高效率 int mid = left + ((right - left) &gt;&gt; 1); // 左边序列排序 mergeSort(arr, left, mid); // 右边序列排序 mergeSort(arr, mid + 1, right); // 两序列归并 mergeWithSentinal(arr, left, mid, right); &#125; /** * 合并局部有序的两段序列（使用哨兵优化） * @param arr * @param left * @param mid * @param right */ public static void mergeWithSentinal(int[] arr, int left, int mid, int right) &#123; int leftLen = mid - left + 1; int rightLen = right - mid; int[] leftTemp = new int[leftLen + 1]; int[] rightTemp = new int[rightLen + 1]; // 左部分 int i = 0; while (i &lt; leftLen) &#123; leftTemp[i] = arr[left + i++]; &#125; // 右部分 int j = 0; while (j &lt; rightLen) &#123; rightTemp[j] = arr[mid + 1 + j++]; &#125; // 使用哨兵减少比较次数 leftTemp[leftLen] = Integer.MAX_VALUE; rightTemp[rightLen] = Integer.MAX_VALUE; // 比较大小，并把有序数据放回原数组 int k = left; i = j = 0; while (k &lt;= right) &#123; arr[k++] = leftTemp[i] &lt; rightTemp[j] ? leftTemp[i++] : rightTemp[j++]; &#125; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125; 3 应用示例3.1 求数组的小和在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/MergeArraySmallSum.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/** * 归并排序使用示例：在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。 求一个数组 的小和 * @author lingyuwang * @date 2019-07-13 10:51 */public class MergeArraySmallSum &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); if (smallSum(arr1) != comparator(arr2)) &#123; succeed = false; printArray(arr1); printArray(arr2); break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); &#125; /** * 求数组的小和 * @param arr * @return */ public static int smallSum(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; return mergeSort(arr, 0, arr.length - 1); &#125; /** * 归并排序 * @param arr * @param left * @param right * @return */ public static int mergeSort(int[] arr, int left, int right) &#123; // 序列中只有一个元素，表示默认已排好序，不需处理，直接返回 if (left == right) &#123; return 0; &#125; // 结果 int res = 0; // 使用加减法和位运算以避免乘除法运算，提高效率 int mid = left + ((right - left) &gt;&gt; 1); // 左边序列排序 res += mergeSort(arr, left, mid); // 右边序列排序 res += mergeSort(arr, mid + 1, right); // 两序列归并 res += merge(arr, left, mid, right); return res; &#125; /** * 归并 * @param arr * @param left * @param mid * @param right * @return */ public static int merge(int[] arr, int left, int mid, int right) &#123; // 两序列合并后的辅助数组 int[] help = new int[right - left + 1]; int i = 0; // 左序列当前指针 int p1 = left; // 右序列当前指针 int p2 = mid + 1; // 记录结果 int res = 0; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; // 若左边序列当前指针的值比右序列当前指针的值小，则前者进入辅助数组，反之则反 if (arr[p1] &lt; arr[p2]) &#123; // 右边序列所有元素都比 p1 指针的元素大，所以都需+1（用乘法实现） res += (right - p2 + 1) * arr[p1]; help[i++] = arr[p1++]; &#125; else &#123; help[i++] = arr[p2++]; &#125; &#125; // 检查左边序列是否还有元素未进入辅助数组 while (p1 &lt;= mid) &#123; help[i++] = arr[p1++]; &#125; // 检查右边序列是否还有元素未进入辅助数组 while (p2 &lt;= right) &#123; help[i++] = arr[p2++]; &#125; // 将辅助数组整理到原数组 for (i = 0; i &lt; help.length; i++) &#123; arr[left + i] = help[i]; &#125; return res; &#125; /** * 对数器 * @param arr * @return */ public static int comparator(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return 0; &#125; int res = 0; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; res += arr[j] &lt; arr[i] ? arr[j] : 0; &#125; &#125; return res; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"插入排序","slug":"插入排序","date":"2020-02-22T14:35:10.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2020/02/22/插入排序/","link":"","permalink":"https://zhechu.github.io/2020/02/22/插入排序/","excerpt":"","text":"原理：假设数列第一个元素为已排序数列，剩余数列为未排序，则将待排序元素依次插入到已排序的数列中，每次插入都必须保证数列是有序的，即通过比较和移动有序数列中的元素，将元素插入到合适的位置。以此类推，直到所有元素排好序 平均时间复杂度 额外空间复杂度 稳定性 备注 O(n^2) O(1) 稳定 大部分已排序时较好 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Insertion.java 12345678910111213141516171819202122232425262728293031323334/** * 插入排序 * @author lingyuwang * @date 2019-07-13 10:47 */public class Insert &#123; public static void main(String[] args) &#123; // 直接插入排序 int[] array = &#123;49,38,65,97,76,13,27,49&#125;; array = insertionSort(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125; public static int[] insertionSort(int[] array)&#123; int len = array.length; // 假设第1个元素已排好序，从第2个元素开始 for (int i = 1; i &lt; len; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (array[j] &lt; array[j - 1]) &#123; array[j - 1] = array[j - 1] ^ array[j]; array[j] = array[j - 1] ^ array[j]; array[j - 1] = array[j - 1] ^ array[j]; &#125; else &#123; break; &#125; &#125; &#125; return array; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"选择排序","slug":"选择排序","date":"2020-02-22T14:19:14.000Z","updated":"2020-11-03T13:04:34.290Z","comments":false,"path":"2020/02/22/选择排序/","link":"","permalink":"https://zhechu.github.io/2020/02/22/选择排序/","excerpt":"","text":"原理：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零 平均时间复杂度 额外空间复杂度 稳定性 备注 O(n^2) O(1) 不稳定 n 小时较好 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Select.java 12345678910111213141516171819202122232425262728293031323334353637/** * 选择排序 * @author lingyuwang * @date 2019-07-13 10:46 */public class Select &#123; public static void main(String[] args) &#123; // 选择排序 int[] array = &#123;49,38,65,97,76,13,27,49&#125;; selectionSort(array); for (int i = 0; i &lt; array.length; i++) &#123; System.out.println(array[i]); &#125; &#125; public static void selectionSort(int[] array) &#123; int minIndex = 0; int len = array.length; for (int i = 0; i &lt; len - 1; i++) &#123; // 无序区的最小数据数组下标 minIndex = i; for (int j = i + 1; j &lt; len; j++) &#123; // 在无序区中找到最小数据并保存其数组下标 if (array[j] &lt; array[minIndex]) minIndex = j; &#125; // 若最小数不在正确位置，则交换 if (minIndex != i) &#123; array[i] = array[i] ^ array[minIndex]; array[minIndex] = array[i] ^ array[minIndex]; array[i] = array[i] ^ array[minIndex]; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2020-02-22T13:46:49.000Z","updated":"2020-11-03T13:04:34.279Z","comments":false,"path":"2020/02/22/冒泡排序/","link":"","permalink":"https://zhechu.github.io/2020/02/22/冒泡排序/","excerpt":"","text":"原理：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成 平均时间复杂度 额外空间复杂度 稳定性 备注 O(n^2) O(1) 稳定 n 小时较好 示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/sort/Bubble.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/** * 冒泡排序 * @author lingyuwang * @date 2019-07-13 10:42 */public class Bubble &#123; public static void main(String[] args) &#123; // 对数器 int testTime = 1; int maxSize = 100; int maxValue = 100; boolean succeed = true; for (int i = 0; i &lt; testTime; i++) &#123; int[] arr1 = generateRandomArray(maxSize, maxValue); int[] arr2 = copyArray(arr1); bubbleSort(arr1); Arrays.sort(arr2); // 检查经冒泡排序的数组是否已有序，若有序，则检查成功 if (!isEqual(arr1, arr2)) &#123; succeed = false; break; &#125; &#125; System.out.println(succeed ? \"检查成功\" : \"检查失败\"); // 冒泡排序 int[] arr = generateRandomArray(maxSize, maxValue); // 排序前 printArray(arr); // 开始排序 bubbleSort(arr); // 排序后 printArray(arr); &#125; /** * 冒泡排序 * @param arr */ public static void bubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) &#123; return; &#125; for (int e = arr.length - 1; e &gt; 0; e--) &#123; for (int i = 0; i &lt; e; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; swap(arr, i, i + 1); &#125; &#125; &#125; &#125; /** * 两数交换 * @param arr * @param i * @param j */ public static void swap(int[] arr, int i, int j) &#123; arr[i] = arr[i] ^ arr[j]; arr[j] = arr[i] ^ arr[j]; arr[i] = arr[i] ^ arr[j]; &#125; /** * 随机生成数组 * @param maxSize * @param maxValue * @return */ public static int[] generateRandomArray(int maxSize, int maxValue) &#123; int[] arr = new int[(int) ((maxSize + 1) * Math.random())]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random()); &#125; return arr; &#125; /** * 拷贝数组 * @param arr * @return */ public static int[] copyArray(int[] arr) &#123; if (arr == null) &#123; return null; &#125; int[] res = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; res[i] = arr[i]; &#125; return res; &#125; /** * 两数组比较 * @param arr1 * @param arr2 * @return */ public static boolean isEqual(int[] arr1, int[] arr2) &#123; if ((arr1 == null &amp;&amp; arr2 != null) || (arr1 != null &amp;&amp; arr2 == null)) &#123; return false; &#125; if (arr1 == null &amp;&amp; arr2 == null) &#123; return true; &#125; if (arr1.length != arr2.length) &#123; return false; &#125; for (int i = 0; i &lt; arr1.length; i++) &#123; if (arr1[i] != arr2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * 数组打印 * @param arr */ public static void printArray(int[] arr) &#123; if (arr == null) &#123; return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + \" \"); &#125; System.out.println(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"除2高效算法","slug":"除2高效算法","date":"2020-02-22T13:25:21.000Z","updated":"2020-11-03T13:04:34.291Z","comments":false,"path":"2020/02/22/除2高效算法/","link":"","permalink":"https://zhechu.github.io/2020/02/22/除2高效算法/","excerpt":"","text":"示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/BitOperation.java 恰当地使用位运算，可以提高程序运行效率。 1234567891011121314151617181920212223242526272829303132333435/** * 位运算 * @author lingyuwang * @date 2019-07-13 9:58 */public class BitOperation &#123; public static void main(String[] args)&#123; int a = 2; int b = 5;// sumAndDivide2(a, b); sumAndDivide2Enhance(a, b); &#125; /** * 求和再除以2：先加后移 * @param a * @param b */ public static void sumAndDivide2(int a, int b) &#123; int result = (a + b) &gt;&gt; 1; System.out.println(result); // 3 &#125; /** * 求和再除以2：先减后移再减，安全，保证不会溢出 * @param a * @param b */ public static void sumAndDivide2Enhance(int a, int b) &#123; int result = a + ((b - a) &gt;&gt; 1); System.out.println(result); // 3 &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java同步辅助器CountDownLatch","slug":"Java同步辅助器CountDownLatch","date":"2019-11-23T15:15:48.000Z","updated":"2020-11-15T14:03:01.399Z","comments":false,"path":"2019/11/23/Java同步辅助器CountDownLatch/","link":"","permalink":"https://zhechu.github.io/2019/11/23/Java同步辅助器CountDownLatch/","excerpt":"","text":"1 分组聚合示例两个步骤： 让一组线程在全部启动完成之后，再一起执行； 主线程等待另外一组线程都执行完成之后，再继续执行。 TIPS：先聚 -&gt; 后散 -&gt; 再聚。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CountDownLatchDemo &#123; // 线程任务 class Worker implements Runnable &#123; // 定义计数锁用来实现功能 1 private final CountDownLatch startSignal; // 定义计数锁用来实现功能 2 private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123; this.startSignal = startSignal; this.doneSignal = doneSignal; &#125; // 子线程做的事情 public void run() &#123; try &#123; System.out.println(Thread.currentThread().getName()+\" begin\"); // await 时有两点需要注意：await 时 state 不会发生变化，2：startSignal 的state初始化是 1，所以所有子线程都是获取不到锁的，都需要到同步队列中去等待，达到先启动的子线程等待后面启动的子线程的结果 startSignal.await(); doWork(); // countDown 每次会使 state 减一，doneSignal 初始化为 9，countDown 前 8 次执行都会返回 false (releaseShared 方法)，执行第 9 次时，state 递减为 0，会 countDown 成功，表示所有子线程都执行完了，会释放 await 在 doneSignal 上的主线程 doneSignal.countDown(); System.out.println(Thread.currentThread().getName()+\" end\"); &#125; catch (InterruptedException ex) &#123; &#125; // return; &#125; void doWork() throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()+\"sleep 5s …………\"); Thread.sleep(5000l); &#125; &#125; @Test public void test() throws InterruptedException &#123; // state 初始化为 1 很关键，子线程是不断的 await，await 时 state 是不会变化的，并且发现 state 都是 1，所有线程都获取不到锁 // 造成所有线程都到同步队列中去等待，当主线程执行 countDown 时，就会一起把等待的线程给释放掉 CountDownLatch startSignal = new CountDownLatch(1); // state 初始化成 9，表示有 9 个子线程执行完成之后，会唤醒主线程 CountDownLatch doneSignal = new CountDownLatch(9); for (int i = 0; i &lt; 9; ++i) // create and start threads &#123; new Thread(new Worker(startSignal, doneSignal)).start(); &#125; System.out.println(\"main thread begin\"); // 这行代码唤醒 9 个子线程，开始执行(因为 startSignal 锁的状态是 1，所以调用一次 countDown 方法就可以释放9个等待的子线程) startSignal.countDown(); // 这行代码使主线程陷入沉睡，等待 9 个子线程执行完成之后才会继续执行(就是等待子线程执行 doneSignal.countDown()) doneSignal.await(); System.out.println(\"main thread end\"); &#125;&#125; 输出效果1234567891011121314151617181920212223242526272829Thread-0 beginThread-1 beginThread-2 beginThread-3 beginThread-4 beginThread-5 beginThread-6 beginThread-7 beginmain thread beginThread-8 beginThread-8sleep 5s …………Thread-2sleep 5s …………Thread-1sleep 5s …………Thread-7sleep 5s …………Thread-0sleep 5s …………Thread-6sleep 5s …………Thread-5sleep 5s …………Thread-4sleep 5s …………Thread-3sleep 5s …………Thread-8 endThread-2 endmain thread endThread-3 endThread-6 endThread-4 endThread-5 endThread-0 endThread-1 endThread-7 end 2 超时等待示例使用其 await 方法可以实现等待超时后返回1public boolean await(long timeout, TimeUnit unit) 正常返回则调用其 countDown 方法即可1public void countDown() 2.1 RocketMQ 生产者发送指定超时时间代码org.apache.rocketmq.client.producer.DefaultMQProducer1public SendResult send(Message msg, long timeout)","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java死锁检测","slug":"Java死锁检测","date":"2019-10-12T10:17:45.000Z","updated":"2020-11-03T13:04:34.158Z","comments":false,"path":"2019/10/12/Java死锁检测/","link":"","permalink":"https://zhechu.github.io/2019/10/12/Java死锁检测/","excerpt":"","text":"环境说明 环境 jdk-1.8 1 死锁示例程序12345678910111213141516171819202122232425262728293031323334353637public class DeadLockSample extends Thread &#123; private String first; private String second; public DeadLockSample(String name, String first, String second) &#123; super(name); this.first = first; this.second = second; &#125; public void run() &#123; synchronized (first) &#123; System.out.println(this.getName() + \" obtained: \" + first); try &#123; Thread.sleep(1000L); synchronized (second) &#123; System.out.println(this.getName() + \" obtained: \" + second); &#125; &#125; catch (InterruptedException e) &#123; // Do nothing &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; String lockA = \"lockA\"; String lockB = \"lockB\"; DeadLockSample t1 = new DeadLockSample(\"Thread1\", lockA, lockB); DeadLockSample t2 = new DeadLockSample(\"Thread2\", lockB, lockA); t1.start(); t2.start(); t1.join(); t2.join(); &#125;&#125; 2 使用 jps 和 jstack 检测使用 jps 找到 pid1$ jps 使用 jstack 根据 pid 查看具体信息（最后发现有打印死锁信息）1$ jstack 3408 3 使用 jconsole 检测双击 jconsole.exe 启动 jconsole 工具，如：F:\\java\\jdk1.8.0_45_64bit\\bin\\jconsole.exe 选择具体进程 进入线程页面，检测死锁 查看线程产生死锁的具体原因 4 使用 ThreadMXBean API 检测使用场景：可以用于程序监控。 示例程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.lang.management.ManagementFactory;import java.lang.management.ThreadInfo;import java.lang.management.ThreadMXBean;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class MyDeadLockSample extends Thread &#123; private String first; private String second; public MyDeadLockSample(String name, String first, String second) &#123; super(name); this.first = first; this.second = second; &#125; public void run() &#123; synchronized (first) &#123; System.out.println(this.getName() + \" obtained: \" + first); try &#123; Thread.sleep(1000L); synchronized (second) &#123; System.out.println(this.getName() + \" obtained: \" + second); &#125; &#125; catch (InterruptedException e) &#123; // Do nothing &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; detectedDeadlockThread(); threadStart(); &#125; private static void threadStart() throws InterruptedException &#123; String lockA = \"lockA\"; String lockB = \"lockB\"; MyDeadLockSample t1 = new MyDeadLockSample(\"Thread1\", lockA, lockB); MyDeadLockSample t2 = new MyDeadLockSample(\"Thread2\", lockB, lockA); t1.start(); t2.start(); t1.join(); t2.join(); &#125; private static void detectedDeadlockThread() &#123; ThreadMXBean mbean = ManagementFactory.getThreadMXBean(); Runnable dlCheck = new Runnable() &#123; @Override public void run() &#123; long[] threadIds = mbean.findDeadlockedThreads(); if (threadIds != null) &#123; ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds); System.out.println(\"Detected deadlock threads:\"); for (ThreadInfo threadInfo : threadInfos) &#123; System.out.println(threadInfo.getThreadName()); &#125; &#125; &#125; &#125;; ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // 稍等 5 秒，然后每 10 秒进行一次死锁扫描 scheduler.scheduleAtFixedRate(dlCheck, 5L, 10L, TimeUnit.SECONDS); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"},{"name":"锁","slug":"锁","permalink":"https://zhechu.github.io/tags/锁/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"LinkedHashMap实现LRU算法","slug":"LinkedHashMap实现LRU算法","date":"2019-10-10T14:43:46.000Z","updated":"2020-11-03T13:04:34.161Z","comments":false,"path":"2019/10/10/LinkedHashMap实现LRU算法/","link":"","permalink":"https://zhechu.github.io/2019/10/10/LinkedHashMap实现LRU算法/","excerpt":"","text":"基于 LinkedHashMap 实现 LRU 算法 1 使用场景 资源池 2 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Collections;import java.util.LinkedHashMap;import java.util.Map;/** * @description: LinkedHashMap 实现 LRU (Least recently used) 最近最少使用 算法 * @author: lingyuwang **/public class LinkedHashMapSample &#123; public static void main(String[] args) &#123; // 初始容量根据实际需要设置 LinkedHashMap&lt;String, String&gt; accessOrderedMap = new LinkedHashMap&lt;String, String&gt;(8, 0.75F, true)&#123; /** * 实现自定义删除策略，否则行为就和普遍 Map 没有区别 * @param eldest * @return */ @Override protected boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) &#123; // 当节点数大于3则移除最近最少使用的节点 return size() &gt; 3; &#125; &#125;; // 同步化，保证线程安全。若确定只有在同一个线程处理，则不需同步化 Map&lt;String, String&gt; accessOrderedSyncMap = Collections.synchronizedMap(accessOrderedMap); // 添加数据 accessOrderedSyncMap.put(\"Project1\", \"Valhalla\"); accessOrderedSyncMap.put(\"Project2\", \"Panama\"); accessOrderedSyncMap.put(\"Project3\", \"Loom\"); // 查看节点顺序，应该与添加顺序一致 accessOrderedSyncMap.forEach( (k,v) -&gt; &#123; System.out.println(k +\":\" + v); &#125;); // 模拟访问 accessOrderedSyncMap.get(\"Project2\"); accessOrderedSyncMap.get(\"Project3\"); accessOrderedSyncMap.get(\"Project2\"); // 查看节点，节点数量应该不变，但是顺序变了，最后访问的节点将排在最后 System.out.println(\"Iterate over should be not affected:\"); accessOrderedSyncMap.forEach( (k,v) -&gt; &#123; System.out.println(k +\":\" + v); &#125;); // 触发删除，排在最前的节点表示最近最少使用，将会被删除 accessOrderedSyncMap.put(\"Project4\", \"Mission Control\"); // 查看节点 System.out.println(\"Oldest entry should be removed:\"); accessOrderedSyncMap.forEach( (k,v) -&gt; &#123; System.out.println(k +\":\" + v); &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"集合","slug":"集合","permalink":"https://zhechu.github.io/tags/集合/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Elasticsearch重建索引","slug":"Elasticsearch重建索引","date":"2019-10-04T03:16:21.000Z","updated":"2020-11-03T13:04:34.082Z","comments":false,"path":"2019/10/04/Elasticsearch重建索引/","link":"","permalink":"https://zhechu.github.io/2019/10/04/Elasticsearch重建索引/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Elasticsearch分页查询","slug":"Elasticsearch分页查询","date":"2019-10-03T09:27:41.000Z","updated":"2020-11-03T13:04:34.080Z","comments":false,"path":"2019/10/03/Elasticsearch分页查询/","link":"","permalink":"https://zhechu.github.io/2019/10/03/Elasticsearch分页查询/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Elasticsearch聚合查询","slug":"Elasticsearch聚合查询","date":"2019-10-03T09:27:23.000Z","updated":"2020-11-03T13:04:34.082Z","comments":false,"path":"2019/10/03/Elasticsearch聚合查询/","link":"","permalink":"https://zhechu.github.io/2019/10/03/Elasticsearch聚合查询/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Elasticsearch集群搭建&跨集群搜索","slug":"Elasticsearch集群搭建-跨集群搜索","date":"2019-10-02T08:37:23.000Z","updated":"2020-11-03T13:04:34.082Z","comments":false,"path":"2019/10/02/Elasticsearch集群搭建-跨集群搜索/","link":"","permalink":"https://zhechu.github.io/2019/10/02/Elasticsearch集群搭建-跨集群搜索/","excerpt":"","text":"环境说明 环境 说明 Elasticsearch-7.1.1 分布式、RESTful 风格的搜索和数据分析引擎 官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/7.1/modules-cross-cluster-search.html 1 多集群搭建单节点集群11$ docker run --name cluster0node -d -p 9200:9200 -p 9300:9300 -e \"node.name=cluster0node\" -e \"cluster.name=cluster0\" -e \"discovery.type=single-node\" elasticsearch:7.1.1 单节点集群21$ docker run --name cluster1node -d -p 9201:9200 -p 9301:9300 -e \"node.name=cluster1node\" -e \"cluster.name=cluster1\" -e \"discovery.type=single-node\" elasticsearch:7.1.1 单节点集群31$ docker run --name cluster2node -d -p 9202:9200 -p 9302:9300 -e \"node.name=cluster2node\" -e \"cluster.name=cluster2\" -e \"discovery.type=single-node\" elasticsearch:7.1.1 启动 kibana1$ docker run --name kibana_7_1_1 -d --link cluster0node:elasticsearch -p 5601:5601 kibana:7.1.1 启动 Cerebro1$ docker run --name cerebro -d -p 9000:9000 lmenezes/cerebro:0.8.3 2 跨集群搜索在每个集群上设置动态的设置跨集群信息123456789101112131415161718192021222324252627PUT _cluster/settings&#123; \"persistent\": &#123; \"cluster\": &#123; \"remote\": &#123; \"cluster0\": &#123; \"seeds\": [ \"192.168.163.41:9300\" ], \"transport.ping_schedule\": \"30s\" &#125;, \"cluster1\": &#123; \"seeds\": [ \"192.168.163.41:9301\" ], \"transport.compress\": true, \"skip_unavailable\": true &#125;, \"cluster2\": &#123; \"seeds\": [ \"192.168.163.41:9302\" ] &#125; &#125; &#125; &#125;&#125; 执行设置12345$ curl -XPUT \"http://192.168.163.41:9200/_cluster/settings\" -H 'Content-Type: application/json' -d' &#123;\"persistent\":&#123;\"cluster\":&#123;\"remote\":&#123;\"cluster0\":&#123;\"seeds\":[\"192.168.163.41:9300\"],\"transport.ping_schedule\":\"30s\"&#125;,\"cluster1\":&#123;\"seeds\":[\"192.168.163.41:9301\"],\"transport.compress\":true,\"skip_unavailable\":true&#125;,\"cluster2\":&#123;\"seeds\":[\"192.168.163.41:9302\"]&#125;&#125;&#125;&#125;&#125;'$ curl -XPUT \"http://192.168.163.41:9201/_cluster/settings\" -H 'Content-Type: application/json' -d' &#123;\"persistent\":&#123;\"cluster\":&#123;\"remote\":&#123;\"cluster0\":&#123;\"seeds\":[\"192.168.163.41:9300\"],\"transport.ping_schedule\":\"30s\"&#125;,\"cluster1\":&#123;\"seeds\":[\"192.168.163.41:9301\"],\"transport.compress\":true,\"skip_unavailable\":true&#125;,\"cluster2\":&#123;\"seeds\":[\"192.168.163.41:9302\"]&#125;&#125;&#125;&#125;&#125;'$ curl -XPUT \"http://192.168.163.41:9202/_cluster/settings\" -H 'Content-Type: application/json' -d' &#123;\"persistent\":&#123;\"cluster\":&#123;\"remote\":&#123;\"cluster0\":&#123;\"seeds\":[\"192.168.163.41:9300\"],\"transport.ping_schedule\":\"30s\"&#125;,\"cluster1\":&#123;\"seeds\":[\"192.168.163.41:9301\"],\"transport.compress\":true,\"skip_unavailable\":true&#125;,\"cluster2\":&#123;\"seeds\":[\"192.168.163.41:9302\"]&#125;&#125;&#125;&#125;&#125;' 创建测试数据12345$ curl -XPOST \"http://192.168.163.41:9200/users/_doc\" -H 'Content-Type: application/json' -d' &#123;\"name\":\"user1\",\"age\":10&#125;'$ curl -XPOST \"http://192.168.163.41:9201/users/_doc\" -H 'Content-Type: application/json' -d' &#123;\"name\":\"user2\",\"age\":20&#125;'$ curl -XPOST \"http://192.168.163.41:9202/users/_doc\" -H 'Content-Type: application/json' -d' &#123;\"name\":\"user3\",\"age\":30&#125;' 查询1234567891011GET /users,cluster1:users,cluster2:users/_search&#123; \"query\": &#123; \"range\": &#123; \"age\": &#123; \"gte\": 10, \"lte\": 40 &#125; &#125; &#125;&#125; 结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; \"took\" : 119, \"timed_out\" : false, \"num_reduce_phases\" : 4, \"_shards\" : &#123; \"total\" : 3, \"successful\" : 3, \"skipped\" : 0, \"failed\" : 0 &#125;, \"_clusters\" : &#123; \"total\" : 3, \"successful\" : 3, \"skipped\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 3, \"relation\" : \"eq\" &#125;, \"max_score\" : 1.0, \"hits\" : [ &#123; \"_index\" : \"users\", \"_type\" : \"_doc\", \"_id\" : \"SsWQjG0BbuMQY95bMqmd\", \"_score\" : 1.0, \"_source\" : &#123; \"name\" : \"user1\", \"age\" : 10 &#125; &#125;, &#123; \"_index\" : \"cluster1:users\", \"_type\" : \"_doc\", \"_id\" : \"0EiQjG0Bt5NNod7deiWN\", \"_score\" : 1.0, \"_source\" : &#123; \"name\" : \"user2\", \"age\" : 20 &#125; &#125;, &#123; \"_index\" : \"cluster2:users\", \"_type\" : \"_doc\", \"_id\" : \"LmuQjG0BbFLoLmzJprox\", \"_score\" : 1.0, \"_source\" : &#123; \"name\" : \"user3\", \"age\" : 30 &#125; &#125; ] &#125;&#125; 3 单集群多节点搭建主节点配置12345678910111213$ vi es_cluster0node0.ymlcluster.name: cluster0node.name: cluster0node0network.bind_host: 0.0.0.0network.host: 192.168.163.41http.port: 9200transport.tcp.port: 9300http.cors.enabled: truehttp.cors.allow-origin: \"*\"node.master: truenode.data: truediscovery.seed_hosts: [\"192.168.163.41:9301\"]cluster.initial_master_nodes: [\"cluster0node0\"] 主节点启动1$ docker run --name cluster0node0 -d --network host -v /usr/local/src/elk/es_cluster0node0.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:7.1.1 非主节点配置12345678910111213$ vi es_cluster0node1.ymlcluster.name: cluster0node.name: cluster0node1network.bind_host: 0.0.0.0network.host: 192.168.163.41http.port: 9201transport.tcp.port: 9301http.cors.enabled: truehttp.cors.allow-origin: \"*\"node.master: truenode.data: truediscovery.seed_hosts: [\"192.168.163.41:9300\"]cluster.initial_master_nodes: [\"cluster0node0\"] 非主节点启动1$ docker run --name cluster0node1 -d --network host -v /usr/local/src/elk/es_cluster0node1.yml:/usr/share/elasticsearch/config/elasticsearch.yml elasticsearch:7.1.1","categories":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://zhechu.github.io/tags/搜索/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}]},{"title":"Elasticsearch搜索建议","slug":"Elasticsearch搜索建议","date":"2019-10-02T04:46:35.000Z","updated":"2020-11-03T13:04:34.081Z","comments":false,"path":"2019/10/02/Elasticsearch搜索建议/","link":"","permalink":"https://zhechu.github.io/2019/10/02/Elasticsearch搜索建议/","excerpt":"","text":"环境说明 环境 说明 Elasticsearch-7.1.1 分布式、RESTful 风格的搜索和数据分析引擎 官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/7.1/search-suggesters.html 1 使用场景搜索框自动补全。 精准度和召回率比较 精准度：Completion &gt; Phrase &gt; Term 召回率：Term &gt; Phrase &gt; Completion 性能：Completion &gt; Phrase &gt; Term 2 Suggestion Mode Missing：若索引中已经存在，就不不提供建议 Popular：推荐出现频率更更加高的词 Always：无论是否存在，都提供建议 每个建议都包含了一个算分，相似性是通过 Levenshtein Edit Distance 的算法实现的。核心思想就是一个词改动多少字符就可以和另外一个词一致。 提供了很多可选参数来控制相似性的模糊程度。例如 “max_edits”。 3 示例准备测试数据，默认使用 standard 分词器（1.大写转小写，2.rocks 和 rock 是两个词）12345678910111213141516171819202122DELETE articlesPOST articles/_bulk&#123; \"index\" : &#123; &#125; &#125;&#123; \"body\": \"lucene is very cool\"&#125;&#123; \"index\" : &#123; &#125; &#125;&#123; \"body\": \"Elasticsearch builds on top of lucene\"&#125;&#123; \"index\" : &#123; &#125; &#125;&#123; \"body\": \"Elasticsearch rocks\"&#125;&#123; \"index\" : &#123; &#125; &#125;&#123; \"body\": \"elastic is the company behind ELK stack\"&#125;&#123; \"index\" : &#123; &#125; &#125;&#123; \"body\": \"Elk stack rocks\"&#125;&#123; \"index\" : &#123;&#125; &#125;&#123; \"body\": \"elasticsearch is rock solid\"&#125;POST _analyze&#123; \"analyzer\": \"standard\", \"text\": [\"Elk stack rocks rock\"]&#125; 3.1 Missing Mode查询123456789101112131415161718POST /articles/_search&#123; \"size\": 1, \"query\": &#123; \"match\": &#123; \"body\": \"lucen rock\" &#125; &#125;, \"suggest\": &#123; \"term-suggestion\": &#123; \"text\": \"lucen rock\", \"term\": &#123; \"suggest_mode\": \"missing\", \"field\": \"body\" &#125; &#125; &#125;&#125; 结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"took\" : 11, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 1, \"relation\" : \"eq\" &#125;, \"max_score\" : 1.5904956, \"hits\" : [ &#123; \"_index\" : \"articles\", \"_type\" : \"_doc\", \"_id\" : \"M3cVjG0BVNsf23wwpif9\", \"_score\" : 1.5904956, \"_source\" : &#123; \"body\" : \"elasticsearch is rock solid\" &#125; &#125; ] &#125;, \"suggest\" : &#123; \"term-suggestion\" : [ &#123; \"text\" : \"lucen\", \"offset\" : 0, \"length\" : 5, \"options\" : [ &#123; \"text\" : \"lucene\", \"score\" : 0.8, \"freq\" : 2 &#125; ] &#125;, &#123; \"text\" : \"rock\", \"offset\" : 6, \"length\" : 4, \"options\" : [ ] &#125; ] &#125;&#125; 3.2 Popular Mode查询12345678910111213POST /articles/_search&#123; \"suggest\": &#123; \"term-suggestion\": &#123; \"text\": \"lucen rock\", \"term\": &#123; \"suggest_mode\": \"popular\", \"field\": \"body\" &#125; &#125; &#125;&#125; 结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; \"took\" : 10, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 0, \"relation\" : \"eq\" &#125;, \"max_score\" : null, \"hits\" : [ ] &#125;, \"suggest\" : &#123; \"term-suggestion\" : [ &#123; \"text\" : \"lucen\", \"offset\" : 0, \"length\" : 5, \"options\" : [ &#123; \"text\" : \"lucene\", \"score\" : 0.8, \"freq\" : 2 &#125; ] &#125;, &#123; \"text\" : \"rock\", \"offset\" : 6, \"length\" : 4, \"options\" : [ &#123; \"text\" : \"rocks\", \"score\" : 0.75, \"freq\" : 2 &#125; ] &#125; ] &#125;&#125; 3.3 Sorting by Frequency &amp; Prefix Length默认按照 score 排序，也可以按照 “frequency” 排序，默认首字母不一致就不会匹配推荐，但是如果将 prefix_length 设置为 0，就会为 hock 建议 rock123456789101112131415POST /articles/_search&#123; \"suggest\": &#123; \"term-suggestion\": &#123; \"text\": \"lucen hocks\", \"term\": &#123; \"suggest_mode\": \"always\", \"field\": \"body\", \"prefix_length\":0, \"sort\": \"frequency\" &#125; &#125; &#125;&#125; 结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123; \"took\" : 7, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 0, \"relation\" : \"eq\" &#125;, \"max_score\" : null, \"hits\" : [ ] &#125;, \"suggest\" : &#123; \"term-suggestion\" : [ &#123; \"text\" : \"lucen\", \"offset\" : 0, \"length\" : 5, \"options\" : [ &#123; \"text\" : \"lucene\", \"score\" : 0.8, \"freq\" : 2 &#125; ] &#125;, &#123; \"text\" : \"hocks\", \"offset\" : 6, \"length\" : 5, \"options\" : [ &#123; \"text\" : \"rocks\", \"score\" : 0.8, \"freq\" : 2 &#125; ] &#125; ] &#125;&#125; 3.4 Phrase SuggesterPhrase Suggester 在 Term Suggester 上增加了一些额外的逻辑。Max Errors：最多可以拼错的 Terms 数，Confidence：限制返回结果数，默认为 1123456789101112131415161718192021POST /articles/_search&#123; \"suggest\": &#123; \"my-suggestion\": &#123; \"text\": \"lucne and elasticsear rock hello world \", \"phrase\": &#123; \"field\": \"body\", \"max_errors\":2, \"confidence\":0, \"direct_generator\":[&#123; \"field\":\"body\", \"suggest_mode\":\"always\" &#125;], \"highlight\": &#123; \"pre_tag\": \"&lt;em&gt;\", \"post_tag\": \"&lt;/em&gt;\" &#125; &#125; &#125; &#125;&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; \"took\" : 33, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 0, \"relation\" : \"eq\" &#125;, \"max_score\" : null, \"hits\" : [ ] &#125;, \"suggest\" : &#123; \"my-suggestion\" : [ &#123; \"text\" : \"lucne and elasticsear rock hello world \", \"offset\" : 0, \"length\" : 39, \"options\" : [ &#123; \"text\" : \"lucene and elasticsearch rock hello world\", \"highlighted\" : \"&lt;em&gt;lucene&lt;/em&gt; and &lt;em&gt;elasticsearch&lt;/em&gt; rock hello world\", \"score\" : 1.5788074E-4 &#125;, &#123; \"text\" : \"lucne and elasticsearch rocks hello world\", \"highlighted\" : \"lucne and &lt;em&gt;elasticsearch rocks&lt;/em&gt; hello world\", \"score\" : 1.136111E-4 &#125;, &#123; \"text\" : \"lucne and elasticsearch rock hello world\", \"highlighted\" : \"lucne and &lt;em&gt;elasticsearch&lt;/em&gt; rock hello world\", \"score\" : 1.05567684E-4 &#125;, &#123; \"text\" : \"lucene and elasticsear rocks hello world\", \"highlighted\" : \"&lt;em&gt;lucene&lt;/em&gt; and elasticsear &lt;em&gt;rocks&lt;/em&gt; hello world\", \"score\" : 9.929376E-5 &#125;, &#123; \"text\" : \"lucene and elasticsear rock hello world\", \"highlighted\" : \"&lt;em&gt;lucene&lt;/em&gt; and elasticsear rock hello world\", \"score\" : 9.2263974E-5 &#125; ] &#125; ] &#125;&#125;","categories":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://zhechu.github.io/tags/搜索/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}]},{"title":"Elasticsearch常用分词器","slug":"Elasticsearch常用分词器","date":"2019-10-01T08:09:00.000Z","updated":"2020-11-03T13:04:34.081Z","comments":false,"path":"2019/10/01/Elasticsearch常用分词器/","link":"","permalink":"https://zhechu.github.io/2019/10/01/Elasticsearch常用分词器/","excerpt":"","text":"环境说明 环境 说明 Elasticsearch-7.1.1 分布式、RESTful 风格的搜索和数据分析引擎 分词器选型参考博客 https://blog.csdn.net/ZYC88888/article/details/83620572 1 分词器1.1 HanLP面向生产环境的自然语言处理理工具包 hanlp：hanlp 默认分词 hanlp_standard：标准分词 hanlp_index：索引分词 hanlp_nlp：NLP 分词 hanlp_n_short：N-最短路分词 hanlp_dijkstra：最短路径分词 hanlp_speed：极速词典分词 官方网站 http://hanlp.com/ 官方文档 https://github.com/KennFalcon/elasticsearch-analysis-hanlp 安装1$ /usr/share/elasticsearch/bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.1/elasticsearch-analysis-ik-7.1.1.zip 1.1.1 默认分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"nsf\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"vn\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"nis\", \"position\" : 2 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"a\", \"position\" : 3 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 4 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 5 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 6 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 8 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 9 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 10 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 11 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 12 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 13 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 14 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 15 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"nz\", \"position\" : 16 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 17 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 18 &#125; ]&#125; 1.1.2 标准分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_standard\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"nsf\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"vn\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"nis\", \"position\" : 2 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"a\", \"position\" : 3 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 4 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 5 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 6 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 8 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 9 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 10 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 11 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 12 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 13 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 14 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 15 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"nz\", \"position\" : 16 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 17 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 18 &#125; ]&#125; 1.1.3 索引分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_index\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"nsf\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"vn\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"nis\", \"position\" : 2 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"a\", \"position\" : 3 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 4 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 5 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 6 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 8 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 9 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 10 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 11 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 12 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 13 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 14 &#125;, &#123; \"token\" : \"唐纳德\", \"start_offset\" : 22, \"end_offset\" : 25, \"type\" : \"nrf\", \"position\" : 15 &#125;, &#123; \"token\" : \"唐纳\", \"start_offset\" : 22, \"end_offset\" : 24, \"type\" : \"nrf\", \"position\" : 16 &#125;, &#123; \"token\" : \"纳德\", \"start_offset\" : 23, \"end_offset\" : 25, \"type\" : \"nrf\", \"position\" : 17 &#125;, &#123; \"token\" : \"特朗普\", \"start_offset\" : 26, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 18 &#125;, &#123; \"token\" : \"朗普\", \"start_offset\" : 27, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 19 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 20 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"nz\", \"position\" : 21 &#125;, &#123; \"token\" : \"总统\", \"start_offset\" : 30, \"end_offset\" : 32, \"type\" : \"nnt\", \"position\" : 22 &#125;, &#123; \"token\" : \"大选\", \"start_offset\" : 32, \"end_offset\" : 34, \"type\" : \"vn\", \"position\" : 23 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 24 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 25 &#125; ]&#125; 1.1.4 NLP 分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_nlp\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥分析公司\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"nt\", \"position\" : 0 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"a\", \"position\" : 1 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 2 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 3 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 4 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 5 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 6 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 8 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 9 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 10 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 11 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 12 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 13 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"nz\", \"position\" : 14 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 15 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 16 &#125; ]&#125; 1.1.5 N-最短路径分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_n_short\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥分析公司\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"nt\", \"position\" : 0 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"m\", \"position\" : 1 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 2 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 3 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 4 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 5 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 6 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 8 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 9 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 10 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 11 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 12 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 13 &#125;, &#123; \"token\" : \"总统\", \"start_offset\" : 30, \"end_offset\" : 32, \"type\" : \"nnt\", \"position\" : 14 &#125;, &#123; \"token\" : \"大选\", \"start_offset\" : 32, \"end_offset\" : 34, \"type\" : \"vn\", \"position\" : 15 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 16 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 17 &#125; ]&#125; 1.1.6 最短路径分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_dijkstra\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥分析公司\", \"start_offset\" : 0, \"end_offset\" : 6, \"type\" : \"nt\", \"position\" : 0 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"a\", \"position\" : 1 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"q\", \"position\" : 2 &#125;, &#123; \"token\" : \"高管\", \"start_offset\" : 8, \"end_offset\" : 10, \"type\" : \"nr\", \"position\" : 3 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"p\", \"position\" : 4 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"v\", \"position\" : 5 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"nnt\", \"position\" : 6 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"v\", \"position\" : 7 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"w\", \"position\" : 8 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"rr\", \"position\" : 9 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"v\", \"position\" : 10 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"ule\", \"position\" : 11 &#125;, &#123; \"token\" : \"唐纳德·特朗普\", \"start_offset\" : 22, \"end_offset\" : 29, \"type\" : \"nrf\", \"position\" : 12 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"p\", \"position\" : 13 &#125;, &#123; \"token\" : \"总统\", \"start_offset\" : 30, \"end_offset\" : 32, \"type\" : \"nnt\", \"position\" : 14 &#125;, &#123; \"token\" : \"大选\", \"start_offset\" : 32, \"end_offset\" : 34, \"type\" : \"vn\", \"position\" : 15 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"f\", \"position\" : 16 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"vi\", \"position\" : 17 &#125; ]&#125; 1.1.7 极速词典分词示例123456POST _analyze&#123; \"analyzer\": \"hanlp_speed\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"null\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"null\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"null\", \"position\" : 2 &#125;, &#123; \"token\" : \"多\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"null\", \"position\" : 3 &#125;, &#123; \"token\" : \"位\", \"start_offset\" : 7, \"end_offset\" : 8, \"type\" : \"null\", \"position\" : 4 &#125;, &#123; \"token\" : \"高\", \"start_offset\" : 8, \"end_offset\" : 9, \"type\" : \"null\", \"position\" : 5 &#125;, &#123; \"token\" : \"管\", \"start_offset\" : 9, \"end_offset\" : 10, \"type\" : \"null\", \"position\" : 6 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"null\", \"position\" : 7 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"null\", \"position\" : 8 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"null\", \"position\" : 9 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"null\", \"position\" : 10 &#125;, &#123; \"token\" : \"，\", \"start_offset\" : 16, \"end_offset\" : 17, \"type\" : \"null\", \"position\" : 11 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"null\", \"position\" : 12 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"null\", \"position\" : 13 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"null\", \"position\" : 14 &#125;, &#123; \"token\" : \"唐纳德\", \"start_offset\" : 22, \"end_offset\" : 25, \"type\" : \"null\", \"position\" : 15 &#125;, &#123; \"token\" : \"·\", \"start_offset\" : 25, \"end_offset\" : 26, \"type\" : \"null\", \"position\" : 16 &#125;, &#123; \"token\" : \"特朗普\", \"start_offset\" : 26, \"end_offset\" : 29, \"type\" : \"null\", \"position\" : 17 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"null\", \"position\" : 18 &#125;, &#123; \"token\" : \"总统\", \"start_offset\" : 30, \"end_offset\" : 32, \"type\" : \"null\", \"position\" : 19 &#125;, &#123; \"token\" : \"大选\", \"start_offset\" : 32, \"end_offset\" : 34, \"type\" : \"null\", \"position\" : 20 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"null\", \"position\" : 21 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"null\", \"position\" : 22 &#125; ]&#125; 1.2 IK 分词器器中文分词 ik_max_word：会将文本做最细粒度的拆分；尽可能多的拆分出词语 ik_smart：会做最粗粒度的拆分；已被分出的词语将不会再次被其它词语占有 官方文档 https://github.com/medcl/elasticsearch-analysis-ik 安装1$ /usr/share/elasticsearch/bin/elasticsearch-plugin install https://github.com/KennFalcon/elasticsearch-analysis-hanlp/releases/download/v7.1.1/elasticsearch-analysis-hanlp-7.1.1.zip 1.2.1 ik_max_word示例123456POST _analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"多位\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 3 &#125;, &#123; \"token\" : \"高\", \"start_offset\" : 8, \"end_offset\" : 9, \"type\" : \"CN_CHAR\", \"position\" : 4 &#125;, &#123; \"token\" : \"管\", \"start_offset\" : 9, \"end_offset\" : 10, \"type\" : \"CN_CHAR\", \"position\" : 5 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"CN_CHAR\", \"position\" : 6 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"CN_WORD\", \"position\" : 7 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"CN_WORD\", \"position\" : 8 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"CN_CHAR\", \"position\" : 9 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"CN_WORD\", \"position\" : 10 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"CN_WORD\", \"position\" : 11 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"CN_CHAR\", \"position\" : 12 &#125;, &#123; \"token\" : \"唐纳德\", \"start_offset\" : 22, \"end_offset\" : 25, \"type\" : \"CN_WORD\", \"position\" : 13 &#125;, &#123; \"token\" : \"特\", \"start_offset\" : 26, \"end_offset\" : 27, \"type\" : \"CN_CHAR\", \"position\" : 14 &#125;, &#123; \"token\" : \"朗\", \"start_offset\" : 27, \"end_offset\" : 28, \"type\" : \"CN_CHAR\", \"position\" : 15 &#125;, &#123; \"token\" : \"普\", \"start_offset\" : 28, \"end_offset\" : 29, \"type\" : \"CN_CHAR\", \"position\" : 16 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"CN_CHAR\", \"position\" : 17 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"CN_WORD\", \"position\" : 18 &#125;, &#123; \"token\" : \"总统\", \"start_offset\" : 30, \"end_offset\" : 32, \"type\" : \"CN_WORD\", \"position\" : 19 &#125;, &#123; \"token\" : \"大选\", \"start_offset\" : 32, \"end_offset\" : 34, \"type\" : \"CN_WORD\", \"position\" : 20 &#125;, &#123; \"token\" : \"选中\", \"start_offset\" : 33, \"end_offset\" : 35, \"type\" : \"CN_WORD\", \"position\" : 21 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"CN_WORD\", \"position\" : 22 &#125; ]&#125; 1.2.2 ik_smart示例123456POST _analyze&#123; \"analyzer\": \"ik_smart\", \"text\": [\"剑桥分析公司多位高管对卧底记者说，他们确保了唐纳德·特朗普在总统大选中获胜\"]&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&#123; \"tokens\" : [ &#123; \"token\" : \"剑桥\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 &#125;, &#123; \"token\" : \"分析\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 1 &#125;, &#123; \"token\" : \"公司\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"多位\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"CN_WORD\", \"position\" : 3 &#125;, &#123; \"token\" : \"高\", \"start_offset\" : 8, \"end_offset\" : 9, \"type\" : \"CN_CHAR\", \"position\" : 4 &#125;, &#123; \"token\" : \"管\", \"start_offset\" : 9, \"end_offset\" : 10, \"type\" : \"CN_CHAR\", \"position\" : 5 &#125;, &#123; \"token\" : \"对\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"CN_CHAR\", \"position\" : 6 &#125;, &#123; \"token\" : \"卧底\", \"start_offset\" : 11, \"end_offset\" : 13, \"type\" : \"CN_WORD\", \"position\" : 7 &#125;, &#123; \"token\" : \"记者\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"CN_WORD\", \"position\" : 8 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 15, \"end_offset\" : 16, \"type\" : \"CN_CHAR\", \"position\" : 9 &#125;, &#123; \"token\" : \"他们\", \"start_offset\" : 17, \"end_offset\" : 19, \"type\" : \"CN_WORD\", \"position\" : 10 &#125;, &#123; \"token\" : \"确保\", \"start_offset\" : 19, \"end_offset\" : 21, \"type\" : \"CN_WORD\", \"position\" : 11 &#125;, &#123; \"token\" : \"了\", \"start_offset\" : 21, \"end_offset\" : 22, \"type\" : \"CN_CHAR\", \"position\" : 12 &#125;, &#123; \"token\" : \"唐纳德\", \"start_offset\" : 22, \"end_offset\" : 25, \"type\" : \"CN_WORD\", \"position\" : 13 &#125;, &#123; \"token\" : \"特\", \"start_offset\" : 26, \"end_offset\" : 27, \"type\" : \"CN_CHAR\", \"position\" : 14 &#125;, &#123; \"token\" : \"朗\", \"start_offset\" : 27, \"end_offset\" : 28, \"type\" : \"CN_CHAR\", \"position\" : 15 &#125;, &#123; \"token\" : \"普\", \"start_offset\" : 28, \"end_offset\" : 29, \"type\" : \"CN_CHAR\", \"position\" : 16 &#125;, &#123; \"token\" : \"在\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"CN_CHAR\", \"position\" : 17 &#125;, &#123; \"token\" : \"总统大选\", \"start_offset\" : 30, \"end_offset\" : 34, \"type\" : \"CN_WORD\", \"position\" : 18 &#125;, &#123; \"token\" : \"中\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"CN_CHAR\", \"position\" : 19 &#125;, &#123; \"token\" : \"获胜\", \"start_offset\" : 35, \"end_offset\" : 37, \"type\" : \"CN_WORD\", \"position\" : 20 &#125; ]&#125; 1.3 Pinyin 分词器拼音分词器。 官方文档 https://github.com/medcl/elasticsearch-analysis-pinyin 安装1$ /usr/share/elasticsearch/bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v7.1.1/elasticsearch-analysis-pinyin-7.1.1.zip 示例1234567891011121314151617181920212223242526PUT /artists/&#123; \"settings\" : &#123; \"analysis\" : &#123; \"analyzer\" : &#123; \"user_name_analyzer\" : &#123; \"tokenizer\" : \"whitespace\", \"filter\" : \"pinyin_first_letter_and_full_pinyin_filter\" &#125; &#125;, \"filter\" : &#123; \"pinyin_first_letter_and_full_pinyin_filter\" : &#123; \"type\" : \"pinyin\", \"keep_first_letter\" : true, \"keep_full_pinyin\" : true, \"keep_none_chinese\" : true, \"keep_original\" : false, \"limit_first_letter_length\" : 32, \"lowercase\" : true, \"trim_whitespace\" : true, \"keep_none_chinese_in_first_letter\" : true &#125; &#125; &#125; &#125;&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&#123; \"tokens\" : [ &#123; \"token\" : \"liu\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"word\", \"position\" : 0 &#125;, &#123; \"token\" : \"ldh\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"word\", \"position\" : 0 &#125;, &#123; \"token\" : \"de\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"word\", \"position\" : 1 &#125;, &#123; \"token\" : \"hua\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"word\", \"position\" : 2 &#125;, &#123; \"token\" : \"zhang\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"word\", \"position\" : 3 &#125;, &#123; \"token\" : \"xue\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"word\", \"position\" : 4 &#125;, &#123; \"token\" : \"you\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"word\", \"position\" : 5 &#125;, &#123; \"token\" : \"zxy\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"word\", \"position\" : 5 &#125;, &#123; \"token\" : \"guo\", \"start_offset\" : 8, \"end_offset\" : 11, \"type\" : \"word\", \"position\" : 6 &#125;, &#123; \"token\" : \"fu\", \"start_offset\" : 8, \"end_offset\" : 11, \"type\" : \"word\", \"position\" : 7 &#125;, &#123; \"token\" : \"cheng\", \"start_offset\" : 8, \"end_offset\" : 11, \"type\" : \"word\", \"position\" : 8 &#125;, &#123; \"token\" : \"gfc\", \"start_offset\" : 8, \"end_offset\" : 11, \"type\" : \"word\", \"position\" : 8 &#125;, &#123; \"token\" : \"li\", \"start_offset\" : 12, \"end_offset\" : 14, \"type\" : \"word\", \"position\" : 9 &#125;, &#123; \"token\" : \"ming\", \"start_offset\" : 12, \"end_offset\" : 14, \"type\" : \"word\", \"position\" : 10 &#125;, &#123; \"token\" : \"lm\", \"start_offset\" : 12, \"end_offset\" : 14, \"type\" : \"word\", \"position\" : 10 &#125;, &#123; \"token\" : \"si\", \"start_offset\" : 15, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 11 &#125;, &#123; \"token\" : \"da\", \"start_offset\" : 15, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 12 &#125;, &#123; \"token\" : \"tian\", \"start_offset\" : 15, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 13 &#125;, &#123; \"token\" : \"wang\", \"start_offset\" : 15, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 14 &#125;, &#123; \"token\" : \"sdtw\", \"start_offset\" : 15, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 14 &#125; ]&#125;","categories":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://zhechu.github.io/tags/搜索/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}]},{"title":"Elasticsearch常用API","slug":"Elasticsearch常用API","date":"2019-09-28T01:19:52.000Z","updated":"2020-11-03T13:04:34.081Z","comments":false,"path":"2019/09/28/Elasticsearch常用API/","link":"","permalink":"https://zhechu.github.io/2019/09/28/Elasticsearch常用API/","excerpt":"","text":"环境说明 环境 说明 Elasticsearch-7.1.1 分布式、RESTful 风格的搜索和数据分析引擎 官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/7.1/index.html TIPS：可以借助 Kibana 的 Dev Tools 工具学习 API 的使用。 1 cat APIs列出所有可用的命令1GET /_cat 12345678910111213141516171819202122232425262728=^.^=/_cat/allocation/_cat/shards/_cat/shards/&#123;index&#125;/_cat/master/_cat/nodes/_cat/tasks/_cat/indices/_cat/indices/&#123;index&#125;/_cat/segments/_cat/segments/&#123;index&#125;/_cat/count/_cat/count/&#123;index&#125;/_cat/recovery/_cat/recovery/&#123;index&#125;/_cat/health/_cat/pending_tasks/_cat/aliases/_cat/aliases/&#123;alias&#125;/_cat/thread_pool/_cat/thread_pool/&#123;thread_pools&#125;/_cat/plugins/_cat/fielddata/_cat/fielddata/&#123;fields&#125;/_cat/nodeattrs/_cat/repositories/_cat/snapshots/&#123;repository&#125;/_cat/templates 1.1 通用参数1.1.1 Verbose使用查询字符串 v 返回详细的输出1GET /_cat/master&amp;v 12id host ip nodeUBgiq696RjueDK3QPFTrgQ 172.17.0.2 172.17.0.2 3c0f6c163958 VS 未使用 v 参数时的效果1GET /_cat/master 1UBgiq696RjueDK3QPFTrgQ 172.17.0.2 172.17.0.2 3c0f6c163958 1.1.2 Sort按照文档个数排序1GET /_cat/indices?v&amp;s=docs.count:desc 1234567health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizegreen open kibana_sample_data_logs mrD7U27WQ5ugNY6RwBB-1Q 1 0 14005 0 10.9mb 10.9mbgreen open kibana_sample_data_flights _sGYWo0aQXeaLI00jZeZEA 1 0 13059 0 6.2mb 6.2mbyellow open movies TmWPFRCqTceXRNX8nA_yeA 1 1 9743 0 1.3mb 1.3mbgreen open kibana_sample_data_ecommerce gqPCrfMyRvmJ9n33e_z4HA 1 0 4675 0 5.1mb 5.1mbgreen open .kibana_1 d4xaJEmhRpaPHHDe3RA2Qw 1 0 141 1 1mb 1mbgreen open .kibana_task_manager -Z0bZeeeQaCNnL6Udrjh6w 1 0 2 0 54.8kb 54.8kb 2 Indices APIs查看 kibana_sample_data_ecommerce 索引的相关信息1GET kibana_sample_data_ecommerce 3 Search APIs查看 kibana_sample_data_ecommerce 索引的文档总数1GET kibana_sample_data_ecommerce/_count 查看 kibana_sample_data_ecommerce 索引的前10条文档123POST kibana_sample_data_ecommerce/_search&#123;&#125; 基本查询1GET /movies/_search?q=2012&amp;df=title&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s 带profile1234GET /movies/_search?q=2012&amp;df=title&#123; \"profile\":\"true\"&#125; 泛查询，正对_all,所有字段1234GET /movies/_search?q=2012&#123; \"profile\":\"true\"&#125; 指定字段1234GET /movies/_search?q=title:2012&amp;sort=year:desc&amp;from=0&amp;size=10&amp;timeout=1s&#123; \"profile\":\"true\"&#125; 查找美丽心灵, Mind为泛查询1234GET /movies/_search?q=title:Beautiful Mind&#123; \"profile\":\"true\"&#125; 泛查询1234GET /movies/_search?q=title:2012&#123; \"profile\":\"true\"&#125; 使用引号，Phrase查询1234GET /movies/_search?q=title:\"Beautiful Mind\"&#123; \"profile\":\"true\"&#125; 分组，Bool查询1234GET /movies/_search?q=title:(Beautiful Mind)&#123; \"profile\":\"true\"&#125; 查找美丽心灵，布尔操作符1234GET /movies/_search?q=title:(Beautiful AND Mind)&#123; \"profile\":\"true\"&#125; 查找美丽心灵1234GET /movies/_search?q=title:(Beautiful NOT Mind)&#123; \"profile\":\"true\"&#125; 查找美丽心灵1234GET /movies/_search?q=title:(Beautiful %2BMind)&#123; \"profile\":\"true\"&#125; 范围查询 ,区间写法1234GET /movies/_search?q=title:beautiful AND year:[2002 TO 2018%7D&#123; \"profile\":\"true\"&#125; 通配符查询1234GET /movies/_search?q=title:b*&#123; \"profile\":\"true\"&#125; 模糊匹配&amp;近似度匹配1234GET /movies/_search?q=title:beautifl~1&#123; \"profile\":\"true\"&#125; 1234GET /movies/_search?q=title:\"Lord Rings\"~2&#123; \"profile\":\"true\"&#125; 4 Cluster APIs查看集群健康情况1GET _cluster/health 查看集群信息1GET _cluster/state 5 Document APIs5.1 创建文档创建 users 索引的文档，自动生成 _id123456POST users/_doc&#123; \"user\" : \"Mike\", \"post_date\" : \"2019-04-15T14:12:12\", \"message\" : \"trying out Kibana\"&#125; 创建 users 索引的文档，指定 _id，若 _id 已经存在，则报错123456PUT users/_doc/1?op_type=create&#123; \"user\" : \"Jack\", \"post_date\" : \"2019-05-15T14:12:12\", \"message\" : \"trying out Elasticsearch\"&#125; 或123456PUT users/_create/1&#123; \"user\" : \"Jack\", \"post_date\" : \"2019-05-15T14:12:12\", \"message\" : \"trying out Elasticsearch\"&#125; 5.2 删除文档删除文档1DELETE users/_doc/1 5.3 更新文档根据 _id 更新文档，先删除再写入1234PUT users/_doc/1&#123; \"user\" : \"Mike\"&#125; 在原文档上增加字段1234567POST users/_update/1/&#123; \"doc\":&#123; \"post_date\" : \"2019-05-15T14:12:12\", \"message\" : \"trying out Elasticsearch\" &#125;&#125; 5.4 查询文档根据 _id 查看文档1GET users/_doc/1 1234567891011121314&#123; \"_index\" : \"users\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_version\" : 1, \"_seq_no\" : 1, \"_primary_term\" : 1, \"found\" : true, \"_source\" : &#123; \"user\" : \"Jack\", \"post_date\" : \"2019-05-15T14:12:12\", \"message\" : \"trying out Elasticsearch\" &#125;&#125; 查看 users 索引的文档1234POST users/_search&#123;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; \"took\" : 1, \"timed_out\" : false, \"_shards\" : &#123; \"total\" : 1, \"successful\" : 1, \"skipped\" : 0, \"failed\" : 0 &#125;, \"hits\" : &#123; \"total\" : &#123; \"value\" : 2, \"relation\" : \"eq\" &#125;, \"max_score\" : 1.0, \"hits\" : [ &#123; \"_index\" : \"users\", \"_type\" : \"_doc\", \"_id\" : \"6-yLd20BKZyFt5vLC64T\", \"_score\" : 1.0, \"_source\" : &#123; \"user\" : \"Mike\", \"post_date\" : \"2019-04-15T14:12:12\", \"message\" : \"trying out Kibana\" &#125; &#125;, &#123; \"_index\" : \"users\", \"_type\" : \"_doc\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : &#123; \"user\" : \"Jack\", \"post_date\" : \"2019-05-15T14:12:12\", \"message\" : \"trying out Elasticsearch\" &#125; &#125; ] &#125;&#125; 6 Analysis安装 analysis-icu 分词器，可以解析中文字符1$ elasticsearch-plugin install analysis-icu 安装 analysis-ik 分词器，可以解析中文字符1$ elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.1.1/elasticsearch-analysis-ik-7.1.1.zip TIPS：分词器有 ik_max_word（会将文本做最细粒度的拆分；尽可能多的拆分出词语） 和 ik_smart（会做最粗粒度的拆分；已被分出的词语将不会再次被其它词语占有）。 使用 ik_max_word 进行中文分词12345POST _analyze&#123; \"analyzer\": \"ik_max_word\", \"text\": \"他说的确实在理”\"&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"tokens\" : [ &#123; \"token\" : \"他\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"CN_CHAR\", \"position\" : 0 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"CN_CHAR\", \"position\" : 1 &#125;, &#123; \"token\" : \"的确\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"确实在\", \"start_offset\" : 3, \"end_offset\" : 6, \"type\" : \"CN_WORD\", \"position\" : 3 &#125;, &#123; \"token\" : \"确实\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 4 &#125;, &#123; \"token\" : \"实在\", \"start_offset\" : 4, \"end_offset\" : 6, \"type\" : \"CN_WORD\", \"position\" : 5 &#125;, &#123; \"token\" : \"在理\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 6 &#125; ]&#125; 使用 ik_max_word 进行中文分词12345POST _analyze&#123; \"analyzer\": \"ik_smart\", \"text\": \"他说的确实在理”\"&#125; 123456789101112131415161718192021222324252627282930313233343536373839&#123; \"tokens\" : [ &#123; \"token\" : \"他\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"CN_CHAR\", \"position\" : 0 &#125;, &#123; \"token\" : \"说\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"CN_CHAR\", \"position\" : 1 &#125;, &#123; \"token\" : \"的确\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 &#125;, &#123; \"token\" : \"实\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"CN_CHAR\", \"position\" : 3 &#125;, &#123; \"token\" : \"在理\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 &#125; ]&#125; 使用空白字符分析器12345POST _analyze&#123; \"analyzer\": \"whitespace\", \"text\": \"The quick brown fox.\"&#125; 使用标准分析器和字符串过滤器123456POST _analyze&#123; \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"asciifolding\" ], \"text\": \"Is this déja vu?\"&#125; 自定义分析器12345678910111213141516171819202122232425PUT my_index&#123; \"settings\": &#123; \"analysis\": &#123; \"analyzer\": &#123; \"std_folded\": &#123; \"type\": \"custom\", \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"asciifolding\" ] &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"properties\": &#123; \"my_text\": &#123; \"type\": \"text\", \"analyzer\": \"std_folded\" &#125; &#125; &#125;&#125; 对文本执行分析过程，并返回文本的标记明细12345GET my_index/_analyze&#123; \"analyzer\": \"std_folded\", \"text\": \"Is this déjà vu?\"&#125; 12345GET my_index/_analyze&#123; \"field\": \"my_text\", \"text\": \"Is this déjà vu?\"&#125; 6.1 Analyzerhtml 剥离123456POST _analyze&#123; \"tokenizer\":\"keyword\", \"char_filter\":[\"html_strip\"], \"text\": \"&lt;b&gt;hello world&lt;/b&gt;\"&#125; 路径级别12345POST _analyze&#123; \"tokenizer\":\"path_hierarchy\", \"text\":\"/user/ymruan/a/b/c/d/e\"&#125; 使用 char filter 进行替换1234567891011POST _analyze&#123; \"tokenizer\": \"standard\", \"char_filter\": [ &#123; \"type\" : \"mapping\", \"mappings\" : [ \"- =&gt; _\"] &#125; ], \"text\": \"123-456, I-test! test-990 650-555-1234\"&#125; char filter 替换表情符号1234567891011POST _analyze&#123; \"tokenizer\": \"standard\", \"char_filter\": [ &#123; \"type\" : \"mapping\", \"mappings\" : [ \":) =&gt; happy\", \":( =&gt; sad\"] &#125; ], \"text\": [\"I am felling :)\", \"Feeling :( today\"]&#125; 按空格分词并过滤停止词和复数转单数等处理123456GET _analyze&#123; \"tokenizer\": \"whitespace\", \"filter\": [\"stop\",\"snowball\"], \"text\": [\"The gilrs in China are playing this game!\"]&#125; 先转小写123456GET _analyze&#123; \"tokenizer\": \"whitespace\", \"filter\": [\"lowercase\",\"stop\",\"snowball\"], \"text\": [\"The gilrs in China are playing this game!\"]&#125; 正则表达式123456789101112GET _analyze&#123; \"tokenizer\": \"standard\", \"char_filter\": [ &#123; \"type\" : \"pattern_replace\", \"pattern\" : \"http://(.*)\", \"replacement\" : \"$1\" &#125; ], \"text\" : \"http://www.elastic.co\"&#125; 7 Query DSLignore_unavailable=true，可以忽略尝试访问不存在的索引“404_idx”导致的报错1234567POST /movies,404_idx/_search?ignore_unavailable=true&#123; \"profile\": true, \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 查询 movies 分页12345678POST /kibana_sample_data_ecommerce/_search&#123; \"from\":10, \"size\":1, \"query\":&#123; \"match_all\": &#123;&#125; &#125;&#125; 对日期排序1234567POST kibana_sample_data_ecommerce/_search&#123; \"sort\":[&#123;\"order_date\":\"desc\"&#125;], \"query\":&#123; \"match_all\": &#123;&#125; &#125;&#125; source 过滤1234567POST kibana_sample_data_ecommerce/_search&#123; \"_source\":[\"order_date\"], \"query\":&#123; \"match_all\": &#123;&#125; &#125;&#125; 脚本字段（可以用于排序）1234567891011121314GET kibana_sample_data_ecommerce/_search&#123; \"script_fields\": &#123; \"new_field\": &#123; \"script\": &#123; \"lang\": \"painless\", \"source\": \"doc['order_date'].value+'hello'\" &#125; &#125; &#125;, \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 或查询（匹配其中一个单词即可）12345678POST movies/_search&#123; \"query\": &#123; \"match\": &#123; \"title\": \"last christmas\" &#125; &#125;&#125; 并查询（匹配所有单词）1234567891011POST movies/_search&#123; \"query\": &#123; \"match\": &#123; \"title\": &#123; \"query\": \"last christmas\", \"operator\": \"and\" &#125; &#125; &#125;&#125; 短语查询，必须匹配12345678910POST movies/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"title\":&#123; \"query\": \"One Love\" &#125; &#125; &#125;&#125; 短语查询，中间可以插值1234567891011POST movies/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"title\":&#123; \"query\": \"one love\", \"slop\": 1 &#125; &#125; &#125;&#125; 7.1 Query string query添加文档1234567891011PUT /users/_doc/1&#123; \"name\":\"Ruan Yiming\", \"about\":\"java, golang, node, swift, elasticsearch\"&#125;PUT /users/_doc/2&#123; \"name\":\"Li Yiming\", \"about\":\"Hadoop\"&#125; 并查询123456789POST users/_search&#123; \"query\": &#123; \"query_string\": &#123; \"default_field\": \"name\", \"query\": \"Ruan AND Yiming\" &#125; &#125;&#125; 或和并查询123456789POST users/_search&#123; \"query\": &#123; \"query_string\": &#123; \"fields\":[\"name\",\"about\"], \"query\": \"(Ruan AND Yiming) OR (Java AND Elasticsearch)\" &#125; &#125;&#125; Simple Query 默认的 operator 是 Or123456789POST users/_search&#123; \"query\": &#123; \"simple_query_string\": &#123; \"query\": \"Ruan AND Yiming\", \"fields\": [\"name\"] &#125; &#125;&#125; Simple Query 指定操作类型12345678910POST users/_search&#123; \"query\": &#123; \"simple_query_string\": &#123; \"query\": \"Ruan Yiming\", \"fields\": [\"name\"], \"default_operator\": \"AND\" &#125; &#125;&#125; 单字段查询1234567891011GET /movies/_search&#123; \"profile\": true, \"query\":&#123; \"query_string\":&#123; \"default_field\": \"title\", \"query\": \"Beafiful AND Mind\" &#125; &#125;&#125;` 多字段查询12345678910111213GET /movies/_search&#123; \"profile\": true, \"query\":&#123; \"query_string\":&#123; \"fields\":[ \"title\", \"year\" ], \"query\": \"2012\" &#125; &#125;&#125; 8 MappingMapping 中的字段一旦设定后，禁止直接修改。因为倒排索引生成后不允许直接修改。需要重新建立新的索引，做 reindex 操作。 类似数据库中的表结构定义，主要作用 定义字段名字 定义字段的类型 定义倒排索引相关的配置（是否被索引？采用的 Analyzer） 对新增字段的处理 true false strict 在 object 下，支持做 dynamic 的属性的定义 8.1 Dynamic Mapping写入文档，查看 Mapping123456PUT mapping_test/_doc/1&#123; \"firstName\":\"Chan\", \"lastName\": \"Jackie\", \"loginDate\":\"2018-07-24T10:29:48.103Z\"&#125; 查看 Mapping 文件1GET mapping_test/_mapping Delete index1DELETE mapping_test dynamic mapping，推断字段的类型12345678PUT mapping_test/_doc/1&#123; \"uid\" : \"123\", \"isVip\" : false, \"isAdmin\": \"true\", \"age\":19, \"heigh\":180&#125; 查看 Dynamic1GET mapping_test/_mapping 默认 Mapping 支持 dynamic，写入的文档中加入新的字段1234PUT dynamic_mapping_test/_doc/1&#123; \"newField\":\"someValue\"&#125; 该字段可以被搜索，数据也在 _source 中出现12345678POST dynamic_mapping_test/_search&#123; \"query\":&#123; \"match\":&#123; \"newField\":\"someValue\" &#125; &#125;&#125; 改为 dynamic false1234PUT dynamic_mapping_test/_mapping&#123; \"dynamic\": false&#125; 新增 anotherField1234PUT dynamic_mapping_test/_doc/10&#123; \"anotherField\":\"someValue\"&#125; 该字段不可以被搜索，因为 dynamic 已经被设置为 false12345678POST dynamic_mapping_test/_search&#123; \"query\":&#123; \"match\":&#123; \"anotherField\":\"someValue\" &#125; &#125;&#125; 获取文档1GET dynamic_mapping_test/_doc/10 修改为 strict1234PUT dynamic_mapping_test/_mapping&#123; \"dynamic\": \"strict\"&#125; 写入数据出错，HTTP Code 4001234PUT dynamic_mapping_test/_doc/12&#123; \"lastField\":\"value\"&#125; 删除索引1DELETE dynamic_mapping_test 8.2 Mapping 定义设置 index 为 false123456789101112131415161718DELETE usersPUT users&#123; \"mappings\" : &#123; \"properties\" : &#123; \"firstName\" : &#123; \"type\" : \"text\" &#125;, \"lastName\" : &#123; \"type\" : \"text\" &#125;, \"mobile\" : &#123; \"type\" : \"text\", \"index\": false &#125; &#125; &#125;&#125; 添加文档123456PUT users/_doc/1&#123; \"firstName\":\"Ruan\", \"lastName\": \"Yiming\", \"mobile\": \"12345678\"&#125; 根据手机号查询，报错，因为没有被索引12345678POST /users/_search&#123; \"query\": &#123; \"match\": &#123; \"mobile\":\"12345678\" &#125; &#125;&#125; 设定 Null_value12345678910111213141516171819DELETE usersPUT users&#123; \"mappings\" : &#123; \"properties\" : &#123; \"firstName\" : &#123; \"type\" : \"text\" &#125;, \"lastName\" : &#123; \"type\" : \"text\" &#125;, \"mobile\" : &#123; \"type\" : \"keyword\", \"null_value\": \"NULL\" &#125; &#125; &#125;&#125; 添加文档12345678910111213PUT users/_doc/1&#123; \"firstName\":\"Ruan\", \"lastName\": \"Yiming\", \"mobile\": null&#125;PUT users/_doc/2&#123; \"firstName\":\"Ruan2\", \"lastName\": \"Yiming2\"&#125; 根据手机号查询12345678GET users/_search&#123; \"query\": &#123; \"match\": &#123; \"mobile\":\"NULL\" &#125; &#125;&#125; 9 Index Templates默认情况下，数字字符串被映射成 text 类型，日期字符串被映射成日期类型123456PUT ttemplate/_doc/1&#123; \"someNumber\":\"1\", \"someDate\":\"2019/01/01\"&#125;GET ttemplate/_mapping 创建 template_test12345678910111213PUT /_template/template_test&#123; \"index_patterns\" : [\"test*\"], \"order\" : 1, \"settings\" : &#123; \"number_of_shards\": 1, \"number_of_replicas\" : 2 &#125;, \"mappings\" : &#123; \"date_detection\": false, \"numeric_detection\": true &#125;&#125; 查看 template 信息1GET /_template/temp* 写入新的数据，index 以 test 开头12345PUT testtemplate/_doc/1&#123; \"someNumber\":\"1\", \"someDate\":\"2019/01/01\"&#125; 查看 testtemplate 信息12GET testtemplate/_mappingGET testtemplate/_settings 使用动态模板123456789101112131415161718192021222324PUT my_index&#123; \"mappings\": &#123; \"dynamic_templates\": [ &#123; \"strings_as_boolean\": &#123; \"match_mapping_type\": \"string\", \"match\":\"is*\", \"mapping\": &#123; \"type\": \"boolean\" &#125; &#125; &#125;, &#123; \"strings_as_keywords\": &#123; \"match_mapping_type\": \"string\", \"mapping\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; ] &#125;&#125; 查看 GET my_index/_mapping 信息1GET my_index/_mapping 使用动态模板，结合路径123456789101112131415161718192021222324252627282930DELETE my_indexPUT my_index&#123; \"mappings\": &#123; \"dynamic_templates\": [ &#123; \"full_name\": &#123; \"path_match\": \"name.*\", \"path_unmatch\": \"*.middle\", \"mapping\": &#123; \"type\": \"text\", \"copy_to\": \"full_name\" &#125; &#125; &#125; ] &#125;&#125;PUT my_index/_doc/1&#123; \"name\": &#123; \"first\": \"John\", \"middle\": \"Winston\", \"last\": \"Lennon\" &#125;&#125;GET my_index/_search?q=full_name:John 10 Aggregations按照目的地进行分桶统计1234567891011GET kibana_sample_data_flights/_search&#123; \"size\": 0, \"aggs\":&#123; \"flight_dest\":&#123; \"terms\":&#123; \"field\":\"DestCountry\" &#125; &#125; &#125;&#125; 查看航班目的地的统计信息，增加平均，最高最低价格12345678910111213141516171819202122232425262728GET kibana_sample_data_flights/_search&#123; \"size\": 0, \"aggs\":&#123; \"flight_dest\":&#123; \"terms\":&#123; \"field\":\"DestCountry\" &#125;, \"aggs\":&#123; \"avg_price\":&#123; \"avg\":&#123; \"field\":\"AvgTicketPrice\" &#125; &#125;, \"max_price\":&#123; \"max\":&#123; \"field\":\"AvgTicketPrice\" &#125; &#125;, \"min_price\":&#123; \"min\":&#123; \"field\":\"AvgTicketPrice\" &#125; &#125; &#125; &#125; &#125;&#125; 价格统计信息+天气信息12345678910111213141516171819202122232425GET kibana_sample_data_flights/_search&#123; \"size\": 0, \"aggs\":&#123; \"flight_dest\":&#123; \"terms\":&#123; \"field\":\"DestCountry\" &#125;, \"aggs\":&#123; \"stats_price\":&#123; \"stats\":&#123; \"field\":\"AvgTicketPrice\" &#125; &#125;, \"wather\":&#123; \"terms\": &#123; \"field\": \"DestWeather\", \"size\": 5 &#125; &#125; &#125; &#125; &#125;&#125; 11 案例11.1 Term 查询数据准备12345678910111213141516171819DELETE productsPUT products&#123; \"settings\": &#123; \"number_of_shards\": 1 &#125;&#125;POST /products/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"productID\" : \"XHDK-A-1293-#fJ3\",\"desc\":\"iPhone\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"productID\" : \"KDKE-B-9947-#kL5\",\"desc\":\"iPad\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"productID\" : \"JODL-X-1937-#pV7\",\"desc\":\"MBP\" &#125;GET /productsGET /products/_mapping 查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647POST /products/_search&#123; \"query\": &#123; \"term\": &#123; \"desc\": &#123; //\"value\": \"iPhone\" \"value\":\"iphone\" &#125; &#125; &#125;&#125;POST /products/_search&#123; \"query\": &#123; \"term\": &#123; \"desc.keyword\": &#123; //\"value\": \"iPhone\" \"value\":\"iphone\" &#125; &#125; &#125;&#125;POST /products/_search&#123; \"query\": &#123; \"term\": &#123; \"productID\": &#123; \"value\": \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125;&#125;POST /products/_search&#123; \"explain\": true, \"query\": &#123; \"term\": &#123; \"productID.keyword\": &#123; \"value\": \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125;&#125; 跳过算分，提高查询效率12345678910111213POST /products/_search&#123; \"explain\": true, \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"term\": &#123; \"productID.keyword\": \"XHDK-A-1293-#fJ3\" &#125; &#125; &#125; &#125;&#125; 11.2 全文查询参考博客 https://blog.csdn.net/chuan442616909/article/details/56664861 设置 position_increment_gap，解决数组查询问题1234567891011121314151617181920212223242526272829303132333435363738394041DELETE groupsPUT groups&#123; \"mappings\": &#123; \"properties\": &#123; \"names\":&#123; \"type\": \"text\", \"position_increment_gap\": 0 &#125; &#125; &#125;&#125;GET groups/_mappingPOST groups/_doc&#123; \"names\": [ \"John Water\", \"Water Smith\"]&#125;POST groups/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"names\": &#123; \"query\": \"Water Water\", \"slop\": 100 &#125; &#125; &#125;&#125;POST groups/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"names\": \"Water Smith\" &#125; &#125;&#125; 11.3 结构化查询数据准备123456789101112DELETE productsPOST /products/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"price\" : 10,\"avaliable\":true,\"date\":\"2018-01-01\", \"productID\" : \"XHDK-A-1293-#fJ3\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"price\" : 20,\"avaliable\":true,\"date\":\"2019-01-01\", \"productID\" : \"KDKE-B-9947-#kL5\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":true, \"productID\" : \"JODL-X-1937-#pV7\" &#125;&#123; \"index\": &#123; \"_id\": 4 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":false, \"productID\" : \"QQPX-R-3956-#aD8\" &#125;GET products/_mapping 对布尔值 match 查询，有算分12345678910POST products/_search&#123; \"profile\": \"true\", \"explain\": true, \"query\": &#123; \"term\": &#123; \"avaliable\": true &#125; &#125;&#125; 对布尔值，通过 constant score 转成 filtering，没有算分1234567891011121314POST products/_search&#123; \"profile\": \"true\", \"explain\": true, \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"term\": &#123; \"avaliable\": true &#125; &#125; &#125; &#125;&#125; 数字类型 Term 精确查询12345678910POST products/_search&#123; \"profile\": \"true\", \"explain\": true, \"query\": &#123; \"term\": &#123; \"price\": 30 &#125; &#125;&#125; 数字类型 terms 精确查询123456789101112131415POST products/_search&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"terms\": &#123; \"price\": [ \"20\", \"30\" ] &#125; &#125; &#125; &#125;&#125; 数字 Range 查询123456789101112131415GET products/_search&#123; \"query\" : &#123; \"constant_score\" : &#123; \"filter\" : &#123; \"range\" : &#123; \"price\" : &#123; \"gte\" : 20, \"lte\" : 30 &#125; &#125; &#125; &#125; &#125;&#125; 日期 range，大于或等于现在减一年1234567891011121314POST products/_search&#123; \"query\" : &#123; \"constant_score\" : &#123; \"filter\" : &#123; \"range\" : &#123; \"date\" : &#123; \"gte\" : \"now-1y\" &#125; &#125; &#125; &#125; &#125;&#125; 文档是否存在字段查询123456789101112POST products/_search&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"exists\": &#123; \"field\": \"date\" &#125; &#125; &#125; &#125;&#125; 多值字段查询数据准备12345POST /movies/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"title\" : \"Father of the Bridge Part II\",\"year\":1995, \"genre\":\"Comedy\"&#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"title\" : \"Dave\",\"year\":1993,\"genre\":[\"Comedy\",\"Romance\"] &#125; 处理多值字段，term 查询是包含，而不是等于123456789101112POST movies/_search&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"term\": &#123; \"genre.keyword\": \"Comedy\" &#125; &#125; &#125; &#125;&#125; 字符类型 terms123456789101112131415POST products/_search&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"terms\": &#123; \"productID.keyword\": [ \"QQPX-R-3956-#aD8\", \"JODL-X-1937-#pV7\" ] &#125; &#125; &#125; &#125;&#125; 根据布尔数值进行算分123456789101112POST products/_search&#123; \"query\": &#123; \"constant_score\": &#123; \"filter\": &#123; \"term\": &#123; \"avaliable\": \"false\" &#125; &#125; &#125; &#125;&#125; 11.4 相关性算分查询参数 boost 的含义 当 boost &gt; 1 时，打分的相关度相对性提升 当 0 &lt; boost &lt; 1 时，打分的权重相对性降低 当 boost &lt; 0 时，贡献负分 数据准备1234567891011121314151617181920212223PUT testscore&#123; \"settings\": &#123; \"number_of_shards\": 1 &#125;, \"mappings\": &#123; \"properties\": &#123; \"content\": &#123; \"type\": \"text\" &#125; &#125; &#125;&#125;PUT testscore/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"content\":\"we use Elasticsearch to power the search\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"content\":\"we like elasticsearch\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"content\":\"The scoring of documents is caculated by the scoring formula\" &#125;&#123; \"index\": &#123; \"_id\": 4 &#125;&#125;&#123; \"content\":\"you know, for search\" &#125; 查询123456789101112131415161718POST testscore/_search&#123; \"query\": &#123; \"boosting\" : &#123; \"positive\" : &#123; \"term\" : &#123; \"content\" : \"elasticsearch\" &#125; &#125;, \"negative\" : &#123; \"term\" : &#123; \"content\" : \"like\" &#125; &#125;, \"negative_boost\" : 0.2 &#125; &#125;&#125; 11.5 复合查询123456789POST /products/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"price\" : 10,\"avaliable\":true,\"date\":\"2018-01-01\", \"productID\" : \"XHDK-A-1293-#fJ3\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"price\" : 20,\"avaliable\":true,\"date\":\"2019-01-01\", \"productID\" : \"KDKE-B-9947-#kL5\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":true, \"productID\" : \"JODL-X-1937-#pV7\" &#125;&#123; \"index\": &#123; \"_id\": 4 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":false, \"productID\" : \"QQPX-R-3956-#aD8\" &#125; 基本语法1234567891011121314151617181920212223POST /products/_search&#123; \"query\": &#123; \"bool\" : &#123; \"must\" : &#123; \"term\" : &#123; \"price\" : \"30\" &#125; &#125;, \"filter\": &#123; \"term\" : &#123; \"avaliable\" : \"true\" &#125; &#125;, \"must_not\" : &#123; \"range\" : &#123; \"price\" : &#123; \"lte\" : 10 &#125; &#125; &#125;, \"should\" : [ &#123; \"term\" : &#123; \"productID.keyword\" : \"JODL-X-1937-#pV7\" &#125; &#125;, &#123; \"term\" : &#123; \"productID.keyword\" : \"XHDK-A-1293-#fJ3\" &#125; &#125; ], \"minimum_should_match\" :1 &#125; &#125;&#125; 改变数据模型，增加字段。解决数组包含而不是精确匹配的问题12345POST /newmovies/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"title\" : \"Father of the Bridge Part II\",\"year\":1995, \"genre\":\"Comedy\",\"genre_count\":1 &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"title\" : \"Dave\",\"year\":1993,\"genre\":[\"Comedy\",\"Romance\"],\"genre_count\":2 &#125; must，有算分123456789101112POST /newmovies/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123;\"term\": &#123;\"genre.keyword\": &#123;\"value\": \"Comedy\"&#125;&#125;&#125;, &#123;\"term\": &#123;\"genre_count\": &#123;\"value\": 1&#125;&#125;&#125; ] &#125; &#125;&#125; Filter。不参与算分，结果的score是0123456789101112POST /newmovies/_search&#123; \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123;\"term\": &#123;\"genre.keyword\": &#123;\"value\": \"Comedy\"&#125;&#125;&#125;, &#123;\"term\": &#123;\"genre_count\": &#123;\"value\": 1&#125;&#125;&#125; ] &#125; &#125;&#125; Filtering Context12345678910111213141516POST _search&#123; \"query\": &#123; \"bool\" : &#123; \"filter\": &#123; \"term\" : &#123; \"avaliable\" : \"true\" &#125; &#125;, \"must_not\" : &#123; \"range\" : &#123; \"price\" : &#123; \"lte\" : 10 &#125; &#125; &#125; &#125; &#125;&#125; Query Context1234567891011121314151617181920212223242526POST /products/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"price\" : 10,\"avaliable\":true,\"date\":\"2018-01-01\", \"productID\" : \"XHDK-A-1293-#fJ3\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"price\" : 20,\"avaliable\":true,\"date\":\"2019-01-01\", \"productID\" : \"KDKE-B-9947-#kL5\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":true, \"productID\" : \"JODL-X-1937-#pV7\" &#125;&#123; \"index\": &#123; \"_id\": 4 &#125;&#125;&#123; \"price\" : 30,\"avaliable\":false, \"productID\" : \"QQPX-R-3956-#aD8\" &#125;POST /products/_search&#123; \"query\": &#123; \"bool\": &#123; \"should\": [ &#123; \"term\": &#123; \"productID.keyword\": &#123; \"value\": \"JODL-X-1937-#pV7\"&#125;&#125; &#125;, &#123;\"term\": &#123;\"avaliable\": &#123;\"value\": true&#125;&#125; &#125; ] &#125; &#125;&#125; 嵌套，实现了 should not 逻辑123456789101112131415161718192021222324POST /products/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": &#123; \"term\": &#123; \"price\": \"30\" &#125; &#125;, \"should\": [ &#123; \"bool\": &#123; \"must_not\": &#123; \"term\": &#123; \"avaliable\": \"false\" &#125; &#125; &#125; &#125; ], \"minimum_should_match\": 1 &#125; &#125;&#125; Controll the Precision1234567891011121314151617181920212223POST _search&#123; \"query\": &#123; \"bool\" : &#123; \"must\" : &#123; \"term\" : &#123; \"price\" : \"30\" &#125; &#125;, \"filter\": &#123; \"term\" : &#123; \"avaliable\" : \"true\" &#125; &#125;, \"must_not\" : &#123; \"range\" : &#123; \"price\" : &#123; \"lte\" : 10 &#125; &#125; &#125;, \"should\" : [ &#123; \"term\" : &#123; \"productID.keyword\" : \"JODL-X-1937-#pV7\" &#125; &#125;, &#123; \"term\" : &#123; \"productID.keyword\" : \"XHDK-A-1293-#fJ3\" &#125; &#125; ], \"minimum_should_match\" :2 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081DELETE blogsPOST /blogs/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123;\"title\":\"Apple iPad\", \"content\":\"Apple iPad,Apple iPad\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123;\"title\":\"Apple iPad,Apple iPad\", \"content\":\"Apple iPad\" &#125;POST blogs/_search&#123; \"query\": &#123; \"bool\": &#123; \"should\": [ &#123;\"match\": &#123; \"title\": &#123; \"query\": \"apple,ipad\", \"boost\": 1.1 &#125; &#125;&#125;, &#123;\"match\": &#123; \"content\": &#123; \"query\": \"apple,ipad\", \"boost\": 2 &#125; &#125;&#125; ] &#125; &#125;&#125;DELETE newsPOST /news/_bulk&#123; \"index\": &#123; \"_id\": 1 &#125;&#125;&#123; \"content\":\"Apple Mac\" &#125;&#123; \"index\": &#123; \"_id\": 2 &#125;&#125;&#123; \"content\":\"Apple iPad\" &#125;&#123; \"index\": &#123; \"_id\": 3 &#125;&#125;&#123; \"content\":\"Apple employee like Apple Pie and Apple Juice\" &#125;POST news/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": &#123; \"match\":&#123;\"content\":\"apple\"&#125; &#125; &#125; &#125;&#125;POST news/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": &#123; \"match\":&#123;\"content\":\"apple\"&#125; &#125;, \"must_not\": &#123; \"match\":&#123;\"content\":\"pie\"&#125; &#125; &#125; &#125;&#125;POST news/_search&#123; \"query\": &#123; \"boosting\": &#123; \"positive\": &#123; \"match\": &#123; \"content\": \"apple\" &#125; &#125;, \"negative\": &#123; \"match\": &#123; \"content\": \"pie\" &#125; &#125;, \"negative_boost\": 0.5 &#125; &#125;&#125; 11.6 Disjunction Max Query将任何与任一查询匹配的文档作为结果返回。采用字段上最匹配的评分最终评分返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061PUT /blogs/_doc/1&#123; \"title\": \"Quick brown rabbits\", \"body\": \"Brown rabbits are commonly seen.\"&#125;PUT /blogs/_doc/2&#123; \"title\": \"Keeping pets healthy\", \"body\": \"My quick brown fox eats rabbits on a regular basis.\"&#125;POST /blogs/_search&#123; \"query\": &#123; \"bool\": &#123; \"should\": [ &#123; \"match\": &#123; \"title\": \"Brown fox\" &#125;&#125;, &#123; \"match\": &#123; \"body\": \"Brown fox\" &#125;&#125; ] &#125; &#125;&#125;POST blogs/_search&#123; \"query\": &#123; \"dis_max\": &#123; \"queries\": [ &#123; \"match\": &#123; \"title\": \"Brown fox\" &#125;&#125;, &#123; \"match\": &#123; \"body\": \"Brown fox\" &#125;&#125; ] &#125; &#125;&#125;POST blogs/_search&#123; \"query\": &#123; \"dis_max\": &#123; \"queries\": [ &#123; \"match\": &#123; \"title\": \"Quick pets\" &#125;&#125;, &#123; \"match\": &#123; \"body\": \"Quick pets\" &#125;&#125; ] &#125; &#125;&#125;POST blogs/_search&#123; \"query\": &#123; \"dis_max\": &#123; \"queries\": [ &#123; \"match\": &#123; \"title\": \"Quick pets\" &#125;&#125;, &#123; \"match\": &#123; \"body\": \"Quick pets\" &#125;&#125; ], \"tie_breaker\": 0.2 &#125; &#125;&#125; 11.7 Multi Match11.8 Function Score Query123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110DELETE blogsPUT /blogs/_doc/1&#123; \"title\": \"About popularity\", \"content\": \"In this post we will talk about...\", \"votes\": 0&#125;PUT /blogs/_doc/2&#123; \"title\": \"About popularity\", \"content\": \"In this post we will talk about...\", \"votes\": 100&#125;PUT /blogs/_doc/3&#123; \"title\": \"About popularity\", \"content\": \"In this post we will talk about...\", \"votes\": 1000000&#125;POST /blogs/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"popularity\", \"fields\": [ \"title\", \"content\" ] &#125; &#125;, \"field_value_factor\": &#123; \"field\": \"votes\" &#125; &#125; &#125;&#125;POST /blogs/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"popularity\", \"fields\": [ \"title\", \"content\" ] &#125; &#125;, \"field_value_factor\": &#123; \"field\": \"votes\", \"modifier\": \"log1p\" &#125; &#125; &#125;&#125;POST /blogs/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"popularity\", \"fields\": [ \"title\", \"content\" ] &#125; &#125;, \"field_value_factor\": &#123; \"field\": \"votes\", \"modifier\": \"log1p\" , \"factor\": 0.1 &#125; &#125; &#125;&#125;POST /blogs/_search&#123; \"query\": &#123; \"function_score\": &#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"popularity\", \"fields\": [ \"title\", \"content\" ] &#125; &#125;, \"field_value_factor\": &#123; \"field\": \"votes\", \"modifier\": \"log1p\" , \"factor\": 0.1 &#125;, \"boost_mode\": \"sum\", \"max_boost\": 3 &#125; &#125;&#125;POST /blogs/_search&#123; \"query\": &#123; \"function_score\": &#123; \"random_score\": &#123; \"seed\": 911119 &#125; &#125; &#125;&#125; 12 Aliases数据准备1234567891011PUT movies-2019/_doc/1&#123; \"name\":\"the matrix\", \"rating\":5&#125;PUT movies-2019/_doc/2&#123; \"name\":\"Speed\", \"rating\":3&#125; 设置索引的别名123456789101112131415161718192021222324252627282930POST _aliases&#123; \"actions\": [ &#123; \"add\": &#123; \"index\": \"movies-2019\", \"alias\": \"movies-latest\" &#125; &#125; ]&#125;POST _aliases&#123; \"actions\": [ &#123; \"add\": &#123; \"index\": \"movies-2019\", \"alias\": \"movies-lastest-highrate\", \"filter\": &#123; \"range\": &#123; \"rating\": &#123; \"gte\": 4 &#125; &#125; &#125; &#125; &#125; ]&#125; 根据别名查询12345678910111213POST movies-latest/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;POST movies-lastest-highrate/_search&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125; 13 Scripting使用场景：在开发初期，虽然可以明确查询参数，但是往往还不不能最终定义查询的 DSL 的具体结构。 定义查询模板123456789101112131415161718POST _scripts/tmdb&#123; \"script\": &#123; \"lang\": \"mustache\", \"source\": &#123; \"_source\": [ \"title\",\"overview\" ], \"size\": 20, \"query\": &#123; \"multi_match\": &#123; \"query\": \"&#123;&#123;q&#125;&#125;\", \"fields\": [\"title\",\"overview\"] &#125; &#125; &#125; &#125;&#125; 使用查询模板查询1234567POST tmdb/_search/template&#123; \"id\":\"tmdb\", \"params\": &#123; \"q\": \"basketball with cartoon aliens\" &#125;&#125;","categories":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://zhechu.github.io/tags/搜索/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}]},{"title":"结构型-装饰模式","slug":"结构型-装饰模式","date":"2019-09-23T15:39:10.000Z","updated":"2020-11-03T13:04:34.289Z","comments":false,"path":"2019/09/23/结构型-装饰模式/","link":"","permalink":"https://zhechu.github.io/2019/09/23/结构型-装饰模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/decorator 1 定义动态地给对象添加额外的职责。本质是增强功能，动态组合。 2 结构 角色 说明 Component 组件对象接口 ConcreteComponent 组件对象的实现，是被装饰器装饰的原始对象 Decorator 装饰器的抽象父类，需定义一个与组件接口一致的接口，并持有一个被装饰的对象 ConcreteDecorator 装饰器对象的实现 3 优缺点优点 比继承更灵活 更容易复用功能 简化高层定义 缺点 可能会产生很多细粒度的对象 4 使用场景 需动态、透明地给对象添加职责 不适合使用子类扩展时 5 示例5.1 订单价格计算需求：实现灵活的订单价格计算功能，可支持优惠券和红包优惠方式。 TIPS：查看示例代码请点开文链接进去。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"创建型-原型模式","slug":"创建型-原型模式","date":"2019-09-22T14:13:13.000Z","updated":"2020-11-03T13:04:34.280Z","comments":false,"path":"2019/09/22/创建型-原型模式/","link":"","permalink":"https://zhechu.github.io/2019/09/22/创建型-原型模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/prototype 1 定义用原型实例指定创建对象的种类，并通过复制其原型创建新的对象。本质是克隆生成对象。 2 结构 角色 说明 Prototype 声明一个克隆自身的接口，用于约束克隆自身的类，要求它们都要实现原型接口定义的克隆方法 ConcretePrototype 实现 Prototype 接口的类 浅度克隆：只负责克隆按值传递的数据。 深度克隆：既克隆按值传递的数据，也克隆引用类型的数据（有可能需要递归克隆）。 3 优缺点优点 对客户端隐藏具体的实现类型 在运行时动态改变具体的实现类型 缺点 难以实现深度克隆 4 使用场景 新的对象实例需要复用已存在的实例部分或全部属性时，可以使用原型模式 5 示例5.1 拆分订单需求：若订单的预订产品超过1000，则需要拆分订单 结构图 客户端12345678910111213141516public class OrderClient &#123; public static void main(String[] args) &#123; // 创建订单对象 PersonalOrder op = new PersonalOrder(); // 设置订单数据 op.setOrderProductNum(3925); op.setCustomerName(\"张三\"); op.setProductId(\"P0001\"); OrderBusiness ob = new OrderBusiness(); // 调用业务服务保存订单对象 ob.saveOrder(op); &#125;&#125; 处理订单业务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.List;/** * 处理订单业务 */public class OrderBusiness &#123; /** * 创建订单 * @param order 订单对象 */ public void saveOrder(OrderApi order) &#123; List&lt;OrderApi&gt; orderList = new ArrayList&lt;&gt;(); // 根据业务需求，当订单的预定的产品数量超过1000的时，则将订单拆成两份订单 // 判断当前的预定产品数量是否大于1000 OrderApi newOrder = null; while(order.getOrderProductNum() &gt; 1000)&#123; // 新建一份订单，跟传入的订单除了数量不一样外，其他都相同 try &#123; newOrder = order.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; // 然后进行赋值，产品数量为1000 newOrder.setOrderProductNum(1000); // 原来的订单保留，把数量设置成减少1000 order.setOrderProductNum(order.getOrderProductNum() - 1000); // 先存储，然后统一处理 orderList.add(newOrder); System.out.println(\"拆分生成订单==\" + newOrder); &#125; // 先存储，然后统一处理 orderList.add(order); System.out.println(\"原订单==\" + order); orderList.forEach(o -&gt; &#123; // hashCode 不一样，表示对象不一样 System.out.println(o.hashCode()); // 业务处理 // TODO &#125;); &#125;&#125; 订单接口12345678910111213141516171819202122232425/** * 订单接口，声明了可以克隆自身的方法 */public interface OrderApi extends Cloneable &#123; /** * 获取订单产品数量 * @return 订单中产品数量 */ int getOrderProductNum(); /** * 设置订单产品数量 * @param num 订单产品数量 */ void setOrderProductNum(int num); /** * 将 Object 的方法修饰符改为 public，允许外界访问 * @return * @throws CloneNotSupportedException */ OrderApi clone() throws CloneNotSupportedException;&#125; 个人订单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 个人订单 */public class PersonalOrder implements OrderApi&#123; /** * 订购人员姓名 */ private String customerName; /** * 产品编号 */ private String productId; /** * 订单产品数量 */ private int orderProductNum; @Override public int getOrderProductNum() &#123; return this.orderProductNum; &#125; @Override public void setOrderProductNum(int num) &#123; this.orderProductNum = num; &#125; public String getCustomerName() &#123; return customerName; &#125; public void setCustomerName(String customerName) &#123; this.customerName = customerName; &#125; public String getProductId() &#123; return productId; &#125; public void setProductId(String productId) &#123; this.productId = productId; &#125; @Override public String toString()&#123; return \"本个人订单的订购人是=\"+this.customerName+\"，订购产品是=\"+this.productId+\"，订购数量为=\"+this.orderProductNum; &#125; @Override public OrderApi clone() throws CloneNotSupportedException &#123; return (OrderApi) super.clone(); &#125;&#125; 企业订单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 企业订单 */public class EnterpriseOrder implements OrderApi &#123; /** * 企业名称 */ private String enterpriseName; /** * 产品编号 */ private String productId; /** * 订单产品数量 */ private int orderProductNum; @Override public int getOrderProductNum() &#123; return this.orderProductNum; &#125; @Override public void setOrderProductNum(int num) &#123; this.orderProductNum = num; &#125; public String getEnterpriseName() &#123; return enterpriseName; &#125; public void setEnterpriseName(String enterpriseName) &#123; this.enterpriseName = enterpriseName; &#125; public String getProductId() &#123; return productId; &#125; public void setProductId(String productId) &#123; this.productId = productId; &#125; @Override public String toString()&#123; return \"本企业订单的订购企业是=\" + this.enterpriseName + \"，订购产品是=\" + this.productId + \"，订购数量为=\" + this.orderProductNum; &#125; @Override public OrderApi clone() throws CloneNotSupportedException &#123; return (OrderApi) super.clone(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java开发环境搭建","slug":"Java开发环境搭建","date":"2019-09-21T13:29:37.000Z","updated":"2020-11-03T13:04:34.155Z","comments":false,"path":"2019/09/21/Java开发环境搭建/","link":"","permalink":"https://zhechu.github.io/2019/09/21/Java开发环境搭建/","excerpt":"","text":"前言：只是为了加快开发环境的搭建！ 环境说明 环境 说明 Windows7 操作系统 1 JDK1.8 环境变量设置JDK1.8 绿色版 百度网盘：https://pan.baidu.com/s/1h1T6leJIYR1H5vFbUq6uYA 提取码：dudq 变量 值 JAVA_HOME D:\\mywork\\java\\jdk1.8.0_45_64bit CLASSPATH .;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; Path %JAVA_HOME\\bin%;%JAVA_HOME%\\jre\\bin; 2 Maven 环境变量设置apache-maven-3.3.9 百度网盘：https://pan.baidu.com/s/1a4lSU6SrNsp6mjINv-0XyA 提取码：o66m 变量 值 MAVEN_HOME D:\\mywork\\java\\apache-maven-3.3.9 Path %MAVEN_HOME%\\bin; settings.xml 配置阿里云地址123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;D:\\mywork\\maven_repository&lt;/localRepository&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;servers&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-wisehoe&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus wisehoe&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt;&lt;/settings&gt; settings.xml 复杂配置示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;D:\\mywork\\maven_repository&lt;/localRepository&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;proxies&gt; &lt;/proxies&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;public&lt;/id&gt; &lt;username&gt;dev&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;dev&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;dev&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus Mirror.&lt;/name&gt; &lt;url&gt;http://192.168.30.58:8081/repository/public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;sonar.host.url&gt; http://192.168.2.173:9000 &lt;/sonar.host.url&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt;&lt;/settings&gt; 3 IntelliJ IDEA 2019.2 激活https://www.jiweichengzhu.com/article/93afbed1245d4ee69b82ed1b067f48a4 4 JRebel 激活https://www.jiweichengzhu.com/article/33c0330308f5429faf7a1e74127c9708 5 Navicat Premium 安装与破解安装包及破解程序 百度网盘：https://pan.baidu.com/s/1B4SOFvKbvpAAOeYwUo_BxA 提取码：vc6e TIP：安装后退出 Navicat Premium，然后双击 PatchNavicat.exe 文件即可。 6 EditPlus 安装与破解7 Git 安装8 Charles 安装9 Xshell 和 Xftp 安装Xshell 5 和 Xftp 5 安装包（免费使用，不需破解） 百度网盘：https://pan.baidu.com/s/1fahg_1CyU470ZOUUA23ZFg 提取码：mwok 10 RedisDesktopManager 安装redis-desktop-manager-0.8.7.322（免费使用，不需破解） 百度网盘：https://pan.baidu.com/s/1pbkc7OAhxOkPz4EB1ClnOA 提取码：cwpz 11 MarkdownPad 2 安装12 Postman","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java方法句柄--优化反射","slug":"Java方法句柄-优化反射","date":"2019-09-08T10:08:31.000Z","updated":"2020-11-03T13:04:34.158Z","comments":false,"path":"2019/09/08/Java方法句柄-优化反射/","link":"","permalink":"https://zhechu.github.io/2019/09/08/Java方法句柄-优化反射/","excerpt":"","text":"先打个标记，后续再完善。 测试示例123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.lang.invoke.*;public class Test &#123; /** * 目标方法，即为将被使用方法句柄调用的方法 * @param i */ public static void target(int i) &#123;&#125; /** * 继承 ConstantCallSite 可以使 JVM 使用内联缓存优化 MethodHandle */ public static class MyCallSite extends ConstantCallSite &#123; public MyCallSite() &#123; super(findTarget()); &#125; private static MethodHandle findTarget() &#123; try &#123; MethodHandles.Lookup l = MethodHandles.lookup(); MethodType t = MethodType.methodType(void.class, int.class); return l.findStatic(Test.class, \"target\", t); &#125; catch (Throwable e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; public static final MyCallSite myCallSite = new MyCallSite(); public static void main(String[] args) throws Throwable &#123; long current = System.currentTimeMillis(); for (int i = 1; i &lt;= 2_000_000_000; i++) &#123; if (i % 100_000_000 == 0) &#123; long temp = System.currentTimeMillis(); System.out.println(temp - current); current = temp; &#125; myCallSite.getTarget().invokeExact(128); &#125; &#125;&#125; 查看 String 类内存分布情况12curl -L -O http://central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jarjava -cp jol-cli-0.9-full.jar org.openjdk.jol.Main internals java.lang.String","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"},{"name":"反射","slug":"反射","permalink":"https://zhechu.github.io/tags/反射/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"创建型-单例模式","slug":"创建型-单例模式","date":"2019-09-05T13:26:31.000Z","updated":"2020-11-03T13:04:34.280Z","comments":false,"path":"2019/09/05/创建型-单例模式/","link":"","permalink":"https://zhechu.github.io/2019/09/05/创建型-单例模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/singleton 1 定义保证一个类仅有一个实例，并提供一个访问它的全局访问点。本质是控制实例的数目。 2 结构 角色 说明 Singleton 负责创建 Singleton 类自身的唯一实例，并提供一个可以被外部调用的 getInstance 的方法 3 优缺点优点 懒汉式是时间换空间 饿汉式是空间换时间 缺点 双重检查加锁的懒汉式需要确保线程安全 4 使用场景 需控制一个类的实例只有一个且客户只能从一个全局访问点访问其时 5 示例5.1 饿汉式特点：以空间换时间。减少第一次获取实例的时间。 5.1.1 静态且不可变变量实现Client1234567891011121314151617181920212223242526/** * 客户端类 * @author lingyuwang * */public class Client &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); System.out.println(singleton1); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton2); Singleton singleton3 = Singleton.getInstance(); System.out.println(singleton3); System.out.println(singleton1 == singleton2); // true System.out.println(singleton1 == singleton3); // true System.out.println(singleton2 == singleton3); // true &#125;&#125; Singleton12345678910111213141516171819202122232425262728293031/** * 饿汉式单例 */public class Singleton &#123; /** * 定义一个变量存储创建的唯一类实例 */ private final static Singleton INSTANCE = new Singleton(); /** * 私有化构造方法，不允许外部直接调用构造函数创建类的实例 */ private Singleton()&#123;&#125; /** * 定义一个方法=为客户端提供类实例 * @return */ public static Singleton getInstance()&#123; return INSTANCE; &#125; /** * 示例方法，单例可以有额外的操作 */ public void operation()&#123; // 功能处理 &#125;&#125; 5.1.2 枚举实现（推荐）优点 简洁 比较安全，防止两种情况：a.使用反射创建多个实例，b.反序列化时重新创建实例 缺点 难以理解 Client123456789101112131415161718192021222324252627282930313233343536/** * 客户端类 * @author lingyuwang * */public class Client &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); System.out.println(singleton1); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton2); Singleton singleton3 = Singleton.getInstance(); System.out.println(singleton3); System.out.println(singleton1 == singleton2); // true System.out.println(singleton1 == singleton3); // true System.out.println(singleton2 == singleton3); // true singleton1.setSingletonData(\"Hello world\"); System.out.println(singleton1.getSingletonData()); // Hello world System.out.println(singleton2.getSingletonData()); // Hello world System.out.println(singleton3.getSingletonData()); // Hello world &#125;&#125; Singleton12345678910111213141516171819202122232425262728/** * 使用枚举实现的单例 */public enum Singleton &#123; /** * 定义一个枚举的元素，其代表 Singleton 的一个实例 */ INSTANCE; public static Singleton getInstance()&#123; return INSTANCE; &#125; /** * 单例可以有自己的属性 */ private String singletonData; public String getSingletonData() &#123; return singletonData; &#125; public void setSingletonData(String singletonData) &#123; this.singletonData = singletonData; &#125;&#125; 5.2 懒汉式特点：以时间换空间。第一次调用时才创建实例，也称懒加载。 5.2.1 双重检查加锁Client1234567891011121314151617181920212223242526/** * 客户端类 * @author lingyuwang * */public class Client &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); System.out.println(singleton1); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton2); Singleton singleton3 = Singleton.getInstance(); System.out.println(singleton3); System.out.println(singleton1 == singleton2); // true System.out.println(singleton1 == singleton3); // true System.out.println(singleton2 == singleton3); // true &#125;&#125; Singleton12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 双重检查加锁的懒汉式单例 */public class Singleton &#123; /** * 添加 volatile 修饰，保证线程间可见 */ private volatile static Singleton INSTANCE = null; /** * 私有化构造方法，不允许外部直接调用构造函数创建类的实例 */ private Singleton()&#123;&#125; public static Singleton getInstance()&#123; Singleton singleton = INSTANCE; // 检查实例是否存在，若不存在则进入同步块 if (singleton == null) &#123; // 同步块，安全地创建实例 synchronized(Singleton.class) &#123; singleton = INSTANCE; // 再次检查实例是否存在，若不存在则创建实例 if (singleton == null) &#123; // 使用局部变量进行优化，volatile 变量创建对象时需要禁止指令重排序 singleton = new Singleton(); INSTANCE = singleton; &#125; &#125; &#125; return INSTANCE; &#125; /** * 示例方法，单例可以有额外的操作 */ public void operation()&#123; // 功能处理 &#125;&#125; 5.2.2 内部类实现（推荐）优点 由 JVM 保证线程安全和延迟加载 比双重检查加锁简洁 Client1234567891011121314151617181920212223242526/** * 客户端类 * @author lingyuwang * */public class Client &#123; public static void main(String[] args) &#123; Singleton singleton1 = Singleton.getInstance(); System.out.println(singleton1); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton2); Singleton singleton3 = Singleton.getInstance(); System.out.println(singleton3); System.out.println(singleton1 == singleton2); // true System.out.println(singleton1 == singleton3); // true System.out.println(singleton2 == singleton3); // true &#125;&#125; Singleton123456789101112131415161718192021222324252627/** * 使用类的内部类实现的单例 */public class Singleton &#123; /** * 静态的内部类的实例与外部类的实例没有绑定关系，且只有被调用到才会加载，从而实现了延迟加载的效果 */ private static class SingletonHolder &#123; /** * 静态初始化器，由 JVM 保证线程安全 */ private static final Singleton instance = new Singleton(); &#125; /** * 私有化构造方法，不允许外部直接调用构造函数创建类的实例 */ private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.instance; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Mysql锁","slug":"Mysql锁","date":"2019-08-29T15:56:47.000Z","updated":"2020-11-03T13:04:34.180Z","comments":false,"path":"2019/08/29/Mysql锁/","link":"","permalink":"https://zhechu.github.io/2019/08/29/Mysql锁/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 官方文档 https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html 参考博文 https://blog.csdn.net/wjn2000414/article/details/82659050 1 全局锁全局锁：对整个数据库实例加锁 应用场景：全库逻辑备份 使用全局读锁锁定所有数据库的所有表1FLUSH TABLES WITH READ LOCK TIPS：其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句 解锁1UNLOCK TABLES TIPS：需在同一加锁的会话执行 2 表级锁2.1 表锁表级锁：在整个表进行加锁 应用场景：初始化全表数据 锁定 t 表1FLUSH TABLES t WITH READ LOCK TIPS：其他线程针对该表的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括修改表结构）和更新类事务的提交语句 解锁1UNLOCK TABLES TIPS：需在同一加锁的会话执行 2.2 MDL作用：保证读写的正确性。不需要显式使用，在访问一个表的时候会被自动加上 详析：在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，若有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行 3 行级锁两阶段锁协议：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放 3.1 死锁和死锁检测 等待超时，innodb_lock_wait_timeout 参数设置超时时间，默认50秒 1SHOW VARIABLES LIKE &apos;innodb_lock_wait_timeout&apos; 死锁检测，innodb_deadlock_detect 参数设置是否开启，默认开启 1SHOW VARIABLES LIKE &apos;innodb_deadlock_detect&apos; 显式加读锁（S 锁，共享锁）1select * from t where id = 1 lock in share mode 显式加写锁（X 锁，排他锁）1select * from t where id = 1 for update 4 间隙锁两个“原则”、两个“优化”和一个“bug” 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间 原则 2：查找过程中访问到的对象才会加锁 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止 TIPS：实践过程中以上原则存在 BUG，需辩证看待 测试表及示例数据12345678910CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); 4.1 等值查询间隙锁 Session A Session B Session C begin;update t set d = d + 1 where id = 7; insert into t values(8, 8, 8);（阻塞） update t set d = d + 1 where id = 10;（立即执行成功） 分析 根据原则 1，加锁单位是 next-key lock，Session A 加锁范围就是 (5,10] 同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10) 总结 Session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 Session C 修改 id=10 这行是可以的 4.2 主键索引范围锁 Session A Session B Session C begin;select * from t where id &gt;= 10 and id &lt; 11 for update; insert into t values(8, 8, 8);insert into t values(13, 13, 13);（阻塞） update t set d = d + 1 where id = 15;（阻塞） 分析 开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁 范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15] 总结 Session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15] 4.3 非唯一索引范围锁 Session A Session B Session C begin;select * from t where c &gt;= 10 and c &lt; 11 for update; insert into t values(8, 8, 8);（阻塞） update t set d = d + 1 where id = 15;（立即执行成功） 分析 在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 Sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock 但实践结果是，只有加 (5,10] next-key lock 总结 Sesson B 要插入（8,8,8) 的这个 insert 语句时就被阻塞 4.4 唯一索引范围锁BUG Session A Session B Session C begin;select * from t where id &gt; 10 and id &lt;= 15 for update; update t set d = d + 1 where id = 20;（阻塞） insert into t values(16, 16, 16);（阻塞） 分析 Session A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止 但实践结果是，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] next-key lock 也会被锁上 总结 Session B 要更新 id=20 这一行，是会被锁住的。同样地，Session C 要插入 id=16 的一行，也会被锁住。锁住 id=20 这一行的行为，是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实际结果是找了，因此被认为这是个 BUG 4.5 limit 语句加锁重置示例数据123truncate t;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25),(30,10,30); Session A Session B begin;delete from t where c = 10 limit 2; insert into t values(13, 13, 13);（立即执行成功） 分析 Session A 的 delete 语句加了 limit 2。表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束。因此，索引 c 上的加锁范围就变成了从（5,10) 总结 在删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围 4.6 死锁 Session A Session B begin;select id from t where c = 10 lock in share mode; update t set d = d + 1 where c = 10; insert into t values(8, 8, 8); [Err] 1213 - Deadlock found when trying to get lock; try restarting transaction TIPS：Session A 第一条语句若为 begin;select id from t where c = 10 for update;，结果也是一样的 分析 Session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15) Session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待 然后 Session A 要再插入 (8,8,8) 这一行，被 Session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 Session B 回滚 总结 Session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的 5 解锁5.1 手动解锁测试表12345CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB; 示例数据12345678910111213delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=100000) do insert into t values(i,i); set i=i+1; end while;end;;delimiter ;call idata(); 模拟阻塞 Session A Session B lock table t write; select * from t where id = 1; TIPS：Session A 持有 MDL 写锁，导致 Session B 拿不到 MDL 读锁，因此 Session B 进入等待状态 查看当前线程信息1show processlist 杀死线程即可1kill &lt;thread id&gt; TIPS：show processlist返回的第一列即为 thread id","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://zhechu.github.io/tags/锁/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"创建型-抽象工厂模式","slug":"创建型-抽象工厂模式","date":"2019-08-25T09:19:21.000Z","updated":"2020-11-03T13:04:34.281Z","comments":false,"path":"2019/08/25/创建型-抽象工厂模式/","link":"","permalink":"https://zhechu.github.io/2019/08/25/创建型-抽象工厂模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/factory/abstractfactory 1 定义提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。本质是选择产品簇的实现。 2 结构 角色 说明 AbstractFactory 抽象工厂，定义创建一系列产品对象的操作接口 ConcreteFactory 具体工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建 AbstractProduct 定义一类产品对象的接口 ConcreteProduct 具体的产品实现对象 Client 客户端 3 体现的 GRASP 设计原则 间接 4 优缺点优点 分离接口和实现 容易切换产品簇 缺点 不容易扩展新的产品 容易造成类层次复杂 5 使用场景 一个系统只知道产品的接口而不关心实现时 需要动态切换产品簇时 需要强调一系列相关产品的接口，以便联合使用它们时 6 示例6.1 组装电脑 Client12345678910111213141516171819202122232425/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123; // 创建装机工程师对象 ComputerEngineer engineer = new ComputerEngineer(); // 客户选择并创建需要使用的装机方案对象 AbstractFactory schema = new Schema1(); // 通知装机工程师自己选择的装机方案，让装机工程师组装电脑 engineer.makeComputer(schema); // now in Intel CPU,pins=1156 // now in GAMainboard,cpuHoles=1156 // 客户选择并创建需要使用的装机方案对象 schema = new Schema2(); // 告诉装机工程师自己选择的装机方案，让装机工程师组装电脑 engineer.makeComputer(schema); // now in AMD CPU,pins=939 // now in MSIMainboard,cpuHoles=939 &#125;&#125; ComputerEngineer123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 装机工程师的类 */public class ComputerEngineer &#123; /** * 定义组装机器需要的CPU */ private CPUApi cpu= null; /** * 定义组装机器需要的主板 */ private MainboardApi mainboard = null; /** * 装机过程 * @param schema 客户选择的装机方案 */ public void makeComputer(AbstractFactory schema)&#123; // 1：首先准备好装机所需要的配件 prepareHardwares(schema); // 2：组装机器 // 3：测试机器 // 4：交付客户 &#125; /** * 准备装机所需要的配件 * @param schema 客户选择的装机方案 */ private void prepareHardwares(AbstractFactory schema)&#123; // 使用抽象工厂来获取相应的接口对象 this.cpu = schema.createCPUApi(); this.mainboard = schema.createMainboardApi(); // 测试一下配件是否好用 this.cpu.calculate(); this.mainboard.installCPU(); &#125;&#125; AbstractFactory123456789101112131415161718/** * 抽象工厂的接口，声明创建抽象产品对象的操作 */public interface AbstractFactory &#123; /** * 创建CPU的对象 * @return CPU的对象 */ CPUApi createCPUApi(); /** * 创建主板的对象 * @return 主板的对象 */ MainboardApi createMainboardApi();&#125; Schema11234567891011121314/** * 装机方案一：Intel 的CPU + 技嘉的主板 */public class Schema1 implements AbstractFactory&#123; public CPUApi createCPUApi() &#123; return new IntelCPU(1156); &#125; public MainboardApi createMainboardApi() &#123; return new GAMainboard(1156); &#125;&#125; Schema21234567891011121314/** * 装机方案二：AMD的CPU + 微星的主板 */public class Schema2 implements AbstractFactory&#123; public CPUApi createCPUApi() &#123; return new AMDCPU(939); &#125; public MainboardApi createMainboardApi() &#123; return new MSIMainboard(939); &#125;&#125; CPUApi1234567891011/** * CPU的接口 */public interface CPUApi &#123; /** * 示意方法，CPU具有运算的功能 */ void calculate();&#125; IntelCPU1234567891011121314151617181920212223/** *Intel的CPU实现 */public class IntelCPU implements CPUApi&#123; /** * CPU的针脚数目 */ private int pins = 0; /** * 构造方法，传入CPU的针脚数目 * @param pins CPU的针脚数目 */ public IntelCPU(int pins)&#123; this.pins = pins; &#125; public void calculate() &#123; System.out.println(\"now in Intel CPU,pins=\"+pins); &#125;&#125; AMDCPU1234567891011121314151617181920212223/** * AMD的CPU实现 */public class AMDCPU implements CPUApi&#123; /** * CPU的针脚数目 */ private int pins = 0; /** * 构造方法，传入CPU的针脚数目 * @param pins CPU的针脚数目 */ public AMDCPU(int pins)&#123; this.pins = pins; &#125; public void calculate() &#123; System.out.println(\"now in AMD CPU,pins=\"+pins); &#125;&#125; MainboardApi1234567891011/** * 主板的接口 */public interface MainboardApi &#123; /** * 示意方法，主板都具有安装CPU的功能 */ void installCPU();&#125; GAMainboard1234567891011121314151617181920212223/** * 技嘉的主板 */public class GAMainboard implements MainboardApi &#123; /** * CPU插槽的孔数 */ private int cpuHoles = 0; /** * 构造方法，传入CPU插槽的孔数 * @param cpuHoles CPU插槽的孔数 */ public GAMainboard(int cpuHoles)&#123; this.cpuHoles = cpuHoles; &#125; public void installCPU() &#123; System.out.println(\"now in GAMainboard,cpuHoles=\"+cpuHoles); &#125;&#125; MSIMainboard1234567891011121314151617181920212223/** * 微星的主板 */public class MSIMainboard implements MainboardApi&#123; /** * CPU插槽的孔数 */ private int cpuHoles = 0; /** * 构造方法，传入CPU插槽的孔数 * @param cpuHoles CPU插槽的孔数 */ public MSIMainboard(int cpuHoles)&#123; this.cpuHoles = cpuHoles; &#125; public void installCPU() &#123; System.out.println(\"now in MSIMainboard,cpuHoles=\"+cpuHoles); &#125;&#125; 程序运行后控制台输出1234now in Intel CPU,pins=1156now in GAMainboard,cpuHoles=1156now in AMD CPU,pins=939now in MSIMainboard,cpuHoles=939","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"创建型-工厂方法模式","slug":"创建型-工厂方法模式","date":"2019-08-25T08:08:55.000Z","updated":"2020-11-03T13:04:34.280Z","comments":false,"path":"2019/08/25/创建型-工厂方法模式/","link":"","permalink":"https://zhechu.github.io/2019/08/25/创建型-工厂方法模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/factory/method 1 定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。本质是延迟到子类选择实现。 2 结构 角色 说明 Product 定义工厂方法所创建的对象的接口，即实际需要使用的对象的接口 ConcreteProduct Product 接口的实现类 Creator 抽象的创建器类，声明工厂方法 ConcreteCreator 具体的创建器类，覆盖实现 Creator 定义的工厂方法，返回具体的 Product 实例 TIPS：可以使用工厂方法模式连接平行的类层次。 3 体现的 GRASP 设计原则 低耦合（Client 不与具体要创建的对象耦合） 隔离变化（将变化移到工厂方法，将来若要扩展，修改工厂方法 即可） 间接（Client 不与具体要创建的对象耦合，但具体要创建的对象和工厂方法耦合） 4 优缺点优点 可以在不知具体实现的情况下编程 更容易扩展对象的新版本（修改工厂方法的实现时，Client 不需变动） 连接平行的类层次 缺点 具体产品对象和工厂方法耦合 5 使用场景 明确接口但不知具体的实现时，可以使用工厂方法将创建 Product 对象的工作延迟到子类实现 一个类本身期望由其子类创建所需对象 6 示例6.1 导出数据导出数据到数据库备份文件和TXT文件。 Client12345678910111213141516171819202122/** * 客户端 */public class Client &#123; public static void main(String[] args) &#123; /*//创建需要使用的Creator对象 ExportOperate operate = new ExportDBOperate(); //调用输出数据的功能方法 operate.export(\"测试数据\");*/ // 当有默认实现时 ExportOperate operate = new ExportOperate(); operate.export(\"测试数据\"); // 导出数据测试数据到文本文件 operate = new ExportDBOperate(); operate.export(\"测试数据\"); // 导出数据测试数据到数据库备份文件 &#125;&#125; ExportOperate1234567891011121314151617181920212223242526/** * 实现导出数据的业务功能对象，当不需默认实现工厂方法时，可声明为抽象类 */public /*abstract*/ class ExportOperate &#123; /** * 导出文件 * @param data 需要保存的数据 * @return 是否成功导出文件 */ public boolean export(String data)&#123; // 使用工厂方法 ExportFileApi api = factoryMethod(); return api.export(data); &#125; /** * 工厂方法，创建导出的文件对象的接口对象 * @return 导出的文件对象的接口对象 */ //protected abstract ExportFileApi factoryMethod(); protected ExportFileApi factoryMethod() &#123; return new ExportTxtFile(); &#125;&#125; ExportDBOperate1234567891011121314/** * 具体的创建器实现对象，实现创建导出成数据库备份文件形式的对象 */public class ExportDBOperate extends ExportOperate&#123; /** * 声明为 protected，目的：1.防止客户端调用，2.可被子类重写，便于扩展 * @return */ protected ExportFileApi factoryMethod() &#123; // 创建导出成数据库备份文件形式的对象 return new ExportDB(); &#125;&#125; ExportTxtFileOperate123456789101112131415/** * 具体的创建器实现对象，实现创建导出成文本文件格式的对象 */public class ExportTxtFileOperate extends ExportOperate&#123; /** * 声明为 protected，目的：1.防止客户端调用，2.可被子类重写，便于扩展 * @return */ protected ExportFileApi factoryMethod() &#123; // 创建导出成文本文件格式的对象 return new ExportTxtFile(); &#125;&#125; ExportFileApi12345678910111213/** * 导出的文件对象的接口 */public interface ExportFileApi &#123; /** * 导出内容成为文件 * @param data 需要保存的数据 * @return 是否导出成功 */ boolean export(String data);&#125; ExportDB123456789101112/** * 导出成数据库备份文件形式的对象 */public class ExportDB implements ExportFileApi&#123; public boolean export(String data) &#123; // 演示使用，这里需要操作数据库和文件 System.out.println(\"导出数据\" + data + \"到数据库备份文件\"); return true; &#125;&#125; ExportTxtFile123456789101112/** * 导出成文本文件格式的对象 */public class ExportTxtFile implements ExportFileApi&#123; public boolean export(String data) &#123; // 演示使用，这里需要操作文件 System.out.println(\"导出数据\" + data + \"到文本文件\"); return true; &#125;&#125; 程序运行后控制台输出12导出数据测试数据到文本文件导出数据测试数据到数据库备份文件","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"创建型-简单工厂模式","slug":"创建型-简单工厂模式","date":"2019-08-25T02:22:17.000Z","updated":"2020-11-03T13:04:34.282Z","comments":false,"path":"2019/08/25/创建型-简单工厂模式/","link":"","permalink":"https://zhechu.github.io/2019/08/25/创建型-简单工厂模式/","excerpt":"","text":"示例代码 https://github.com/zhechu/design-pattern-demo/tree/master/src/main/java/com/wise/factory/simple 1 定义提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。简单工厂方法的功能是选择合适的实现类并创建。本质是选择实现。 2 描述简单工厂也称为静态工厂，可以把简单工厂类实现成一个工具类，直接提供静态创建对象的方法。 简单工厂也称为万能工厂，一个简单工厂理论上可以构造任何对象，因此又称为万能工厂。 可配置的简单工厂，使用反射加上配置文件，实现添加新的实现类后，无须修改代码，即可把新的实现类加入应用中进行使用。 3 结构 角色 说明 Api 定义 Client 所需要的接口 Impl Api 的实现类，可能有多个 Factory 创建合适的 Api 接口对象 Client 通过 Factory 获取 Api 接口对象，面向接口编程 工厂命名规则 类名为“模块名称 + Factory”，如：用户模块的工厂命名为 UserFactory 方法名称为“get + 接口名称”或“create + 接口名称” 4 体现的 GRASP 设计原则 低耦合（Client 不与具体要创建的对象耦合） 隔离变化（将变化移到 Factory，将来若要扩展，修改 Factory 即可） 5 优缺点优点 帮助封装 解耦 缺点 可能增加 Client 的复杂度（Client 需要传参到 Factory 以创建具体对象。要传什么参数，需要 Client 知道） 不方便扩展子工厂（简单工厂不是面向接口编程，存在自身扩展问题） 6 使用场景 将对外创建对象的职责集中管理和控制 7 示例7.1 静态工厂Client1234567891011121314151617/** * 客户端类 * @author lingyuwang * */public class Client &#123; public static void main(String[] args) &#123; // 客户端不需知道具体的实现（隔离封装、面向接口编程） Api api = Factory.createApi(); api.hello(\"man\"); // Impl1 hello man Api api1 = Factory.createApi(2); api1.hello(\"girl\"); // Impl2 hello girl &#125;&#125; Factory12345678910111213141516171819202122232425262728293031323334353637/** * 简单工厂类 * 范围：独立的组件或独立的模块级别 * 类名：“模块名称+Factory” * 方法名：“get+接口名称”或“create+接口名称” * @author lingyuwang * */public class Factory &#123; private Factory() &#123;&#125; public static Api createApi() &#123; // 主要实现选择合适的实现类创建实例对象 return new Impl1(); &#125; public static Api createApi(int type) &#123; // 缺点，暴露参数的含义 // 主要实现选择合适的实现类创建实例对象 // 根据type进行选择，1和2应为常量 Api api = null; if (type==1) &#123; api = new Impl1(); &#125; else if (type==2) &#123; api = new Impl2(); &#125; // 参数来源 // 1：client // 2：配置文件 // 3：系统自身，比如运行期间的某个值 return api; &#125;&#125; Api12345678910/** * 接口 * @author lingyuwang * */public interface Api &#123; void hello(String name);&#125; Impl1123456789101112/** * 实现类 * @author lingyuwang * */public class Impl1 implements Api &#123; public void hello(String name) &#123; System.out.println(\"Impl1 hello \"+name); &#125;&#125; Impl2123456789101112/** * 实现类 * @author lingyuwang * */public class Impl2 implements Api &#123; public void hello(String name) &#123; System.out.println(\"Impl2 hello \"+name); &#125;&#125; 程序运行后控制台输出12Impl1 hello manImpl2 hello girl","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhechu.github.io/tags/设计模式/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot配置加密","slug":"SpringBoot配置加密","date":"2019-08-05T14:30:27.000Z","updated":"2020-11-03T13:04:34.207Z","comments":false,"path":"2019/08/05/SpringBoot配置加密/","link":"","permalink":"https://zhechu.github.io/2019/08/05/SpringBoot配置加密/","excerpt":"","text":"环境说明 环境 说明 spring-boot-2.0.x 企业应用程序框架 官方文档 https://github.com/ulisesbocchio/jasypt-spring-boot 示例代码 https://github.com/zhechu/spring-jasypt-demo 1 加解密单元测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import lombok.extern.slf4j.Slf4j;import org.jasypt.intf.service.JasyptStatelessService;import org.junit.Test;import org.springframework.beans.factory.annotation.Value;import java.util.ArrayList;import java.util.List;@Slf4jpublic class EncryptTest &#123; final static JasyptStatelessService service = new JasyptStatelessService(); /** * 秘钥 */ final static String password = \"9e5eb701949a152dabb25af9a21b764f2439fa9dd76437d4209bbee8088a1be5\"; /** * 加密方式 */ final static String algorithm = \"PBEWithMD5AndDES\"; @Test public void encode() &#123; String param = \"123456\"; log.debug(\"加密前的原文：&#123;&#125;\", param); // 123456 // 加密 String result = service.encrypt( param, password, null, null, algorithm, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); log.debug(\"加密后的密文：&#123;&#125;\", result); // vlJIXfrLSR2uDLeGN7vyEw== &#125; @Test public void decode()&#123; String param = \"1EnLd3e1TMY2pifbPKVXZg==\"; log.debug(\"解密前的密文：&#123;&#125;\", param); // 1EnLd3e1TMY2pifbPKVXZg== // 解密 String deResult = service.decrypt( param, password, null, null, algorithm, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null); log.debug(\"解密后的原文：&#123;&#125;\", deResult); // 123456 &#125;&#125; TIPS：每次加密的密文都会不一样。 2 配置案例application.yml12345678910111213141516################################################################################################################################ 运行容器端口设置 ####################################################################################################################################server: port: 8080JASYPT_PASS: 9e5eb701949a152dabb25af9a21b764f2439fa9dd76437d4209bbee8088a1be5#################################################################################################################################### jasypt ########################################################################################################################################jasypt: encryptor: password: $&#123;JASYPT_PASS:&#125;##################################################################################################################################### pwd ##########################################################################################################################################pwd: ENC(1EnLd3e1TMY2pifbPKVXZg==)","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"CentOS7离线安装k8s-1.14.2","slug":"CentOS7离线安装k8s-1-14-2","date":"2019-07-28T07:06:50.000Z","updated":"2020-11-03T13:04:34.061Z","comments":false,"path":"2019/07/28/CentOS7离线安装k8s-1-14-2/","link":"","permalink":"https://zhechu.github.io/2019/07/28/CentOS7离线安装k8s-1-14-2/","excerpt":"","text":"在线安装请看 CentOS7在线安装k8s-1.14.2 就算操作系统版本一样，但环境还是有可能不一样，存在软件冲突和版本等问题。 笔者建议：效仿阿里，自建 yum 源。以不变应万变。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"},{"name":"k8s","slug":"k8s","permalink":"https://zhechu.github.io/tags/k8s/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"k8s故障排查","slug":"k8s故障排查","date":"2019-07-28T02:22:32.000Z","updated":"2020-11-03T13:04:34.267Z","comments":false,"path":"2019/07/28/k8s故障排查/","link":"","permalink":"https://zhechu.github.io/2019/07/28/k8s故障排查/","excerpt":"","text":"前置博文 k8s部署nginx 1 查看日志1.1 查看系统日志1$ tail -500 /var/log/messages 1.2 查看 kubelet 日志所有节点都有 kubelet 服务1$ journalctl -f -u kubelet.service 1.3 查看 pod 日志1.3.1 dashboard 操作 1.3.2 命令操作查看 pod1$ kubectl get pods -n example -l app=nginx 1$ kubectl logs nginx-56db997f77-2pdmw -n example 2 时钟同步2.1 时区配置查看当前主机使用的时区1$ timedatectl 查看亚洲的所有时区1$ timedatectl list-timezones | grep Asia 将时区设为 Asia/Shanghai1$ timedatectl set-timezone Asia/Shanghai 2.2 时间同步安装 ntpdate1$ yum -y install ntpdate 添加系统定时任务，每10分钟自动同步一次时间12$ crontab -e*/10 * * * * /usr/sbin/ntpdate -u cn.pool.ntp.org &gt;/dev/null 2&gt;&amp;1 检查定时任务是否添加成功1$ crontab -l 3 检查服务状态检查关键 pod 是否启动成功，如：etcd 和 api server pod12$ docker ps -a | grep etcd$ docker ps -a | grep apiserver 4 清除已过期的容器可参考 https://github.com/HardySimpson/docker-cleanup","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"},{"name":"k8s","slug":"k8s","permalink":"https://zhechu.github.io/tags/k8s/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"k8s部署nginx","slug":"k8s部署nginx","date":"2019-07-27T15:51:43.000Z","updated":"2020-11-03T13:04:34.271Z","comments":false,"path":"2019/07/27/k8s部署nginx/","link":"","permalink":"https://zhechu.github.io/2019/07/27/k8s部署nginx/","excerpt":"","text":"前置博文 CentOS7在线安装k8s-1.14.2 Dashboard 官方文档 https://github.com/kubernetes/dashboard 1 新建命名空间master 节点上执行新建命名空间 example1$ kubectl create namespace example TIPS：此步在 dashboard 上无法操作。 master 查看命名空间1$ kubectl get namespaces 或 dashboard 上查看 2 新建部署有两种方式，dashboard 上操作或使用命令操作。 2.1 dashboard 操作需先选择命名空间 填入如下配置，启动两个 pod12345678910111213141516171819apiVersion: apps/v1kind: Deploymentmetadata: name: nginxspec: selector: matchLabels: app: nginx replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 上传后，新建成功 2.2 命令操作需在 master 节点上执行。 新建配置文件1234567891011121314151617181920$ vi nginx-deploy.yamlapiVersion: apps/v1kind: Deploymentmetadata: name: nginxspec: selector: matchLabels: app: nginx replicas: 2 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 新建部署1$ kubectl create -f nginx-deploy.yaml -n example 检查部署是否成功1$ kubectl get deploy -n example 检查 pod 个数是否正确1$ kubectl get pods -n example -l app=nginx 3 新建服务也有两种方式，dashboard 上操作或使用命令操作。 3.1 dashboard 操作需先选择命名空间 填入如下配置，新建服务并暴露 31111 端口给外界访问123456789101112apiVersion: v1kind: Servicemetadata: name: nginxspec: type: NodePort ports: - port: 8000 targetPort: 80 nodePort: 31111 selector: app: nginx 上传后，新建成功 浏览器访问 nginx （集群中任一节点 IP 都可以） http://192.168.163.101:31111/ 或 http://192.168.163.102:31111/ 3.2 命令操作需在 master 节点上执行。 新建配置文件12345678910111213$ vi service.yamlapiVersion: v1kind: Servicemetadata: name: nginxspec: type: NodePort ports: - port: 8000 targetPort: 80 nodePort: 31111 selector: app: nginx 新建服务1$ kubectl create -f service.yaml -n example 检查服务是否启动成功1$ kubectl get svc -n example","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://zhechu.github.io/categories/Nginx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"},{"name":"k8s","slug":"k8s","permalink":"https://zhechu.github.io/tags/k8s/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://zhechu.github.io/categories/Nginx/"}]},{"title":"CentOS7在线安装k8s-1.14.2","slug":"CentOS7在线安装k8s-1-14-2","date":"2019-07-27T14:24:34.000Z","updated":"2020-11-03T13:04:34.052Z","comments":false,"path":"2019/07/27/CentOS7在线安装k8s-1-14-2/","link":"","permalink":"https://zhechu.github.io/2019/07/27/CentOS7在线安装k8s-1-14-2/","excerpt":"","text":"环境说明 环境 说明 CentOS7 操作系统 k8s-1.14.2 容器编排系统 docker-18.06.1.ce-3.el7 容器引擎 节点配置 IP 地址 节点角色 CPU Memory Hostname 192.168.163.101 master 1 4G k8s-master-101 192.168.163.102 node 1 4G k8s-node-102 192.168.163.103 node 1 4G k8s-node-103 官方安装文档 https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/ 中文社区安装文档 https://www.kubernetes.org.cn/5462.html 1 准备1.1 设置主机名k8s-master-101 上执行1$ hostnamectl --static set-hostname k8s-master-101 k8s-node-102 上执行1$ hostnamectl --static set-hostname k8s-node-102 k8s-node-103 上执行1$ hostnamectl --static set-hostname k8s-node-103 1.2 所有节点配置1.2.1 配置 /etc/hosts 域名解析12345$ cat &lt;&lt; EOF &gt;&gt; /etc/hosts192.168.163.101 k8s-master-101192.168.163.102 k8s-node-102192.168.163.103 k8s-node-103EOF 1.2.2 关闭防火墙、selinux 和 swap12345$ systemctl stop firewalld &amp;&amp; systemctl disable firewalld$ setenforce 0 &amp;&amp; sed -i \"s/^SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config$ swapoff -a &amp;&amp; sed -i 's/.*swap.*/#&amp;/' /etc/fstab 检查 swap 分区是否已禁用1$ free -m 1.2.3 路由转发配置将桥接的 IPv4 流量传递到 iptables 链123456$ cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOF$ sysctl --system 1.2.4 配置源1.2.4.1 配置国内 yum 源安装 wget1$ yum -y install wget 安装常用工具包（可选）1$ yum -y install lrzsz net-tools 备份 yum 源配置文件1$ mkdir /etc/yum.repos.d/bak &amp;&amp; mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak 配置腾讯 yum 源12$ wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo 更新 yum 缓存1$ yum clean all &amp;&amp; yum makecache TIPS：若后续安装 docker 有软件冲突或版本问题，则可以执行tail -500 /var/log/messages查看系统日志，根据需要更新或安装指定软件。若网速较好，则可以执行yum -y update更新所有软件，但较耗时。 重启系统1$ reboot 1.2.4.2 配置国内 k8s 源配置阿里云 k8s 源123456789$ cat &lt;&lt; EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 1.2.4.3 配置国内 docker 源配置阿里云 docker 源1$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo 2 所有节点安装2.1 安装 docker安装 docker 所需的软件123$ yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 更新管理 XFS 文件系统的工具包1$ yum -y update xfsprogs 查看仓库中 docker 的所有版本1$ yum list docker-ce --showduplicates | sort -r 安装 docker-ce-18.06.1.ce-3.el71$ yum -y install docker-ce-18.06.1.ce-3.el7 启动1$ systemctl enable docker &amp;&amp; systemctl start docker TIPS：启动 docker 可能会报错，可能是因为 systemctl 要重新加载，可以尝试使 systemctl 重新加载 systemctl daemon-reload，再重启 docker。 检查安装版本1$ docker version 配置 DaoCloud 加速器1$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 需重启 Docker 才会生效1$ systemctl restart docker 检查是否配置加速器成功1$ cat /etc/docker/daemon.json 2.2 准备 flannel 镜像安装 flannel 前准备好相关镜像（网络不好时，推荐执行此步，可选） 官方 docker 包下载 https://github.com/coreos/flannel/releases 也可以通过笔者的网盘下载 链接：https://pan.baidu.com/s/1ktGwhCeRv0mOKWyNaAfK3w 提取码：fmhy 导入12345$ docker load &lt; flanneld-v0.11.0-amd64.docker$ docker load &lt; flanneld-v0.11.0-arm64.docker$ docker load &lt; flanneld-v0.11.0-arm.docker$ docker load &lt; flanneld-v0.11.0-ppc64le.docker$ docker load &lt; flanneld-v0.11.0-s390x.docker 检查 flannel 镜像是否导入成功1$ docker images | grep flannel 2.3 安装 k8s 基础组件安装 kubeadm、kubelet 和 kubectl1$ yum -y install kubelet-1.14.2-0 kubeadm-1.14.2-0 kubectl-1.14.2-0 TIPS：若需安装指定版本，可以执行 yum list &lt;package name&gt; --showduplicates | sort -r 查看仓库中目标软件的所有版本。 kubelet 配置随机启动1$ systemctl enable kubelet TIPS：此时 kubelet 暂时不能启动。master 节点需初始化集群才能成功启动，node 节点则需加入集群才会启动。 3 部署3.1 部署 master 节点k8s 集群初始化123$ kubeadm init --kubernetes-version=1.14.2 \\--image-repository registry.aliyuncs.com/google_containers \\--pod-network-cidr=10.244.0.0/16 TIPS：pod 的网段为 10.244.0.0/16。此过程虽配置了阿里云的镜像仓库，但下载镜像还是比较耗时。 集群初始化成功后返回，后续其它节点加入集群将会用到12kubeadm join 192.168.163.101:6443 --token 2fzgsq.c5d2jhb7zu7q3wj2 \\ --discovery-token-ca-cert-hash sha256:e98f577c542855f4884cc608044f90d991a39611f305f1bf007f9a0753795895 若忘记 token，则可以查看或创建 token12345$ kubeadm token list或$ kubeadm token create 配置环境变量12$ echo \"export KUBECONFIG=/etc/kubernetes/admin.conf\" &gt;&gt; ~/.bash_profile$ source ~/.bash_profile 检查 kubectl 版本1$ kubectl version 安装 flannel1$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml TIPS：没有使用国内源，下载镜像会比较慢，推荐先执行 2.2 节步骤，手动导入镜像。kube-flannel.yml 本来应该用 v0.11.0 分支的，但目前只有 master 分支使用的镜像是 v0.11.0 版本的。 检查 flannel 是否安装成功1$ kubectl get pod --all-namespaces TIPS：若有问题，可以执行 kubectl delete -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 卸载 flannel，然后重新安装。 3.2 部署 node 节点将 node 节点加入 k8s 集群12$ kubeadm join 192.168.163.101:6443 --token 2fzgsq.c5d2jhb7zu7q3wj2 \\ --discovery-token-ca-cert-hash sha256:e98f577c542855f4884cc608044f90d991a39611f305f1bf007f9a0753795895 TIPS：此命令是在 master 节点执行 k8s 集群初始化后返回的。若加入节点失败，可能是 flannel 相关镜像下载较慢。可以先执行 2.2 节步骤，手动导入镜像。 master 检查加入 node 是否成功1$ kubectl get nodes 3.3 master 节点部署 dashboard-v1.10.1下载部署文件1$ wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 修改镜像地址，提高下载效率1$ sed -i 's/k8s.gcr.io/loveone/g' kubernetes-dashboard.yaml 修改端口为 300011$ sed -i '/targetPort:/a\\ \\ \\ \\ \\ \\ nodePort: 30001\\n\\ \\ type: NodePort' kubernetes-dashboard.yaml TIPS：端口有限制，不能随便起，当然也可以改全局配置。此步待完善。 启动 dashboard1$ kubectl create -f kubernetes-dashboard.yaml 检查启动是否成功1234$ kubectl get deployment kubernetes-dashboard -n kube-system$ kubectl get pods -n kube-system -o wide$ kubectl get services -n kube-system$ netstat -ntlp | grep 30001 用 Firefox 浏览器访问（其它浏览器因有安全限制，可能会打不开） https://192.168.163.101:30001 配置权限，获取登录要使用的 token123$ kubectl create serviceaccount dashboard-admin -n kube-system$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin$ kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk '/dashboard-admin/&#123;print $1&#125;') TIPS：最后，浏览器输入 token 即可登录成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"},{"name":"k8s","slug":"k8s","permalink":"https://zhechu.github.io/tags/k8s/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"SpringCloud基础","slug":"SpringCloud基础","date":"2019-07-24T14:00:31.000Z","updated":"2020-11-03T13:04:34.212Z","comments":false,"path":"2019/07/24/SpringCloud基础/","link":"","permalink":"https://zhechu.github.io/2019/07/24/SpringCloud基础/","excerpt":"","text":"环境说明 环境 说明 spring-cloud-Finchley.SR2 快速构建分布式应用的工具集 spring-boot-2.0.x 企业应用程序框架 1 相关组件相关组件及其兼容性 https://spring.io/projects/spring-cloud#overview 2 监控2.1 监控端点spring-boot-starter-actuator 监控端点 端点 描述 HTTP 方法 敏感 conditions 自动配置的信息 GET 是 beans 应用程序上下文所有的 Spring Bean GET 是 configprops 所有 @ConfigurationProperties 的配置属性列表 GET 是 dump 线程活动的快照 GET 是 env 环境变量 GET 是 health 应用程序的健康指标，值由 HealthIndicator 的实现类提供；结果有 UP、DOWN、OUTOFSERVICE、UNKNOWN，如需查看看详情，需配置：management.endpoint.health.show-details GET 否 info 应用的信息，可使用 info.* 属性自定义 info 端点公开的数据 GET 否 mappings 所有的 URL 路径 GET 是 metrics 应用的度量标准信息 GET 是 访问 http://{ip}:{port}/actuator/{endpoint} 端点，即可监控应用的运行状况。 监控可视化：spring-boot-admin-starter-server https://github.com/codecentric/spring-boot-admin spring-boot-admin 示例代码 https://github.com/zhechu/spring-boot-admin-demo 监控示例代码 https://github.com/zhechu/spring-boot-actuator-demo 注册中心示例代码 https://github.com/zhechu/eureka-server 2.2 链路跟踪Spring Cloud Sleuth 官方文档 https://cloud.spring.io/spring-cloud-sleuth/reference/html/ Zipkin 官方文档 https://github.com/openzipkin/zipkin Zipkin docker 官方文档 https://github.com/openzipkin/docker-zipkin Sleuth 与 Zipkin 集成 http://www.itmuch.com/spring-cloud/finchley-25/ 参考博客 https://windmt.com/2018/04/24/spring-cloud-12-sleuth-zipkin/ Zipkin 整合 MQ http://www.itmuch.com/spring-cloud/edgware-new-sleuth-zipkin-mq/ 示例代码 https://github.com/zhechu/spring-boot-sleuth-zipkin-demo 3 注册中心3.1 Eureka官方文档 https://github.com/Netflix/Eureka 配置 默认值 说明 eureka.client.fetch-registry true 是否开启缓存刷新，意为会从 Eureka Server 抓取注册表信息 eureka.client.registry-fetch-interval-seconds 30 每隔X秒执行一次刷新任务 eureka.server.enable-self-preservation true 是否开启自我保护模式 搭建高可用 https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247484279&amp;idx=1&amp;sn=80029c0c9641ea71c12698689a6c2c3e&amp;chksm=ec3c9e10db4b170613dd4d9152eab717b89a9ad43a1851cc82a15f040f813268c9be46396939&amp;scene=21#wechat_redirect 3.2 Consul4 负载均衡4.1 Ribbon官方文档 https://github.com/Netflix/ribbon 原理解析 https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247484298&amp;idx=1&amp;sn=acb31a593a51efd67fa7622ddff4c1b3&amp;chksm=ec3c9eeddb4b17fbee1a5fb45e6f4444e04a4acae7790486f6d6f6ed2d7f076b12d3dd15615c&amp;scene=21#wechat_redirect 饥饿加载 http://blog.didispace.com/spring-cloud-tips-ribbon-eager/?utm_source=tuicool&amp;utm_medium=referral 5 HTTP 客户端5.1 FeignFeign 原理解析 https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247484348&amp;idx=1&amp;sn=1f9a2e477df9de73e746cc87c64f67f7&amp;chksm=ec3c9edbdb4b17cd8d151e4d24312a547fba5edb4d061c8dcd64ae171167f0f2d984964e6599&amp;scene=21#wechat_redirect 示例代码 https://github.com/zhechu/spring-boot-feign-demo spring-boot-feign-consumer application.yml 配置12345678910111213141516171819202122232425262728293031323334353637383940414243server: port: 8082spring: application: name: spring-boot-feign-consumereureka: client: service-url: # 指定eureka server通信地址，注意/eureka/小尾巴不能少 defaultZone: http://admin:123456@127.0.0.1:8761/eureka/ instance: # 是否注册 IP 到 eureka server，如不指定或设为 false，那就会注册主机名到 eureka server prefer-ip-address: true# 指定 Feign 日志打印级别logging: level: com.wise.feign.UserFeignClient: debugfeign: client: config: default: connectTimeout: 5000 readTimeout: 5000 # 配置 Feign 的日志级别 loggerLevel: full# 自定义属性application: service: spring-boot-feign-provider: name: spring-boot-feign-provider # 可为空，若指定 url 则会固定负载到其指定节点 url:ribbon: eager-load: # 开启 Ribbon 的饥饿加载模式 enabled: true # 指定需要饥饿加载的客户端名称、服务名 clients: $&#123;application.service.spring-boot-feign-provider.name&#125; UserFeignClient 类12345678910111213141516171819import com.wise.entity.User;import feign.Logger;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.context.annotation.Bean;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;/** * 用户远程调用 */@FeignClient( name = \"$&#123;application.service.spring-boot-feign-provider.name&#125;\", url = \"$&#123;application.service.spring-boot-feign-provider.url&#125;\")public interface UserFeignClient &#123; @GetMapping(\"/users/&#123;id&#125;\") User findById(@PathVariable(\"id\") Long id);&#125; 6 熔断器6.1 HystrixHystrix 超时设置1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 官方文档 https://github.com/Netflix/Hystrix/wiki Hystrix 传播 ThreadLocal 对象 https://mp.weixin.qq.com/s?__biz=MzI4ODQ3NjE2OA==&amp;mid=2247483817&amp;idx=1&amp;sn=e00bb823d45d9ec99f5bb63fbd6aa602&amp;chksm=ec3c9ccedb4b15d88df5a3b2085f75e646f0404c2fbfdaf2ee0a2857e5e5ad2086b24bdf1590&amp;scene=21#wechat_redirect 服务降级示例代码 https://github.com/zhechu/spring-boot-hystrix-demo 7 事件流7.1 Spring Cloud Stream博客 http://blog.didispace.com/spring-cloud-starter-finchley-7-5/ 示例代码 https://github.com/zhechu/spring-cloud-stream-rabbitmq-demo 8 网关8.1 Spring Cloud Gatewayhttps://github.com/ityouknow/spring-cloud-examples https://windmt.com/2019/01/20/spring-cloud-20-gateway-dynamic-routing/ 熔断、限流、重试 http://www.ityouknow.com/springcloud/2019/01/26/spring-cloud-gateway-limit.html 示例代码 https://github.com/zhechu/spring-cloud-gateway-demo 9 杂篇9.1 重试机制http://www.itmuch.com/spring-cloud-sum/spring-cloud-retry/ 9.2 超时机制http://www.itmuch.com/spring-cloud-sum/spring-cloud-timeout/ 9.3 Swaggerhttps://github.com/dyc87112/swagger-butler https://github.com/SpringForAll/spring-boot-starter-swagger","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot性能优化","slug":"SpringBoot性能优化","date":"2019-07-22T13:48:22.000Z","updated":"2020-11-03T13:04:34.206Z","comments":false,"path":"2019/07/22/SpringBoot性能优化/","link":"","permalink":"https://zhechu.github.io/2019/07/22/SpringBoot性能优化/","excerpt":"","text":"环境说明 环境 说明 spring-boot-2.0.0.RELEASE 企业应用程序框架 1 指定扫描的包若启动类只使用 @SpringBootApplication 且没有加扫描参数。则其会扫描启动类所在包及所在包目录下的所有文件。因此，指定扫描的包，会减少 Spring Boot 启动时扫描的文件，从而提高 Spring Boot 启动效率。 示例：指定扫描包12345678910111213141516package com.wise.example;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication(scanBasePackages = &#123; \"com.wise.example.controller\", \"com.wise.example.service.impl\"&#125;)public class SpringBootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootDemoApplication.class, args); &#125;&#125; 2 使用 Undertow 替代 TomcatTomcat vs. Jetty vs. Undertow: Comparison of Spring Boot Embedded Servlet Containers https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Spring中Bean的ID重复问题解决","slug":"Spring中Bean的ID重复问题解决","date":"2019-07-21T12:25:06.000Z","updated":"2020-11-03T13:04:34.220Z","comments":false,"path":"2019/07/21/Spring中Bean的ID重复问题解决/","link":"","permalink":"https://zhechu.github.io/2019/07/21/Spring中Bean的ID重复问题解决/","excerpt":"","text":"环境说明 环境 说明 spring-4.3.24.RELEASE 企业应用程序框架 AllowBeanDefinitionOverriding 变量控制 Bean id 是否允许重复。若允许，则后面注册的 Bean 会覆盖前面的。若不允许，Spring 在初始化时若检测到重复的 Bean id 则会抛出异常。 1 启动时配置是否允许 Bean id 重复变量注解版12345AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();applicationContext.register(ExtConfig.class);// 不允许重复，当检测存在重复的 Bean id 时，则会抛出异常applicationContext.setAllowBeanDefinitionOverriding(false);applicationContext.refresh(); 2 Spring Boot 配置文件配置是否允许 Bean id 重复变量application.yml1spring.main.allow-bean-definition-overriding: false","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Spring源码详读","slug":"Spring源码详读","date":"2019-07-16T15:31:42.000Z","updated":"2020-11-03T13:04:34.220Z","comments":false,"path":"2019/07/16/Spring源码详读/","link":"","permalink":"https://zhechu.github.io/2019/07/16/Spring源码详读/","excerpt":"","text":"环境说明 环境 说明 spring-5.0.x 企业应用程序框架 官方文档 https://docs.spring.io/spring/docs/5.0.15.RELEASE/spring-framework-reference/ Spring 源码中文注释 https://github.com/zhechu/spring-framework-5.0.x Spring Boot 源码中文注释 https://github.com/zhechu/spring-boot-2.1.5.RELEASE 1 注册组件1.1 @ComponentScan-包扫描+组件标注注解包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）。 @ComponentScan 示例 12345@Configuration@ComponentScan(\"com.wise.controller\")public class AnnotationConfig &#123;&#125; @ComponentScans 示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 配置类==配置文件@Configuration // 告诉Spring这是一个配置类@ComponentScans( value = &#123; @ComponentScan(value=\"com.wise\",includeFilters = &#123; @Filter(type=FilterType.ANNOTATION,classes=&#123;Controller.class&#125;), @Filter(type=FilterType.ASSIGNABLE_TYPE,classes=&#123;BookService.class&#125;), @Filter(type=FilterType.CUSTOM,classes=&#123;MyTypeFilter.class&#125;) &#125;,useDefaultFilters = false) &#125; )//@ComponentScan value:指定要扫描的包//excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件//includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件//FilterType.ANNOTATION：按照注解//FilterType.ASSIGNABLE_TYPE：按照给定的类型；//FilterType.ASPECTJ：使用ASPECTJ表达式//FilterType.REGEX：使用正则指定//FilterType.CUSTOM：使用自定义规则public class MainConfig &#123; /** 给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id */ @Bean(\"person\") public Person person01()&#123; return new Person(\"lisi\", 20); &#125;&#125;public class MyTypeFilter implements TypeFilter &#123; /** * metadataReader：读取到的当前正在扫描的类的信息 * metadataReaderFactory:可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; // TODO Auto-generated method stub //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println(\"---&gt;\"+className); if(className.contains(\"er\"))&#123; return true; &#125; return false; &#125;&#125; 1.2 @Bean通常用于导入的第三方包里面的组件。 1.3 @Import @Import(要导入到容器中的组件)；容器中就会自动注册这个组件，id 默认是全类名 ImportSelector:返回需要导入的组件的全类名数组； ImportBeanDefinitionRegistrar:手动注册 bean 到容器中，官方示例 AspectJAutoProxyRegistrar @Import 示例 12345678910import com.wise.controller.ImportController;import com.wise.service.ImportService;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import(&#123;ImportService.class, ImportController.class&#125;)public class AnnotationConfig &#123;&#125; @Import + ImportSelector 示例 自定义 ImportSelector 类12345678910111213141516171819import org.springframework.context.annotation.ImportSelector;import org.springframework.core.type.AnnotationMetadata;/** * 自定义逻辑返回需要导入的组件 */public class CustomImportSelector implements ImportSelector &#123; /** * 返回值，就是到导入到容器中的组件全类名 * @param importingClassMetadata 当前标注@Import注解的类的所有注解信息 * @return */ @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[]&#123;\"com.wise.controller.ImportController\"&#125;; &#125;&#125; 配置类 123456789import com.wise.selector.CustomImportSelector;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import(&#123;CustomImportSelector.class&#125;)public class AnnotationConfig &#123;&#125; @Import + ImportBeanDefinitionRegistrar 示例 自定义 ImportBeanDefinitionRegistrar 类 1234567891011121314151617181920212223242526import com.wise.controller.RegistrarController;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.RootBeanDefinition;import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;import org.springframework.core.type.AnnotationMetadata;public class CustomImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * * @param importingClassMetadata 当前类的注解信息 * @param registry 注册类 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 判断是否已经定义，若还未注册，则执行注册逻辑 boolean defined = registry.containsBeanDefinition(\"com.wise.controller.RegistrarController\"); if (!defined) &#123; // 指定Bean定义信息 RootBeanDefinition registrarControllerBeanDefinition = new RootBeanDefinition(RegistrarController.class); // 注册 Bean，指定 Bean 名 registry.registerBeanDefinition(\"CustomRegistrarController\", registrarControllerBeanDefinition); &#125; &#125;&#125; 配置类 123456789import com.wise.registrar.CustomImportBeanDefinitionRegistrar;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@Import(&#123;CustomImportBeanDefinitionRegistrar.class&#125;)public class AnnotationConfig &#123;&#125; 1.4 FactoryBean 示例：自定义 FactoryBean 自定义 FactoryBean 类 12345678910111213141516171819202122232425262728293031import com.wise.controller.FactoryController;import org.springframework.beans.factory.FactoryBean;public class ControllerFactoryBean implements FactoryBean&lt;FactoryController&gt; &#123; /** * 返回对象并加入 Spring 容器中 * @return * @throws Exception */ @Override public FactoryController getObject() throws Exception &#123; System.out.println(\"init factoryController instance\"); return new FactoryController(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return FactoryController.class; &#125; /** * 是否为单例 * @return */ @Override public boolean isSingleton() &#123; return true; &#125;&#125; 配置类 1234567891011121314151617import com.wise.factory.ControllerFactoryBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AnnotationConfig &#123; /** * 将工厂 Bean 注入 Spring 容器，但其实际类型为 com.wise.controller.FactoryController * @return */ @Bean public ControllerFactoryBean controllerFactoryBean() &#123; return new ControllerFactoryBean(); &#125;&#125; 单元测试 123456789101112131415161718@Testpublic void factoryBeanTest() throws Exception &#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); System.out.println(\"container start up\"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; // 此时真正注册的 Bean 才会初始化 FactoryController factoryController = applicationContext.getBean(FactoryController.class); FactoryController factoryControllerTemp = applicationContext.getBean(FactoryController.class); System.out.println(factoryController == factoryControllerTemp); factoryController.say(\"zhangsan\");&#125; 2 @Configuration-注册配置3 注册条件3.1 @Conditional示例：是在 Linux 系统上运行才注册 条件类123456789101112131415161718192021import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;/** * 判断是否windows系统 */public class WindowsCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment environment = context.getEnvironment(); String property = environment.getProperty(\"os.name\"); if(property.contains(\"Windows\"))&#123; return true; &#125; return false; &#125;&#125; 配置类12345678910111213141516171819202122232425262728293031import com.wise.bean.Person;import com.wise.condition.LinuxCondition;import com.wise.controller.LazyController;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Lazy;//@Conditional(&#123;WindowsCondition.class&#125;) // 满足当前条件，这个类中配置的所有 bean 注册才能生效@Conditional(&#123;LinuxCondition.class&#125;) // 满足当前条件，这个类中配置的所有 bean 注册才能生效@Configurationpublic class AnnotationConfig &#123; @Bean public Person person() &#123; System.out.println(\"person created\"); Person person = new Person(); person.setId(\"1\"); person.setName(\"张三\"); person.setAge(20); return person; &#125; @Bean @Lazy public LazyController lazyController() &#123; System.out.println(\"lazyController created\"); return new LazyController(); &#125;&#125; 3.2 @ConditionalOnProperty@ConditionalOnProperty 为 Spring Boot 注解，可用于自定义 spring boot starter！ 示例：自定义 spring boot starter 自动配置类123456789@Configuration@EnableConfigurationProperties(&#123; QiaokuCommonSmsProperties.class, QiaokuCommonAliyunProperties.class, QiaokuCommonRongCloudProperties.class&#125;)@ConditionalOnProperty(name = \"qiaoku.common.enabled\", matchIfMissing = true)public class QiaokuCommonAutoConfigure &#123;&#125; 示例：Apollo 配置中心 configservice 组件是否启用 eureka 条件类12345678910111213141516package com.ctrip.framework.apollo.configservice;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.context.annotation.Configuration;/** * Start Eureka Client annotations according to configuration * * @author Zhiqiang Lin(linzhiqiang0514@163.com) */@Configuration@EnableEurekaClient@ConditionalOnProperty(name = \"apollo.eureka.client.enabled\", havingValue = \"true\", matchIfMissing = true)public class ConfigServerEurekaClientConfigure &#123;&#125; TIPS：Apollo 源码解析链接 http://www.iocoder.cn/categories/Apollo/ 4 @Lazy-懒注册 Bean 延迟初始化示例123456@Bean@Lazy // 第一次用时才注册public LazyController lazyController() &#123; System.out.println(\"lazyController created\"); return new LazyController();&#125; 解决循环依赖示例123456789101112/** * 拦截器， */@Component@Slf4jpublic class PunishInterceptor implements HandlerInterceptor &#123; @Autowired @Lazy // 解决循环依赖 BUG，Controller 中也依赖 UserService 导致间接循环依赖 UserService userService;&#125; 5 Bean 的生命周期5.1 指定初始化和销毁方法 通过 @Bean 指定 init-method 和 destroy-method Bean 实现 InitializingBean（定义初始化逻辑）和 DisposableBean（定义销毁逻辑） @PostConstruct 和 @PreDestroy 实现 BeanPostProcessor 接口。postProcessBeforeInitialization 方法在 init 方法被回调之前执行，postProcessAfterInitialization 在 init 方法被回调之后执行 实现 InstantiationAwareBeanPostProcessor 接口。postProcessBeforeInstantiation 在构造器之前执行，postProcessAfterInstantiation 在构造器之后执行，postProcessPropertyValues 在 postProcessAfterInstantiation 之后执行且在 postProcessBeforeInitialization 之前执行 初始化：对象创建完成，并赋值好，调用初始化方法。 销毁：容器关闭的时候调用销毁方法。多实例下，容器不会调用销毁方法。 5.1.1 示例：指定 init-method 和 destroy-methodBean 类 12345678910111213141516171819public class LifeCycleController &#123; public LifeCycleController()&#123; System.out.println(\"lifeCycleController constructor...\"); &#125; public void init()&#123; System.out.println(\"lifeCycleController ... init...\"); &#125; public void detory()&#123; System.out.println(\"lifeCycleController ... detory...\"); &#125; public void say(String name) &#123; System.out.println(\"hello \" + name); &#125;&#125; 配置类12345678910111213import com.wise.controller.LifeCycleController;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AnnotationConfig &#123; @Bean(initMethod = \"init\", destroyMethod = \"detory\") public LifeCycleController lifeCycleController() &#123; return new LifeCycleController(); &#125;&#125; 单元测试 123456789101112131415161718@Testpublic void lifeCycleTest() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); System.out.println(\"container start up\"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; LifeCycleController lifeCycleController = applicationContext.getBean(LifeCycleController.class); lifeCycleController.say(\"zhangsan\"); // 关闭容器 applicationContext.close();&#125; 控制台输出 12345678910111213lifeCycleController constructor...lifeCycleController ... init...container start uporg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryannotationConfiglifeCycleControllerhello zhangsanlifeCycleController ... detory... 5.1.2 示例：实现 InitializingBean 和 DisposableBeanBean 类 123456789101112131415161718192021222324import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;public class LifeCycleController implements InitializingBean, DisposableBean &#123; public LifeCycleController()&#123; System.out.println(\"lifeCycleController constructor...\"); &#125; @Override public void destroy() throws Exception &#123; System.out.println(\"lifeCycleController ... detory...\"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(\"lifeCycleController ... init...\"); &#125; public void say(String name) &#123; System.out.println(\"hello \" + name); &#125;&#125; 配置类12345678910111213import com.wise.controller.LifeCycleController;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AnnotationConfig &#123; @Bean public LifeCycleController lifeCycleController() &#123; return new LifeCycleController(); &#125;&#125; 单元测试 123456789101112131415161718@Testpublic void lifeCycleTest() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); System.out.println(\"container start up\"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; LifeCycleController lifeCycleController = applicationContext.getBean(LifeCycleController.class); lifeCycleController.say(\"zhangsan\"); // 关闭容器 applicationContext.close();&#125; 控制台输出 12345678910111213lifeCycleController constructor...lifeCycleController ... init...container start uporg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryannotationConfiglifeCycleControllerhello zhangsanlifeCycleController ... detory... 5.1.3 示例：@PostConstruct 和 @PreDestroyBean 类 123456789101112131415161718192021222324import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;public class LifeCycleController &#123; public LifeCycleController()&#123; System.out.println(\"lifeCycleController constructor...\"); &#125; @PreDestroy public void destroy() throws Exception &#123; System.out.println(\"lifeCycleController ... detory...\"); &#125; @PostConstruct public void afterPropertiesSet() throws Exception &#123; System.out.println(\"lifeCycleController ... init...\"); &#125; public void say(String name) &#123; System.out.println(\"hello \" + name); &#125;&#125; 配置类12345678910111213import com.wise.controller.LifeCycleController;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AnnotationConfig &#123; @Bean public LifeCycleController lifeCycleController() &#123; return new LifeCycleController(); &#125;&#125; 单元测试 123456789101112131415161718@Testpublic void lifeCycleTest() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); System.out.println(\"container start up\"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; LifeCycleController lifeCycleController = applicationContext.getBean(LifeCycleController.class); lifeCycleController.say(\"zhangsan\"); // 关闭容器 applicationContext.close();&#125; 控制台输出 12345678910111213lifeCycleController constructor...lifeCycleController ... init...container start uporg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryannotationConfiglifeCycleControllerhello zhangsanlifeCycleController ... detory... 5.1.4 示例：实现 BeanPostProcessor 接口自定义 Bean 的后置处理器，官方示例： ApplicationContextAwareProcessor， InitDestroyAnnotationBeanPostProcessor， AsyncAnnotationBeanPostProcessor， AutowiredAnnotationBeanPostProcessor TIPS：可以结合 @order 注解或 PriorityOrdered 接口控制 BeanPostProcessor 的执行顺序。 12345678910111213141516171819202122import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class CustomBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"postProcessBeforeInitialization...\" + beanName + \"===&gt;\" + bean); // bean 可以经过包装后再返回 return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"postProcessAfterInitialization...\" + beanName + \"===&gt;\" + bean); // bean 可以经过包装后再返回 return bean; &#125;&#125; 配置类12345678910111213141516171819import com.wise.controller.LifeCycleController;import com.wise.processor.CustomBeanPostProcessor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class AnnotationConfig &#123; @Bean public LifeCycleController lifeCycleController() &#123; return new LifeCycleController(); &#125; @Bean public CustomBeanPostProcessor customBeanPostProcessor() &#123; return new CustomBeanPostProcessor(); &#125;&#125; 单元测试 123456789101112131415161718@Testpublic void lifeCycleTest() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); System.out.println(\"container start up\"); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) &#123; System.out.println(beanDefinitionName); &#125; LifeCycleController lifeCycleController = applicationContext.getBean(LifeCycleController.class); lifeCycleController.say(\"zhangsan\"); // 关闭容器 applicationContext.close();&#125; 控制台输出 1234567891011121314151617181920postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerProcessor===&gt;org.springframework.context.event.EventListenerMethodProcessor@62bd765postProcessAfterInitialization...org.springframework.context.event.internalEventListenerProcessor===&gt;org.springframework.context.event.EventListenerMethodProcessor@62bd765postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerFactory===&gt;org.springframework.context.event.DefaultEventListenerFactory@78a2da20postProcessAfterInitialization...org.springframework.context.event.internalEventListenerFactory===&gt;org.springframework.context.event.DefaultEventListenerFactory@78a2da20lifeCycleController constructor...postProcessBeforeInitialization...lifeCycleController===&gt;com.wise.controller.LifeCycleController@ba8d91clifeCycleController ... init...postProcessAfterInitialization...lifeCycleController===&gt;com.wise.controller.LifeCycleController@ba8d91ccontainer start uporg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryannotationConfiglifeCycleControllercustomBeanPostProcessorhello zhangsanlifeCycleController ... detory... 6 属性注入6.1 @Value@Value 参数允许的数据类型 基本数值 SpEL：#{} ${}：取出配置文件 properties 中或环境变量中的值 TIPS：使用 @PropertySource 注解可以加载属性配置文件。 获取环境变量示例：获取操作系统名称123ConfigurableEnvironment environment = applicationContext.getEnvironment();String property = environment.getProperty(\"os.name\");System.out.println(property); 6.2 BeanPostProcessor 方式6.3 @Autowired执行逻辑 默认优先按照类型去容器中找对应的组件，找到则赋值 若找到多个相同类型的组件，再将属性的名称作为组件的 id 到容器中查找 @Qualifier(&quot;id&quot;)：使用 @Qualifier 指定需要装配的组件的 id，而不是使用属性名 自动装配默认一定要将属性赋值好，没有则会报错。可以使用 @Autowired(required=false) 避免报错 @Primary：在自动装配的时，默认使用首选的 bean 标注在如下位置都可以注入组件 [标注在方法位置]：@Bean+方法参数；参数从容器中获取；默认不写 @Autowired 效果是一样的；都能自动装配 [标在构造器上]：若组件只有一个有参构造器，这个有参构造器的 @Autowired 可以省略，参数位置的组件还是可以自动从容器中获取 [标在形参上]：参数位置的组件还是可以自动从容器中获取 7 Aware 接口自定义组件实现 Aware 接口，在创建对象的时，会调用接口规定的方法注入相关组件。 示例 Aware 实现类123456789101112131415161718192021222324252627282930313233343536373839404142import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanNameAware;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.EmbeddedValueResolverAware;import org.springframework.stereotype.Component;import org.springframework.util.StringValueResolver;@Componentpublic class CustomAware implements ApplicationContextAware, BeanNameAware, EmbeddedValueResolverAware &#123; private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125; public ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 本对象实例在容器里的 id * @param name */ @Override public void setBeanName(String name) &#123; System.out.println(\"bean name: \" + name); &#125; /** * 解析字符串 * @param resolver */ @Override public void setEmbeddedValueResolver(StringValueResolver resolver) &#123; String resolveStringValue = resolver.resolveStringValue(\"Hello $&#123;os.name&#125;, math cal result: #&#123;21*13&#125;\"); System.out.println(\"resolve result: \" + resolveStringValue); &#125;&#125; 配置类12345678import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(value = \"com.wise\")public class AnnotationConfig &#123;&#125; 单元测试123456789@Testpublic void awareTest()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); CustomAware customAware = applicationContext.getBean(CustomAware.class); ApplicationContext applicationContextTemp = customAware.getApplicationContext(); System.out.println(applicationContext == applicationContextTemp);&#125; 控制台输出123bean name: customAwareresolve result: Hello Windows 7, math cal result: 273true 8 @Profile根据环境激活组件。 9 AOP通知类型 前置通知(@Before)：在目标方法运行之前运行 后置通知(@After)：在目标方法运行结束之后运行（无论方法正常结束还是异常结束） 返回通知(@AfterReturning)：在目标方法正常返回之后运行 异常通知(@AfterThrowing)：在目标方法出现异常以后运行 环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()） 9.1 原理AOP 实现原理：链式调用。 创建和注册 AnnotationAwareAspectJAutoProxyCreator 的过程1）、传入配置类，创建ioc容器2）、注册配置类，调用refresh（）刷新容器；3）、registerBeanPostProcessors(beanFactory);注册bean的后置处理器来方便拦截bean的创建；– 3.1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor– 3.2）、给容器中加别的BeanPostProcessor– 3.3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；– 3.4）、再给容器中注册实现了Ordered接口的BeanPostProcessor；– 3.5）、注册没实现优先级接口的BeanPostProcessor；– 3.6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象，保存在容器中；—- 3.6.1）、创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】的bean实例—- 3.6.2）、populateBean；给bean的各种属性赋值—- 3.6.3）、initializeBean：初始化bean；—— 3.6.3.1）、invokeAwareMethods()：处理Aware接口的方法回调—— 3.6.3.2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）—— 3.6.3.3）、invokeInitMethods()；执行自定义的初始化方法—— 3.6.3.4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；—- 3.6.4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；–&gt; aspectJAdvisorsBuilder– 3.7）、把BeanPostProcessor注册到BeanFactory中；beanFactory.addBeanPostProcessor(postProcessor); 9.2 示例 处理日志 业务类 1234567891011/** * 数学运算器 */public class MathCalculator &#123; public int div(int i, int j) &#123; System.out.println(\"MathCalculator...div...\"); return i / j; &#125;&#125; 日志类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import java.util.Arrays;/** * 使用切面处理日志 */@Aspectpublic class LogAspects &#123; /** * 抽取公共的切入点表达式 */ @Pointcut(\"execution(public int com.wise.aop.MathCalculator.*(..))\") public void pointCut()&#123;&#125;; /** * @Before在目标方法之前切入；切入点表达式（指定在哪个方法切入） */ @Before(\"pointCut()\") public void logStart(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); System.out.println(joinPoint.getSignature().getName() + \"运行。。。@Before:参数列表是：&#123;\" + Arrays.asList(args) + \"&#125;\"); &#125; @After(\"com.wise.aop.LogAspects.pointCut()\") public void logEnd(JoinPoint joinPoint)&#123; System.out.println(joinPoint.getSignature().getName() + \"结束。。。@After\"); &#125; /** * JoinPoint 一定要出现在参数表的第一位 * @param joinPoint * @param result */ @AfterReturning(value=\"pointCut()\",returning=\"result\") public void logReturn(JoinPoint joinPoint, Object result)&#123; System.out.println(joinPoint.getSignature().getName() + \"正常返回。。。@AfterReturning:运行结果：&#123;\" + result + \"&#125;\"); &#125; @AfterThrowing(value=\"pointCut()\", throwing=\"exception\") public void logException(JoinPoint joinPoint, Exception exception)&#123; System.out.println(joinPoint.getSignature().getName() + \"异常。。。异常信息：&#123;\" + exception + \"&#125;\"); &#125;&#125; 配置类 1234567891011121314151617181920212223242526272829import com.wise.aop.LogAspects;import com.wise.aop.MathCalculator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@EnableAspectJAutoProxy@Configurationpublic class AnnotationConfig &#123; /** * 业务逻辑类加入容器中 * @return */ @Bean public MathCalculator calculator()&#123; return new MathCalculator(); &#125; /** * 切面类加入到容器中 * @return */ @Bean public LogAspects logAspects()&#123; return new LogAspects(); &#125;&#125; 单元测试 12345678@Testpublic void aopTest()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AnnotationConfig.class); MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class); mathCalculator.div(1, 0);&#125; 控制台输出 1234div运行。。。@Before:参数列表是：&#123;[1, 0]&#125;MathCalculator...div...div结束。。。@Afterdiv异常。。。异常信息：&#123;java.lang.ArithmeticException: / by zero&#125; 10 Transaction 示例：声明式事务 业务类 123456789101112131415161718192021import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class UserService &#123; @Autowired private UserDao userDao; @Transactional public void insertUser()&#123; userDao.insert(); System.out.println(\"插入完成...\"); // 将会报错 int i = 10 / 0; &#125;&#125; 持久层类 12345678910111213141516171819import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;import java.util.UUID;@Repositorypublic class UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void insert()&#123; String sql = \"INSERT INTO `tbl_user`(username,age) VALUES(?,?)\"; String username = UUID.randomUUID().toString().substring(0, 5); jdbcTemplate.update(sql, username, 19); &#125;&#125; 配置类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;/** * 声明式事务： * * 环境搭建： * 1、导入相关依赖 * 数据源、数据库驱动、Spring-jdbc模块 * 2、配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据 * 3、给方法上标注 @Transactional 表示当前方法是一个事务方法； * 4、 @EnableTransactionManagement 开启基于注解的事务管理功能； * @EnableXXX * 5、配置事务管理器来控制事务; * @Bean * public PlatformTransactionManager transactionManager() */@EnableTransactionManagement@ComponentScan(\"com.wise.tx\")@Configurationpublic class TxConfig &#123; /** * 数据源 * @return * @throws Exception */ @Bean public DataSource dataSource() throws Exception&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setUser(\"root\"); dataSource.setPassword(\"123456\"); dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/mysql_test\"); return dataSource; &#125; @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource) throws Exception&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); return jdbcTemplate; &#125; /** * 注册事务管理器在容器中 * @return * @throws Exception */ @Bean public PlatformTransactionManager transactionManager() throws Exception&#123; return new DataSourceTransactionManager(dataSource()); &#125;&#125; 单元测试 123456789101112131415import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TxTest &#123; @Test public void insertTest()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class); UserService userService = applicationContext.getBean(UserService.class); userService.insertUser(); applicationContext.close(); &#125;&#125; 11 Extend11.1 BeanFactoryPostProcessor在 BeanFactory 标准初始化之后调用，以定制和修改 BeanFactory 的内容。所有的 Bean 定义已经保存加载到 BeanFactory，但是 Bean 的实例还未创建 示例 配置类 12345678import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@ComponentScan(\"com.wise.ext\")@Configurationpublic class ExtConfig &#123;&#125; 业务类 1234567891011121314import org.springframework.stereotype.Service;@Servicepublic class ExtService &#123; public ExtService() &#123; System.out.println(\"ExtService...constructor\"); &#125; public void extFunction() &#123; System.out.println(\"ExtService...extFunction...\"); &#125;&#125; 优先级较高的 BeanFactoryPostProcessor 类 1234567891011121314151617181920212223242526272829import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.core.PriorityOrdered;import org.springframework.stereotype.Component;/** * 优先级较高的 BeanFactoryPostProcessor */@Componentpublic class PriorityOrderedBeanFactoryPostProcessor implements BeanFactoryPostProcessor, PriorityOrdered &#123; /** * 在 BeanFactory 标准初始化之后调用，以定制和修改 BeanFactory 的内容。 * 所有的bean定义已经保存加载到 beanFactory，但是bean的实例还未创建 * @param beanFactory * @throws BeansException */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(\"PriorityOrderedBeanFactoryPostProcessor...postProcessBeanFactory...\"); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; 优先级比实现 PriorityOrdered 接口的 BeanFactoryPostProcessor 接口略低的类 1234567891011121314151617181920212223242526272829import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.core.Ordered;import org.springframework.stereotype.Component;/** * 优先级比实现 PriorityOrdered 接口的 BeanFactoryPostProcessor 接口略低 */@Componentpublic class OrderedBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered &#123; /** * 在 BeanFactory 标准初始化之后调用，以定制和修改 BeanFactory 的内容。 * 所有的bean定义已经保存加载到 beanFactory，但是bean的实例还未创建 * @param beanFactory * @throws BeansException */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(\"OrderedBeanFactoryPostProcessor...postProcessBeanFactory...\"); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; 无优先级 BeanFactoryPostProcessor 类 1234567891011121314151617181920212223242526272829303132import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanFactoryPostProcessor;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.stereotype.Component;@Componentpublic class CustomBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123; /** * 在 BeanFactory 标准初始化之后调用，以定制和修改 BeanFactory 的内容。 * 所有的bean定义已经保存加载到 beanFactory，但是bean的实例还未创建 * @param beanFactory * @throws BeansException */ @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(\"CustomBeanFactoryPostProcessor...postProcessBeanFactory...start...\"); // 获取已定义的 Bean 的数量 int count = beanFactory.getBeanDefinitionCount(); System.out.println(\"当前BeanFactory中有\" + count + \"个Bean\"); // 获取已定义的 Bean 的名称 String[] names = beanFactory.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(name); &#125; System.out.println(\"CustomBeanFactoryPostProcessor...postProcessBeanFactory...end...\"); &#125;&#125; 单元测试 12345678910111213import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ExtTest &#123; @Test public void beanFactoryPostProcessorTest()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class); applicationContext.close(); &#125;&#125; 控制台输出 1234567891011121314151617PriorityOrderedBeanFactoryPostProcessor...postProcessBeanFactory...OrderedBeanFactoryPostProcessor...postProcessBeanFactory...CustomBeanFactoryPostProcessor...postProcessBeanFactory...start...当前BeanFactory中有11个Beanorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigcustomBeanFactoryPostProcessorextServiceorderedBeanFactoryPostProcessorpriorityOrderedBeanFactoryPostProcessorCustomBeanFactoryPostProcessor...postProcessBeanFactory...end...ExtService...constructor 11.2 BeanDefinitionRegistryPostProcessor在所有 Bean 定义信息要被加载前执行。先于 BeanFactoryPostProcessor 执行。可用于注册第三方组件。 示例：类似 11.1 节示例，但添加 BeanDefinitionRegistryPostProcessor 实现类 BeanDefinitionRegistryPostProcessor 实现类 123456789101112131415161718192021222324252627282930313233import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.AbstractBeanDefinition;import org.springframework.beans.factory.support.BeanDefinitionBuilder;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;import org.springframework.stereotype.Component;/** * 在所有 Bean 定义信息要被加载前执行。先于 BeanFactoryPostProcessor 执行 */@Componentpublic class CustomBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123; /** * BeanDefinitionRegistry：Bean定义信息的保存中心， * 以后 BeanFactory 就是按照 BeanDefinitionRegistry 里面保存的每一个 Bean 定义信息创建 Bean 的实例 */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123; System.out.println(\"CustomBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry...bean 的数量：\" + registry.getBeanDefinitionCount()); // 注册 Bean AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(ExtService.class).getBeanDefinition(); registry.registerBeanDefinition(\"ThirdPartyExtService\", beanDefinition); &#125; @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; System.out.println(\"CustomBeanDefinitionRegistryPostProcessor...postProcessBeanFactory...bean 的数量：\" + beanFactory.getBeanDefinitionCount()); &#125;&#125; 单元测试 123456789101112131415import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class TxTest &#123; @Test public void insertTest()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TxConfig.class); UserService userService = applicationContext.getBean(UserService.class); userService.insertUser(); applicationContext.close(); &#125;&#125; 控制台输出 12345678910111213141516171819202122CustomBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry...bean 的数量：12CustomBeanDefinitionRegistryPostProcessor...postProcessBeanFactory...bean 的数量：13PriorityOrderedBeanFactoryPostProcessor...postProcessBeanFactory...OrderedBeanFactoryPostProcessor...postProcessBeanFactory...CustomBeanFactoryPostProcessor...postProcessBeanFactory...start...当前BeanFactory中有13个Beanorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactoryextConfigcustomBeanDefinitionRegistryPostProcessorcustomBeanFactoryPostProcessorextServiceorderedBeanFactoryPostProcessorpriorityOrderedBeanFactoryPostProcessorThirdPartyExtServiceCustomBeanFactoryPostProcessor...postProcessBeanFactory...end...ExtService...constructorExtService...constructor 11.3 ApplicationListener监听容器中发布的事件。 步骤 定义事件 定义监听器（ApplicationListener 的实现类）用于监听某个事件（ApplicationEvent 及其子类） 把监听器加入到容器 发布事件 11.3.1 示例：同步发送邮件定义事件 123456789101112131415161718192021222324252627import org.springframework.context.ApplicationContext;import org.springframework.context.event.ApplicationContextEvent;/** * 邮件发送事件 */public class MailSendEvent extends ApplicationContextEvent &#123; private String to; private String content; public MailSendEvent(ApplicationContext source, String to, String content) &#123; super(source); this.to = to; this.content = content; &#125; public String getTo() &#123; return to; &#125; public String getContent() &#123; return content; &#125;&#125; 定义监听器 123456789101112131415import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * 邮件监听器 */@Componentpublic class MailSendListener &#123; @EventListener public void onMailSendEvent(MailSendEvent event) &#123; System.out.println(\"当前线程：\" + Thread.currentThread() + \"，MailSendListener：向\" + event.getTo() + \"发送：\" + event.getContent()); &#125;&#125; 定义发送器 12345678910111213141516171819202122232425import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.stereotype.Component;/** * 邮件发送器 */@Componentpublic class MailSender implements ApplicationContextAware &#123; private ApplicationContext ctx ; public void setApplicationContext(ApplicationContext ctx) &#123; this.ctx = ctx; &#125; public void sendMail(String to, String content)&#123; System.out.println(\"当前线程：\" + Thread.currentThread() + \"，MailSender：模拟发送邮件...\"); // 发布事件 MailSendEvent mse = new MailSendEvent(this.ctx, to, content); ctx.publishEvent(mse); &#125;&#125; 配置类 12345678import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@ComponentScan(\"com.wise.ext\")@Configurationpublic class ExtConfig &#123;&#125; 单元测试 1234567891011121314151617import com.wise.ext.listener.MailSender;import org.junit.Test;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ExtTest &#123; @Test public void listenerTest()&#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ExtConfig.class); MailSender mailSender = applicationContext.getBean(MailSender.class); mailSender.sendMail(\"xxx@qq.com\", \"Hello xxx.\"); applicationContext.close(); &#125;&#125; 控制台输出 12当前线程：Thread[main,5,main]，MailSender：模拟发送邮件...当前线程：Thread[main,5,main]，MailSendListener：向xxx@qq.com发送：Hello xxx. 11.3.2 示例：异步发送邮件类似 11.3.1 节，但配置类自定义事件广播器。 定义监听器，使用懒加载，节省资源 123456789101112131415161718192021import org.springframework.context.annotation.Lazy;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * 邮件监听器 */@Component@Lazy // 懒加载public class MailSendListener &#123; public MailSendListener() &#123; System.out.println(\"MailSendListener...constructor\"); &#125; @EventListener// @EventListener(classes = MailSendEvent.class) public void onMailSendEvent(MailSendEvent event) &#123; System.out.println(\"当前线程：\" + Thread.currentThread() + \"，MailSendListener：向\" + event.getTo() + \"发送：\" + event.getContent()); &#125;&#125; 配置类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.event.SimpleApplicationEventMulticaster;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;import java.util.concurrent.ThreadPoolExecutor;@ComponentScan(\"com.wise.ext\")@Configurationpublic class ExtConfig &#123; /** * 任务线程池 * @return */ @Bean public Executor taskExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(2); // 核心线程大小 taskExecutor.setMaxPoolSize(8); // 最大线程大小 taskExecutor.setQueueCapacity(100); // 等待队列长度 taskExecutor.setKeepAliveSeconds(60); // 空闲时保持60秒就销毁 taskExecutor.setThreadNamePrefix(\"taskExecutor-\"); // rejection-policy：当pool已经达到max size的时候，如何处理新任务 // CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行 taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); taskExecutor.initialize(); return taskExecutor; &#125; /** * 覆盖默认事件广播器，设置任务线程池 * @param taskExecutor * @return */ @Bean public SimpleApplicationEventMulticaster applicationEventMulticaster(Executor taskExecutor) &#123; SimpleApplicationEventMulticaster applicationEventMulticaster = new SimpleApplicationEventMulticaster(); applicationEventMulticaster.setTaskExecutor(taskExecutor); return applicationEventMulticaster; &#125;&#125; 单元测试 123456789101112131415161718192021import org.springframework.context.annotation.Lazy;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;/** * 邮件监听器 */@Component@Lazy // 懒加载public class MailSendListener &#123; public MailSendListener() &#123; System.out.println(\"MailSendListener...constructor\"); &#125; @EventListener// @EventListener(classes = MailSendEvent.class) public void onMailSendEvent(MailSendEvent event) &#123; System.out.println(\"当前线程：\" + Thread.currentThread() + \"，MailSendListener：向\" + event.getTo() + \"发送：\" + event.getContent()); &#125;&#125; 控制台输出 1234容器已启动当前线程：Thread[main,5,main]，MailSender：模拟发送邮件...MailSendListener...constructor当前线程：Thread[taskExecutor-1,5,main]，MailSendListener：向xxx@qq.com发送：Hello xxx. 12 Start-up processSpring 容器的 refresh()。 12.1 prepareRefresh() 刷新前的预处理 initPropertySources() 初始化一些属性设置；子类自定义个性化的属性设置方法 getEnvironment().validateRequiredProperties() 检验属性的合法等 earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;() 保存容器中的一些早期的事件 12.2 obtainFreshBeanFactory() 获取 BeanFactory refreshBeanFactory() 刷新/创建 BeanFactory：创建 this.beanFactory = new DefaultListableBeanFactory() 并设置 id getBeanFactory() 返回刚才 GenericApplicationContext 创建的 BeanFactory 对象 将创建的 DefaultListableBeanFactory 返回 12.3 prepareBeanFactory(beanFactory) BeanFactory 的预准备工作 设置 BeanFactory 的类加载器、支持表达式解析器等 添加部分 BeanPostProcessor，如：ApplicationContextAwareProcessor 设置忽略的自动装配的接口 EnvironmentAware、EmbeddedValueResolverAware 等 注册可以解析的自动装配。可以直接在任何组件中自动注入：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext 添加 BeanPostProcessor【ApplicationListenerDetector】 添加编译时的 AspectJ 给 BeanFactory 中注册一些能用的组件，如：environment【ConfigurableEnvironment】、systemProperties【Map&lt;String, Object&gt;】、systemEnvironment【Map&lt;String, Object&gt;】 12.4 postProcessBeanFactory(beanFactory) BeanFactory 准备工作后的后置处理子类通过重写这个方法以在 BeanFactory 创建并预准备完成以后做进一步的设置。 12.5 invokeBeanFactoryPostProcessors(beanFactory) 执行 BeanFactoryPostProcessor 方法BeanFactoryPostProcessor：BeanFactory 的后置处理器。在 BeanFactory 标准初始化之后执行。两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 先执行 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry 方法 获取所有的 BeanDefinitionRegistryPostProcessor 先执行实现了 PriorityOrdered 优先级接口的 BeanDefinitionRegistryPostProcessor、postProcessor.postProcessBeanDefinitionRegistry(registry) 再执行实现了 Ordered 顺序接口的 BeanDefinitionRegistryPostProcessor、postProcessor.postProcessBeanDefinitionRegistry(registry) 最后执行没有实现任何优先级或者是顺序接口的 BeanDefinitionRegistryPostProcessors、postProcessor.postProcessBeanDefinitionRegistry(registry) 再执行 BeanFactoryPostProcessor 的 postProcessBeanFactory 方法 获取所有的 BeanFactoryPostProcessor 先执行实现了 PriorityOrdered 优先级接口的 BeanFactoryPostProcessor、postProcessor.postProcessBeanFactory() 再执行实现了 Ordered 顺序接口的 BeanFactoryPostProcessor、postProcessor.postProcessBeanFactory() 最后执行没有实现任何优先级或者是顺序接口的 BeanFactoryPostProcessor、postProcessor.postProcessBeanFactory() 12.6 registerBeanPostProcessors(beanFactory) 注册 BeanPostProcessor（Bean 的后置处理器）不同接口类型的 BeanPostProcessor，在 Bean 创建前后的执行时机是不一样的。如：BeanPostProcessor、DestructionAwareBeanPostProcessor、InstantiationAwareBeanPostProcessor、SmartInstantiationAwareBeanPostProcessor、MergedBeanDefinitionPostProcessor 获取所有的 BeanPostProcessor 后置处理器默认都可以通过 PriorityOrdered、Ordered 接口区分优先级 先注册 PriorityOrdered 优先级接口的 BeanPostProcessor 再注册 Ordered 接口的 BeanPostProcessor 最后注册没有实现任何优先级接口的 BeanPostProcessor 最终注册 MergedBeanDefinitionPostProcessor 注册 ApplicationListenerDetector 用于在 Bean 创建完成后检查是否是 ApplicationListener，若是则执行 applicationContext.addApplicationListener((ApplicationListener&lt;?&gt;) bean) 12.7 initMessageSource() 初始化 MessageSource 组件（做国际化功能；消息绑定，消息解析） 获取 BeanFactory 检查容器中是否有 id 为 messageSource 且类型是 MessageSource 的组件，若有则赋值给 messageSource，反之则创建一个 DelegatingMessageSource 将创建后的 MessageSource 注册在容器中，以后获取国际化配置文件的值时，可以自动注入 MessageSource 12.8 initApplicationEventMulticaster() 初始化事件派发器 获取 BeanFactory 从 BeanFactory 中获取 applicationEventMulticaster 的 ApplicationEventMulticaster 若上一步没有配置，则创建 SimpleApplicationEventMulticaster 并将其添加到 BeanFactory 中，以后其他组件可以直接自动注入 12.9 onRefresh() 留给子容器（子类）重写子类若重写这个方法，在容器刷新的时候可以自定义逻辑。 12.10 registerListeners() 注册监听器 从容器中获取所有的 ApplicationListener 将每个监听器添加到事件派发器中 派发之前步骤产生的事件 12.11 finishBeanFactoryInitialization(beanFactory) 初始化所有剩下的单实例 Bean12.12 finishRefresh() 完成 BeanFactory 的初始化创建工作IOC 容器就此创建完成。 initLifecycleProcessor(); 初始化和生命周期有关的后置处理器，LifecycleProcessor 默认从容器中找是否有 lifecycleProcessor 的组件（LifecycleProcessor）。若没有则 new DefaultLifecycleProcessor(); 并加入到容器 getLifecycleProcessor().onRefresh(); 获取前面定义的生命周期处理器（BeanFactory），回调 onRefresh() 方法 publishEvent(new ContextRefreshedEvent(this)); 发布容器刷新完成事件 liveBeansView.registerApplicationContext(this); 13 核心类 核心类 说明 AliasRegistry 定义对 alias 的 CRUD 操作 SimpleAliasRegistry 主要使用 map 作为 alias 的缓存，并对接口 AliasRegistry 进行实现 SingletonBeanRegistry 定义对单例的注册及获取 BeanFactory 定义获取 bean 及 bean 的各种属性 DefaultSingletonBeanRegistry 对接口 SingletonBeanRegistry 各函数的实现 HierarchicalBeanFactory 继承 BeanFactory，在 BeanFactory 定义的功能基础上增加对 parentFactory 的支持 BeanDefinitionRegistry 定义对 BeanDefinition 的各种增删改操作 FactoryBeanRegistrySupport 在 DefaultSingletonBeanRegistry 基础上增加对 FactoryBean 的特殊功能 ConfigurableBeanFactory 提供配置 Factory 的各种方法 ListableBeanFactory 根据各种条件获取 bean 的配置清单 AbstractBeanFactory 综合 FactoryBeanRegistrySupport 和 ConfigurableBeanFactory 的功能 AutowireCapableBeanFactory 提供创建 bean、自动注入、初始化以及应用 bean 的后处理器 AbstractAutowireCapableBeanFactory 综合 AbastractBeanFactory 并实现 AutowireCapableBeanFactory ConfigurableListableBeanFactory BeanFactory 配置清单 DefaultListableBeanFactory 主要对 bean 注册的后处理 ResourceLoader 定义资源加载器，主要应用于根据给定的资源文件地址返回对应的 Resource BeanDefinitionReader 主要定义资源文件读取并转换为 BeanDefinition 的各个功能 EnvironmentCapable 定义获取 Environment 方法 DocumentLoader 定义从资源文件加载到转换为 Document 的功能 AbstractBeanDefinitionReader 对 EnvironmentCapable、BeanDefinitionReader 类定义的功能进行实现 BeanDefinitionDocumentReader 定义读取 Document 并注册 BeanDefinition 功能 BeanDefinitionParserDelegate 定义解析 Element 的各种方法 BeanDefinition 承载 bean 定义的接口，有三种实现，RootBeanDefinition、ChildBeanDefinition 和 GenericBeanDefinition","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"MessagePack序列化","slug":"MessagePack序列化","date":"2019-07-14T01:42:47.000Z","updated":"2020-11-03T13:04:34.167Z","comments":false,"path":"2019/07/14/MessagePack序列化/","link":"","permalink":"https://zhechu.github.io/2019/07/14/MessagePack序列化/","excerpt":"","text":"环境说明 环境 说明 msgpack-0.6.12 类似于JSON的一种有效的二进制序列化格式 官方文档 https://msgpack.org/ 1 MessagePack 优劣势优势 同样跨平台 使用方式比 Google 的 Protocol buffers 要简单，Java 类加 @Message 注解即可，不需编写协议文件 默认使用 UTF-8 编码，不需考虑编码问题 劣势 压缩比还是没有 Google 的 Protocol buffers 高，但也差距不大 2 Java 对象序列化示例：将嵌套对象 User 序列化和反序列化 Maven pom.xml 文件引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.msgpack&lt;/groupId&gt; &lt;artifactId&gt;msgpack&lt;/artifactId&gt; &lt;version&gt;0.6.12&lt;/version&gt;&lt;/dependency&gt; 单元测试 123456789101112131415161718192021222324252627282930313233import com.wise.netty.messagepack.User;import com.wise.netty.messagepack.UserContact;import org.junit.Test;import org.msgpack.MessagePack;import java.io.IOException;/** * 序列化测试 */public class MessagePackTest &#123; @Test public void messagePackCodecTest() throws IOException &#123; User user = new User(); user.setAge(20); String userName = \"张三\"; user.setUserName(userName); user.setId(\"zhagnsan\"); user.setUserContact(new UserContact(userName + \"@xiangxue.com\",\"133\")); MessagePack messagePack = new MessagePack(); byte[] raw = messagePack.write(user); System.out.println(\"序列化后大小：\" + raw.length); // 43 User rawUser = messagePack.read(raw, User.class); System.out.println(\"解析后的数据：\" + rawUser); // User&#123;userName='张三', age=20, id='zhagnsan', userContact=UserContact&#123;mail='张三@xiangxue.com', phone='133'&#125;&#125; &#125;&#125; User 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.msgpack.annotation.Message;/** * 实体类 */@Message // MessagePack提供的注解，表明这是一个需要序列化的实体类public class User &#123; private String id; private String userName; private int age; private UserContact userContact; public User() &#123;&#125; public User(String userName, int age, String id) &#123; this.userName = userName; this.age = age; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public UserContact getUserContact() &#123; return userContact; &#125; public void setUserContact(UserContact userContact) &#123; this.userContact = userContact; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userName='\" + userName + '\\'' + \", age=\" + age + \", id='\" + id + '\\'' + \", userContact=\" + userContact + '&#125;'; &#125;&#125; UserContact 类 12345678910111213141516171819202122232425262728293031323334353637383940414243import org.msgpack.annotation.Message;/** * 实体类 */@Message // MessagePack提供的注解，表明这是一个需要序列化的实体类public class UserContact &#123; private String mail; private String phone; public UserContact() &#123;&#125; public UserContact(String mail, String phone) &#123; this.mail = mail; this.phone = phone; &#125; public String getMail() &#123; return mail; &#125; public void setMail(String mail) &#123; this.mail = mail; &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone; &#125; @Override public String toString() &#123; return \"UserContact&#123;\" + \"mail='\" + mail + '\\'' + \", phone='\" + phone + '\\'' + '&#125;'; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"https://zhechu.github.io/tags/序列化/"},{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"排序算法","slug":"排序算法","date":"2019-07-13T02:25:30.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2019/07/13/排序算法/","link":"","permalink":"https://zhechu.github.io/2019/07/13/排序算法/","excerpt":"","text":"示例代码 https://github.com/zhechu/algorithm-demo/tree/master/src/main/java/com/wise/algorithm/sort 算法 平均时间复杂度 额外空间复杂度 稳定性 备注 冒泡排序 O(n^2) O(1) 稳定 n 小时较好 选择排序 O(n^2) O(1) 不稳定 n 小时较好 插入排序 O(n^2) O(1) 稳定 大部分已排序时较好 快速排序 O(nlogn) O(1) 不稳定 n 大时较好，比堆排序性能好 归并排序 O(nlogn) O(n) 稳定 n 大时较好 堆排序 O(nlogn) O(1) 不稳定 n 大时较好 计数排序 O(n) O(n) 稳定 数据范围分布均匀且 n 较小时较好 基数排序 O(n) O(n) 稳定 综合排序可参考 JDK java.util.Arrays#sort 方法的实现 检查数组的大小 如果数组比较小，则直接调用改进后的快速排序完成排序 如果数组较大，则评估数组的无序程度 如果这个数组几乎是无序的，那么同样调用改进后的快速排序算法排序 如果数组基本有序，那么采用归并排序算法对数组进行排序","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"欧几里得算法","slug":"欧几里得算法","date":"2019-07-13T02:06:56.000Z","updated":"2020-11-03T13:04:34.288Z","comments":false,"path":"2019/07/13/欧几里得算法/","link":"","permalink":"https://zhechu.github.io/2019/07/13/欧几里得算法/","excerpt":"","text":"示例代码 https://github.com/zhechu/algorithm-demo/blob/master/src/main/java/com/wise/algorithm/Euclid.java 辗转相除法：求两个正整数最大公约数 123456789101112131415161718192021222324/** * 欧几里得算法（辗转相除法）：求两个正整数最大公约数 * @author lingyuwang * @date 2019-07-13 9:53 */public class Euclid &#123; public static void main(String[] args) &#123; long result = divisor(123, 321); System.out.println(result); // 3 &#125; public static long divisor(long m, long n) &#123; while (n != 0) &#123; m = m % n; m = m ^ n; n = n ^ m; m = n ^ m; &#125; return m; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Netty手记","slug":"Netty手记","date":"2019-07-09T12:48:37.000Z","updated":"2020-11-03T13:04:34.181Z","comments":false,"path":"2019/07/09/Netty手记/","link":"","permalink":"https://zhechu.github.io/2019/07/09/Netty手记/","excerpt":"","text":"环境说明 环境 说明 Netty-4.1.15.Final 异步事件驱动的网络应用程序框架 Netty 官网 http://netty.io/ Netty 内存泄露跟踪 https://netty.io/wiki/reference-counted-objects.html Netty 实现的 SocketIO 框架 https://github.com/socketio/socket.io https://github.com/mrniko/netty-socketio 安卓客户端 https://socket.io/blog/native-socket-io-and-android/ IOS 客户端 https://github.com/socketio/socket.io-client-swift 小案例代码 https://github.com/zhechu/netty-demo Netty 仿微信案例代码 https://github.com/zhechu/Springboot_muxin Netty RPC 框架案例代码 https://github.com/zhechu/netty-rpc-demo 1 Reactor 模式角色 Handle（句柄或描述符） Synchronous Event Demultiplexer（同步事件分离器） Event Handler（事件处理器） Concrete Event Handler（具体事件处理器） Initiation Dispacther（初始分发器） 2 Netty 架构设计原则 一个EventLoopGroup当中会包含一个或多个EventLoop。 一个EventLoop在它的整个生命周期当中都只会与唯一一个Thread进行绑定。 所有由EventLoop所处理的各种I/O事件都将在它所关联的那个Thread上进行处理。 一个Channel在它的整个生命周期中只会注册在一个EventLoop上。 一个EventLoop在运行过程中，会被分配给一个或多个Channel。 3 SelectionKey 操作类型 OP_READ OP_WRITE OP_CONNECT OP_ACCEPT 服务端 ServerSocketChannel N N N Y 服务端 SocketChannel Y Y N N 客户端 SocketChannel Y Y Y N TIPS：服务端 SocketChannel 指由服务端 ServerSocketChannel.accept() 返回的对象。 每个操作类型的就绪条件 操作类型 就绪条件 OP_READ 当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作 OP_WRITE 当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册 OP_CONNECT 当 SocketChannel.connect() 请求连接成功后就绪。该操作只给客户端使用 OP_ACCEPT 当接收到一个客户端连接请求时就绪。该操作只给服务器使用 4 解决粘包半包问题 加分割符，如：LineBasedFrameDecoder、DelimiterBasedFrameDecoder 消息定长，如：FixedLengthFrameDecoder 消息带上长度字段，如：LengthFieldBasedFrameDecoder","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://zhechu.github.io/tags/Netty/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Netty引用计数自旋锁的使用","slug":"Netty引用计数自旋锁的使用","date":"2019-06-27T13:56:49.000Z","updated":"2020-11-03T13:04:34.181Z","comments":false,"path":"2019/06/27/Netty引用计数自旋锁的使用/","link":"","permalink":"https://zhechu.github.io/2019/06/27/Netty引用计数自旋锁的使用/","excerpt":"","text":"环境说明 环境 说明 Netty-4.1.15.Final 异步事件驱动的网络应用程序框架 引用计数更新时使用自旋锁优化程序性能 volatile 的作用是多线程间共享数据，其修饰的属性里的值会在多线程间同步更新，保证线程安全 AtomicIntegerFieldUpdater 是原子类，自旋锁的实现。可以只更新对象里的某个属性 compareAndSet 方法只能保证被更新的属性统一使用其更新才实现线程安全，反之则反。如：refCnt 若使用 compareAndSet 方法更新，同时可以采用直接赋值的方式更新；compareAndSet 方法不会保证跟直接赋值的方式不冲突。详细解释请看 AtomicIntegerFieldUpdater 类的 JavaDoc：A reflection-based utility that enables atomic updates to designated volatile int fields of designated classes. This class is designed for use in atomic data structures in which several fields of the same node are independently subject to atomic updates. Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater. TIPS：类似 AtomicIntegerFieldUpdater 的类还有 AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater（用于更新引用类型属性）。 关键代码123456789101112131415161718192021222324public abstract class AbstractReferenceCounted implements ReferenceCounted &#123; private static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCounted&gt; refCntUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, \"refCnt\"); private volatile int refCnt = 1; private ReferenceCounted retain0(int increment) &#123; for (;;) &#123; int refCnt = this.refCnt; final int nextCnt = refCnt + increment; // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow. if (nextCnt &lt;= increment) &#123; throw new IllegalReferenceCountException(refCnt, increment); &#125; if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) &#123; break; &#125; &#125; return this; &#125;&#125; AbstractReferenceCounted 类完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * Copyright 2013 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */package io.netty.util;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;import static io.netty.util.internal.ObjectUtil.checkPositive;/** * Abstract base class for classes wants to implement &#123;@link ReferenceCounted&#125;. */public abstract class AbstractReferenceCounted implements ReferenceCounted &#123; private static final AtomicIntegerFieldUpdater&lt;AbstractReferenceCounted&gt; refCntUpdater = AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, \"refCnt\"); private volatile int refCnt = 1; @Override public final int refCnt() &#123; return refCnt; &#125; /** * An unsafe operation intended for use by a subclass that sets the reference count of the buffer directly */ protected final void setRefCnt(int refCnt) &#123; this.refCnt = refCnt; &#125; @Override public ReferenceCounted retain() &#123; return retain0(1); &#125; @Override public ReferenceCounted retain(int increment) &#123; return retain0(checkPositive(increment, \"increment\")); &#125; private ReferenceCounted retain0(int increment) &#123; for (;;) &#123; int refCnt = this.refCnt; final int nextCnt = refCnt + increment; // Ensure we not resurrect (which means the refCnt was 0) and also that we encountered an overflow. if (nextCnt &lt;= increment) &#123; throw new IllegalReferenceCountException(refCnt, increment); &#125; if (refCntUpdater.compareAndSet(this, refCnt, nextCnt)) &#123; break; &#125; &#125; return this; &#125; @Override public ReferenceCounted touch() &#123; return touch(null); &#125; @Override public boolean release() &#123; return release0(1); &#125; @Override public boolean release(int decrement) &#123; return release0(checkPositive(decrement, \"decrement\")); &#125; private boolean release0(int decrement) &#123; for (;;) &#123; int refCnt = this.refCnt; if (refCnt &lt; decrement) &#123; throw new IllegalReferenceCountException(refCnt, -decrement); &#125; if (refCntUpdater.compareAndSet(this, refCnt, refCnt - decrement)) &#123; if (refCnt == decrement) &#123; deallocate(); return true; &#125; return false; &#125; &#125; &#125; /** * Called once &#123;@link #refCnt()&#125; is equals 0. */ protected abstract void deallocate();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://zhechu.github.io/tags/锁/"},{"name":"Netty","slug":"Netty","permalink":"https://zhechu.github.io/tags/Netty/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"字符集编解码手册","slug":"字符集编解码手册","date":"2019-06-15T13:57:24.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2019/06/15/字符集编解码手册/","link":"","permalink":"https://zhechu.github.io/2019/06/15/字符集编解码手册/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"Google Protocol Buffers","slug":"Google-Protocol-Buffers","date":"2019-06-08T06:24:45.000Z","updated":"2020-11-03T13:04:34.083Z","comments":false,"path":"2019/06/08/Google-Protocol-Buffers/","link":"","permalink":"https://zhechu.github.io/2019/06/08/Google-Protocol-Buffers/","excerpt":"","text":"环境说明 环境 说明 protobuf-3.8.0 RPC 编解码工具 官方文档 https://developers.google.cn/protocol-buffers/ 1 Windows 安装 Protoc 编译器下载并解压到 F:\\protoc 目录 https://github.com/protocolbuffers/protobuf/releases/download/v3.8.0/protoc-3.8.0-win64.zip 检查 Protoc 是否安装成功1protoc --version 2 定义消息并生成 Java 类StudentProto.proto12345678910111213141516syntax = \"proto2\";package com.wise.proto;option java_package = \"com.wise.proto\";option java_outer_classname = \"StudentProto\";message Student &#123; required string name = 1; optional int32 age = 2; optional string address = 3;&#125; 编译生成 Java 类1protoc --java_out=src/main/java src/proto/Student.proto 生成的 Java 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896// Generated by the protocol buffer compiler. DO NOT EDIT!// source: src/proto/StudentProto.protopackage com.wise.proto;public final class StudentProto &#123; private StudentProto() &#123;&#125; public static void registerAllExtensions( com.google.protobuf.ExtensionRegistryLite registry) &#123; &#125; public static void registerAllExtensions( com.google.protobuf.ExtensionRegistry registry) &#123; registerAllExtensions( (com.google.protobuf.ExtensionRegistryLite) registry); &#125; public interface StudentOrBuilder extends // @@protoc_insertion_point(interface_extends:com.wise.proto.Student) com.google.protobuf.MessageOrBuilder &#123; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ boolean hasName(); /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ java.lang.String getName(); /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ com.google.protobuf.ByteString getNameBytes(); /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ boolean hasAge(); /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ int getAge(); /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ boolean hasAddress(); /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ java.lang.String getAddress(); /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ com.google.protobuf.ByteString getAddressBytes(); &#125; /** * Protobuf type &#123;@code com.wise.proto.Student&#125; */ public static final class Student extends com.google.protobuf.GeneratedMessageV3 implements // @@protoc_insertion_point(message_implements:com.wise.proto.Student) StudentOrBuilder &#123; private static final long serialVersionUID = 0L; // Use Student.newBuilder() to construct. private Student(com.google.protobuf.GeneratedMessageV3.Builder&lt;?&gt; builder) &#123; super(builder); &#125; private Student() &#123; name_ = \"\"; address_ = \"\"; &#125; @java.lang.Override @SuppressWarnings(&#123;\"unused\"&#125;) protected java.lang.Object newInstance( UnusedPrivateParameter unused) &#123; return new Student(); &#125; @java.lang.Override public final com.google.protobuf.UnknownFieldSet getUnknownFields() &#123; return this.unknownFields; &#125; private Student( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException &#123; this(); if (extensionRegistry == null) &#123; throw new java.lang.NullPointerException(); &#125; int mutable_bitField0_ = 0; com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(); try &#123; boolean done = false; while (!done) &#123; int tag = input.readTag(); switch (tag) &#123; case 0: done = true; break; case 10: &#123; com.google.protobuf.ByteString bs = input.readBytes(); bitField0_ |= 0x00000001; name_ = bs; break; &#125; case 16: &#123; bitField0_ |= 0x00000002; age_ = input.readInt32(); break; &#125; case 26: &#123; com.google.protobuf.ByteString bs = input.readBytes(); bitField0_ |= 0x00000004; address_ = bs; break; &#125; default: &#123; if (!parseUnknownField( input, unknownFields, extensionRegistry, tag)) &#123; done = true; &#125; break; &#125; &#125; &#125; &#125; catch (com.google.protobuf.InvalidProtocolBufferException e) &#123; throw e.setUnfinishedMessage(this); &#125; catch (java.io.IOException e) &#123; throw new com.google.protobuf.InvalidProtocolBufferException( e).setUnfinishedMessage(this); &#125; finally &#123; this.unknownFields = unknownFields.build(); makeExtensionsImmutable(); &#125; &#125; public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() &#123; return com.wise.proto.StudentProto.internal_static_com_wise_proto_Student_descriptor; &#125; @java.lang.Override protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() &#123; return com.wise.proto.StudentProto.internal_static_com_wise_proto_Student_fieldAccessorTable .ensureFieldAccessorsInitialized( com.wise.proto.StudentProto.Student.class, com.wise.proto.StudentProto.Student.Builder.class); &#125; private int bitField0_; public static final int NAME_FIELD_NUMBER = 1; private volatile java.lang.Object name_; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public boolean hasName() &#123; return ((bitField0_ &amp; 0x00000001) != 0); &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public java.lang.String getName() &#123; java.lang.Object ref = name_; if (ref instanceof java.lang.String) &#123; return (java.lang.String) ref; &#125; else &#123; com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref; java.lang.String s = bs.toStringUtf8(); if (bs.isValidUtf8()) &#123; name_ = s; &#125; return s; &#125; &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public com.google.protobuf.ByteString getNameBytes() &#123; java.lang.Object ref = name_; if (ref instanceof java.lang.String) &#123; com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref); name_ = b; return b; &#125; else &#123; return (com.google.protobuf.ByteString) ref; &#125; &#125; public static final int AGE_FIELD_NUMBER = 2; private int age_; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public boolean hasAge() &#123; return ((bitField0_ &amp; 0x00000002) != 0); &#125; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public int getAge() &#123; return age_; &#125; public static final int ADDRESS_FIELD_NUMBER = 3; private volatile java.lang.Object address_; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public boolean hasAddress() &#123; return ((bitField0_ &amp; 0x00000004) != 0); &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public java.lang.String getAddress() &#123; java.lang.Object ref = address_; if (ref instanceof java.lang.String) &#123; return (java.lang.String) ref; &#125; else &#123; com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref; java.lang.String s = bs.toStringUtf8(); if (bs.isValidUtf8()) &#123; address_ = s; &#125; return s; &#125; &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public com.google.protobuf.ByteString getAddressBytes() &#123; java.lang.Object ref = address_; if (ref instanceof java.lang.String) &#123; com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref); address_ = b; return b; &#125; else &#123; return (com.google.protobuf.ByteString) ref; &#125; &#125; private byte memoizedIsInitialized = -1; @java.lang.Override public final boolean isInitialized() &#123; byte isInitialized = memoizedIsInitialized; if (isInitialized == 1) return true; if (isInitialized == 0) return false; if (!hasName()) &#123; memoizedIsInitialized = 0; return false; &#125; memoizedIsInitialized = 1; return true; &#125; @java.lang.Override public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException &#123; if (((bitField0_ &amp; 0x00000001) != 0)) &#123; com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_); &#125; if (((bitField0_ &amp; 0x00000002) != 0)) &#123; output.writeInt32(2, age_); &#125; if (((bitField0_ &amp; 0x00000004) != 0)) &#123; com.google.protobuf.GeneratedMessageV3.writeString(output, 3, address_); &#125; unknownFields.writeTo(output); &#125; @java.lang.Override public int getSerializedSize() &#123; int size = memoizedSize; if (size != -1) return size; size = 0; if (((bitField0_ &amp; 0x00000001) != 0)) &#123; size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_); &#125; if (((bitField0_ &amp; 0x00000002) != 0)) &#123; size += com.google.protobuf.CodedOutputStream .computeInt32Size(2, age_); &#125; if (((bitField0_ &amp; 0x00000004) != 0)) &#123; size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, address_); &#125; size += unknownFields.getSerializedSize(); memoizedSize = size; return size; &#125; @java.lang.Override public boolean equals(final java.lang.Object obj) &#123; if (obj == this) &#123; return true; &#125; if (!(obj instanceof com.wise.proto.StudentProto.Student)) &#123; return super.equals(obj); &#125; com.wise.proto.StudentProto.Student other = (com.wise.proto.StudentProto.Student) obj; if (hasName() != other.hasName()) return false; if (hasName()) &#123; if (!getName() .equals(other.getName())) return false; &#125; if (hasAge() != other.hasAge()) return false; if (hasAge()) &#123; if (getAge() != other.getAge()) return false; &#125; if (hasAddress() != other.hasAddress()) return false; if (hasAddress()) &#123; if (!getAddress() .equals(other.getAddress())) return false; &#125; if (!unknownFields.equals(other.unknownFields)) return false; return true; &#125; @java.lang.Override public int hashCode() &#123; if (memoizedHashCode != 0) &#123; return memoizedHashCode; &#125; int hash = 41; hash = (19 * hash) + getDescriptor().hashCode(); if (hasName()) &#123; hash = (37 * hash) + NAME_FIELD_NUMBER; hash = (53 * hash) + getName().hashCode(); &#125; if (hasAge()) &#123; hash = (37 * hash) + AGE_FIELD_NUMBER; hash = (53 * hash) + getAge(); &#125; if (hasAddress()) &#123; hash = (37 * hash) + ADDRESS_FIELD_NUMBER; hash = (53 * hash) + getAddress().hashCode(); &#125; hash = (29 * hash) + unknownFields.hashCode(); memoizedHashCode = hash; return hash; &#125; public static com.wise.proto.StudentProto.Student parseFrom( java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data); &#125; public static com.wise.proto.StudentProto.Student parseFrom( java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data, extensionRegistry); &#125; public static com.wise.proto.StudentProto.Student parseFrom( com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data); &#125; public static com.wise.proto.StudentProto.Student parseFrom( com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data, extensionRegistry); &#125; public static com.wise.proto.StudentProto.Student parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data); &#125; public static com.wise.proto.StudentProto.Student parseFrom( byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException &#123; return PARSER.parseFrom(data, extensionRegistry); &#125; public static com.wise.proto.StudentProto.Student parseFrom(java.io.InputStream input) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input); &#125; public static com.wise.proto.StudentProto.Student parseFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry); &#125; public static com.wise.proto.StudentProto.Student parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input); &#125; public static com.wise.proto.StudentProto.Student parseDelimitedFrom( java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseDelimitedWithIOException(PARSER, input, extensionRegistry); &#125; public static com.wise.proto.StudentProto.Student parseFrom( com.google.protobuf.CodedInputStream input) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input); &#125; public static com.wise.proto.StudentProto.Student parseFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException &#123; return com.google.protobuf.GeneratedMessageV3 .parseWithIOException(PARSER, input, extensionRegistry); &#125; @java.lang.Override public Builder newBuilderForType() &#123; return newBuilder(); &#125; public static Builder newBuilder() &#123; return DEFAULT_INSTANCE.toBuilder(); &#125; public static Builder newBuilder(com.wise.proto.StudentProto.Student prototype) &#123; return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype); &#125; @java.lang.Override public Builder toBuilder() &#123; return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this); &#125; @java.lang.Override protected Builder newBuilderForType( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) &#123; Builder builder = new Builder(parent); return builder; &#125; /** * Protobuf type &#123;@code com.wise.proto.Student&#125; */ public static final class Builder extends com.google.protobuf.GeneratedMessageV3.Builder&lt;Builder&gt; implements // @@protoc_insertion_point(builder_implements:com.wise.proto.Student) com.wise.proto.StudentProto.StudentOrBuilder &#123; public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() &#123; return com.wise.proto.StudentProto.internal_static_com_wise_proto_Student_descriptor; &#125; @java.lang.Override protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() &#123; return com.wise.proto.StudentProto.internal_static_com_wise_proto_Student_fieldAccessorTable .ensureFieldAccessorsInitialized( com.wise.proto.StudentProto.Student.class, com.wise.proto.StudentProto.Student.Builder.class); &#125; // Construct using com.wise.proto.StudentProto.Student.newBuilder() private Builder() &#123; maybeForceBuilderInitialization(); &#125; private Builder( com.google.protobuf.GeneratedMessageV3.BuilderParent parent) &#123; super(parent); maybeForceBuilderInitialization(); &#125; private void maybeForceBuilderInitialization() &#123; if (com.google.protobuf.GeneratedMessageV3 .alwaysUseFieldBuilders) &#123; &#125; &#125; @java.lang.Override public Builder clear() &#123; super.clear(); name_ = \"\"; bitField0_ = (bitField0_ &amp; ~0x00000001); age_ = 0; bitField0_ = (bitField0_ &amp; ~0x00000002); address_ = \"\"; bitField0_ = (bitField0_ &amp; ~0x00000004); return this; &#125; @java.lang.Override public com.google.protobuf.Descriptors.Descriptor getDescriptorForType() &#123; return com.wise.proto.StudentProto.internal_static_com_wise_proto_Student_descriptor; &#125; @java.lang.Override public com.wise.proto.StudentProto.Student getDefaultInstanceForType() &#123; return com.wise.proto.StudentProto.Student.getDefaultInstance(); &#125; @java.lang.Override public com.wise.proto.StudentProto.Student build() &#123; com.wise.proto.StudentProto.Student result = buildPartial(); if (!result.isInitialized()) &#123; throw newUninitializedMessageException(result); &#125; return result; &#125; @java.lang.Override public com.wise.proto.StudentProto.Student buildPartial() &#123; com.wise.proto.StudentProto.Student result = new com.wise.proto.StudentProto.Student(this); int from_bitField0_ = bitField0_; int to_bitField0_ = 0; if (((from_bitField0_ &amp; 0x00000001) != 0)) &#123; to_bitField0_ |= 0x00000001; &#125; result.name_ = name_; if (((from_bitField0_ &amp; 0x00000002) != 0)) &#123; result.age_ = age_; to_bitField0_ |= 0x00000002; &#125; if (((from_bitField0_ &amp; 0x00000004) != 0)) &#123; to_bitField0_ |= 0x00000004; &#125; result.address_ = address_; result.bitField0_ = to_bitField0_; onBuilt(); return result; &#125; @java.lang.Override public Builder clone() &#123; return super.clone(); &#125; @java.lang.Override public Builder setField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) &#123; return super.setField(field, value); &#125; @java.lang.Override public Builder clearField( com.google.protobuf.Descriptors.FieldDescriptor field) &#123; return super.clearField(field); &#125; @java.lang.Override public Builder clearOneof( com.google.protobuf.Descriptors.OneofDescriptor oneof) &#123; return super.clearOneof(oneof); &#125; @java.lang.Override public Builder setRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value) &#123; return super.setRepeatedField(field, index, value); &#125; @java.lang.Override public Builder addRepeatedField( com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value) &#123; return super.addRepeatedField(field, value); &#125; @java.lang.Override public Builder mergeFrom(com.google.protobuf.Message other) &#123; if (other instanceof com.wise.proto.StudentProto.Student) &#123; return mergeFrom((com.wise.proto.StudentProto.Student)other); &#125; else &#123; super.mergeFrom(other); return this; &#125; &#125; public Builder mergeFrom(com.wise.proto.StudentProto.Student other) &#123; if (other == com.wise.proto.StudentProto.Student.getDefaultInstance()) return this; if (other.hasName()) &#123; bitField0_ |= 0x00000001; name_ = other.name_; onChanged(); &#125; if (other.hasAge()) &#123; setAge(other.getAge()); &#125; if (other.hasAddress()) &#123; bitField0_ |= 0x00000004; address_ = other.address_; onChanged(); &#125; this.mergeUnknownFields(other.unknownFields); onChanged(); return this; &#125; @java.lang.Override public final boolean isInitialized() &#123; if (!hasName()) &#123; return false; &#125; return true; &#125; @java.lang.Override public Builder mergeFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException &#123; com.wise.proto.StudentProto.Student parsedMessage = null; try &#123; parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry); &#125; catch (com.google.protobuf.InvalidProtocolBufferException e) &#123; parsedMessage = (com.wise.proto.StudentProto.Student) e.getUnfinishedMessage(); throw e.unwrapIOException(); &#125; finally &#123; if (parsedMessage != null) &#123; mergeFrom(parsedMessage); &#125; &#125; return this; &#125; private int bitField0_; private java.lang.Object name_ = \"\"; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public boolean hasName() &#123; return ((bitField0_ &amp; 0x00000001) != 0); &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public java.lang.String getName() &#123; java.lang.Object ref = name_; if (!(ref instanceof java.lang.String)) &#123; com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref; java.lang.String s = bs.toStringUtf8(); if (bs.isValidUtf8()) &#123; name_ = s; &#125; return s; &#125; else &#123; return (java.lang.String) ref; &#125; &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public com.google.protobuf.ByteString getNameBytes() &#123; java.lang.Object ref = name_; if (ref instanceof String) &#123; com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref); name_ = b; return b; &#125; else &#123; return (com.google.protobuf.ByteString) ref; &#125; &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public Builder setName( java.lang.String value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; bitField0_ |= 0x00000001; name_ = value; onChanged(); return this; &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public Builder clearName() &#123; bitField0_ = (bitField0_ &amp; ~0x00000001); name_ = getDefaultInstance().getName(); onChanged(); return this; &#125; /** * &lt;code&gt;required string name = 1;&lt;/code&gt; */ public Builder setNameBytes( com.google.protobuf.ByteString value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; bitField0_ |= 0x00000001; name_ = value; onChanged(); return this; &#125; private int age_ ; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public boolean hasAge() &#123; return ((bitField0_ &amp; 0x00000002) != 0); &#125; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public int getAge() &#123; return age_; &#125; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public Builder setAge(int value) &#123; bitField0_ |= 0x00000002; age_ = value; onChanged(); return this; &#125; /** * &lt;code&gt;optional int32 age = 2;&lt;/code&gt; */ public Builder clearAge() &#123; bitField0_ = (bitField0_ &amp; ~0x00000002); age_ = 0; onChanged(); return this; &#125; private java.lang.Object address_ = \"\"; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public boolean hasAddress() &#123; return ((bitField0_ &amp; 0x00000004) != 0); &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public java.lang.String getAddress() &#123; java.lang.Object ref = address_; if (!(ref instanceof java.lang.String)) &#123; com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref; java.lang.String s = bs.toStringUtf8(); if (bs.isValidUtf8()) &#123; address_ = s; &#125; return s; &#125; else &#123; return (java.lang.String) ref; &#125; &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public com.google.protobuf.ByteString getAddressBytes() &#123; java.lang.Object ref = address_; if (ref instanceof String) &#123; com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8( (java.lang.String) ref); address_ = b; return b; &#125; else &#123; return (com.google.protobuf.ByteString) ref; &#125; &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public Builder setAddress( java.lang.String value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; bitField0_ |= 0x00000004; address_ = value; onChanged(); return this; &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public Builder clearAddress() &#123; bitField0_ = (bitField0_ &amp; ~0x00000004); address_ = getDefaultInstance().getAddress(); onChanged(); return this; &#125; /** * &lt;code&gt;optional string address = 3;&lt;/code&gt; */ public Builder setAddressBytes( com.google.protobuf.ByteString value) &#123; if (value == null) &#123; throw new NullPointerException(); &#125; bitField0_ |= 0x00000004; address_ = value; onChanged(); return this; &#125; @java.lang.Override public final Builder setUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) &#123; return super.setUnknownFields(unknownFields); &#125; @java.lang.Override public final Builder mergeUnknownFields( final com.google.protobuf.UnknownFieldSet unknownFields) &#123; return super.mergeUnknownFields(unknownFields); &#125; // @@protoc_insertion_point(builder_scope:com.wise.proto.Student) &#125; // @@protoc_insertion_point(class_scope:com.wise.proto.Student) private static final com.wise.proto.StudentProto.Student DEFAULT_INSTANCE; static &#123; DEFAULT_INSTANCE = new com.wise.proto.StudentProto.Student(); &#125; public static com.wise.proto.StudentProto.Student getDefaultInstance() &#123; return DEFAULT_INSTANCE; &#125; @java.lang.Deprecated public static final com.google.protobuf.Parser&lt;Student&gt; PARSER = new com.google.protobuf.AbstractParser&lt;Student&gt;() &#123; @java.lang.Override public Student parsePartialFrom( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException &#123; return new Student(input, extensionRegistry); &#125; &#125;; public static com.google.protobuf.Parser&lt;Student&gt; parser() &#123; return PARSER; &#125; @java.lang.Override public com.google.protobuf.Parser&lt;Student&gt; getParserForType() &#123; return PARSER; &#125; @java.lang.Override public com.wise.proto.StudentProto.Student getDefaultInstanceForType() &#123; return DEFAULT_INSTANCE; &#125; &#125; private static final com.google.protobuf.Descriptors.Descriptor internal_static_com_wise_proto_Student_descriptor; private static final com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internal_static_com_wise_proto_Student_fieldAccessorTable; public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor() &#123; return descriptor; &#125; private static com.google.protobuf.Descriptors.FileDescriptor descriptor; static &#123; java.lang.String[] descriptorData = &#123; \"\\n\\034src/proto/StudentProto.proto\\022\\016com.wise\" + \".proto\\\"5\\n\\007Student\\022\\014\\n\\004name\\030\\001 \\002(\\t\\022\\013\\n\\003age\\030\\002\" + \" \\001(\\005\\022\\017\\n\\007address\\030\\003 \\001(\\tB\\036\\n\\016com.wise.protoB\" + \"\\014StudentProto\" &#125;; descriptor = com.google.protobuf.Descriptors.FileDescriptor .internalBuildGeneratedFileFrom(descriptorData, new com.google.protobuf.Descriptors.FileDescriptor[] &#123; &#125;); internal_static_com_wise_proto_Student_descriptor = getDescriptor().getMessageTypes().get(0); internal_static_com_wise_proto_Student_fieldAccessorTable = new com.google.protobuf.GeneratedMessageV3.FieldAccessorTable( internal_static_com_wise_proto_Student_descriptor, new java.lang.String[] &#123; \"Name\", \"Age\", \"Address\", &#125;); &#125; // @@protoc_insertion_point(outer_class_scope)&#125; 3 protostuffprotostuff 是基于 protobuf 的 Java 序列化库，protostuff 官方文档 https://protostuff.github.io/docs/","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"Gradle 使用手册","slug":"Gradle-使用手册","date":"2019-06-07T03:39:31.000Z","updated":"2020-11-03T13:04:34.084Z","comments":false,"path":"2019/06/07/Gradle-使用手册/","link":"","permalink":"https://zhechu.github.io/2019/06/07/Gradle-使用手册/","excerpt":"","text":"环境说明 环境 说明 Gradle-5.4.1 类似 Maven 的构建工具 官方文档 https://docs.gradle.org/current/userguide/userguide.html 1 Windows 安装 Gradle下载 gradle-5.4.1-all.zip https://gradle.org/next-steps/?version=5.4.1&amp;format=all 解压 gradle-5.4.1-all.zip 并配置环境变量123GRADLE_HOME=D:\\mywork\\java\\gradle-5.4.1GRADLE_USER_HOME=D:\\mywork\\.gradlePath=%GRADLE_HOME%\\bin; TIPS：GRADLE_USER_HOME 环境变量配置的是 Gradle 的本地仓库目录地址（类似于 Maven 的本地仓库）。由于 Windows 不支持界面直接创建以 . 符号开头的名称的文件夹，因此 D:\\mywork.gradle 目录需要使用命令行 mkdir D:\\mywork\\.gradle 创建。 检查 Gradle 是否安装成功1gradle -v D:\\mywork.gradle 本地仓库目录下创建 init.gradle 文件，以使用国内镜像站，加快依赖包下载速度，内容如下1234567891011allprojects &#123; repositories &#123; mavenLocal() maven &#123; url 'http://maven.aliyun.com/nexus/content/repositories/central/' &#125; mavenCentral() jcenter() maven &#123; url \"https://repo.spring.io/snapshot\" &#125; maven &#123; url \"https://repo.spring.io/milestone\" &#125; maven &#123; url 'http://oss.jfrog.org/artifactory/oss-snapshot-local/' &#125; &#125;&#125; TIPS：init.gradle 文件类似于 Maven 的 settings.xml 全局配置文件 D:\\mywork.gradle 本地仓库目录下创建 gradle.properties 文件，自定义全局属性，提高编译效率，内容如下1234# 配置编译时的虚拟机参数org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8# 开启并行编译org.gradle.parallel=true 2 常用命令构建打包1gradle clean build 构建打包并跳过测试1gradle clean build -x test","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"https://zhechu.github.io/tags/Gradle/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"分布式事务解决方案","slug":"分布式事务解决方案","date":"2019-06-01T14:24:03.000Z","updated":"2020-11-03T13:04:34.279Z","comments":false,"path":"2019/06/01/分布式事务解决方案/","link":"","permalink":"https://zhechu.github.io/2019/06/01/分布式事务解决方案/","excerpt":"","text":"1 柔性事务1.1 柔性事务类型 两阶段型 补偿型 异步确保型 最大努力通知型 1.2 柔性事务中的服务模式1.2.1 可查询操作1.2.2 幂等操作定义：重复调用多次产生的业务结果与调用一次产生的结果相同。 实现方式 通过业务操作本身实现幂等性 系统缓存所有请求与处理结果，检测到重复请求之后，自动返回之前的处理结果 1.2.3 TCC 操作Try：尝试执行业务 完成所有业务检查（一致性） 预留必须业务资源（准隔离性） Confirm：确认执行业务 真正执行业务 不做任何业务检查 只使用 Try 阶段预留的业务资源 Confirm 操作要满足幂等性 Cancel：取消执行业务 释放 Try 阶段预留的业务资源 Cancel 操作要满足幂等性 与 2PC 协议比较 位于业务服务层而非资源层 没有单独的准备（Prepare）阶段，Try 操作兼备资源操作与准备能力 Try 操作可以灵活选择业务资源的锁定粒度 较高开发成本 TIPS：TCC 操作也属于两阶段型操作。 1.2.4 可补偿操作do：真正执行业务 完成业务处理 业务执行结果外部可见 compensate：业务补偿 抵消（或部分抵消）正向业务操作的业务结果 补偿操作满足幂等性 约束 补偿在业务上可行 由于业务执行结果未隔离、或者补偿不完整带来的风险与成本可控 TIPS：TCC 操作中的 Confirm 操作和 Cancel 操作也可以看作是补偿操作。 1.3 可靠消息最终一致1.3.1 实现业务处理服务在业务事务提交前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不真正发送。业务处理服务在业务事务提交后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送。 1.3.2 消息业务处理服务在业务事务回滚后，向实时消息服务取消发送。消息状态确认系统定期找到未确认发送或回滚发送的消息，向业务处理服务询问消息状态，业务处理服务根据消息 ID 或消息内容确定该消息是否有效。 1.3.3 约束被动方的处理结果不影响主动方的处理结果，被动方的消息处理操作是幂等操作。 1.3.4 成本 可靠消息系统建设成本 一次消息发送需要两次请求，业务处理服务需实现消息状态回查接口 1.3.5 优点 消息数据独立存储、独立伸缩，降低业务系统与消息系统间的耦合 对最终一致性时间敏感度较高，降低业务被动方实现成本 1.3.6 方案1.3.6.1 本地消息服务1.3.6.2 独立消息服务1.4 TCC1.4.1 实现 一个完整的业务活动由一个主业务服务与若干从业务服务组成 主业务服务负责发起并完成整个业务活动 从业务服务提供 TCC 型业务操作 业务活动管理器控制业务活动的一致性，登记业务活动中的操作，并在业务活动提交时确认所有的 TCC 型操作的 Confirm 操作，在业务活动取消时调用所有 TCC 型操作的 Cancel 操作 1.4.2 成本 实现 TCC 操作的成本 业务活动结束时 Confirm 或 Cancel 操作的执行成本 业务活动日志成本 1.4.3 适用范围 强隔离性、严格一致性要求的业务活动 适用于执行时间较短的业务 1.5 最大努力通知1.5.1 实现 业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失 业务活动的被动方根据定时策略，向业务活动主动方查询，恢复丢失的业务消息 1.5.2 约束被动方的处理结果不影响主动方的处理结果。 1.5.3 成本业务查询与校对系统的建设成本。 1.5.4 适用范围 对业务最终一致性的时间敏感度低 跨企业的业务活动","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"分布式事务","slug":"分布式事务","permalink":"https://zhechu.github.io/tags/分布式事务/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Mysql函数","slug":"Mysql函数","date":"2019-06-01T06:41:42.000Z","updated":"2023-11-09T22:14:50.442Z","comments":false,"path":"2019/06/01/Mysql函数/","link":"","permalink":"https://zhechu.github.io/2019/06/01/Mysql函数/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 官方文档 https://dev.mysql.com/doc/refman/5.7/en/functions.html 存储 IP 地址可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。 MySQL 提供了两个方法来处理 ip 地址 INET_ATON()：把 ip 转为无符号整型 (4-8 位) INET_NTOA()：把整型的 ip 转为地址 插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。123insert into ip_record(id, ip) VALUES(1, INET_ATON(&apos;127.0.0.1&apos;));select id, INET_NTOA(ip) from ip_record;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql行列互转","slug":"Mysql行列互转","date":"2019-05-27T15:57:04.000Z","updated":"2020-11-03T13:04:34.179Z","comments":false,"path":"2019/05/27/Mysql行列互转/","link":"","permalink":"https://zhechu.github.io/2019/05/27/Mysql行列互转/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 1 行转列1.1 CORSS JOIN1.2 CASE WHEN1.3 序列化表的方式2 列转行2.1 序列化表的方式2.2 UNION3 应用3.1 同一属性多值过滤3.1.1 GROUP BY","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql查询优化","slug":"Mysql查询优化","date":"2019-05-26T13:33:33.000Z","updated":"2023-11-09T23:06:35.734Z","comments":false,"path":"2019/05/26/Mysql查询优化/","link":"","permalink":"https://zhechu.github.io/2019/05/26/Mysql查询优化/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 1 使用 JOIN 优化子查询2 使用 JOIN 优化 NOT IN 和 &lt;&gt; 查询条件3 使用 in 代替 orin 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。 4 使用 JOIN 优化聚合子查询4.1 测试数据准备创建表和导入数据123456789101112131415161718192021222324252627282930313233343536373839404142434445-- 学生表drop table if exists student;CREATE TABLE `student` ( `id` int unsigned NOT NULL AUTO_INCREMENT, `name` varchar(45) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8;insert into student(id, name) values(1, &apos;张三&apos;);insert into student(id, name) values(2, &apos;李四&apos;);commit;-- 课程表drop table if exists course;CREATE TABLE `course` ( `id` int unsigned NOT NULL AUTO_INCREMENT, `name` varchar(45) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8;insert into course(id, name) values(1, &apos;语文&apos;);insert into course(id, name) values(2, &apos;数学&apos;);insert into course(id, name) values(3, &apos;英语&apos;);commit;-- 成绩表drop table if exists score;CREATE TABLE `score` ( `id` int unsigned NOT NULL AUTO_INCREMENT, `course_id` int NOT NULL, `stu_id` int NOT NULL, `score` int NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=201 DEFAULT CHARSET=utf8;alter table score add index idx_course_id (course_id);alter table score add index idx_stu_id (stu_id);insert into score(id, course_id, stu_id, score) values(1, 1, 1, 30);insert into score(id, course_id, stu_id, score) values(2, 1, 2, 40);insert into score(id, course_id, stu_id, score) values(3, 2, 1, 90);insert into score(id, course_id, stu_id, score) values(4, 2, 2, 70);insert into score(id, course_id, stu_id, score) values(5, 3, 1, 60);insert into score(id, course_id, stu_id, score) values(6, 3, 2, 50);commit; 学生表数据 id name 1 张三 2 李四 成绩表数据 id course_id stu_id score 1 1 1 30 2 1 2 40 3 2 1 90 4 2 2 70 5 3 1 60 6 3 2 50 课程表数据 id name 1 语文 2 数学 3 英语 目标：查询出每个学生最高分数的课程 stu_name course_name score 张三 数学 90 李四 数学 70 4.2 方案一：子查询过滤（差）使用子查询过滤1234567891011121314151617SELECT a.`name` AS stu_name, c.`name` AS course_name, b.scoreFROM student aLEFT JOIN score b ON b.stu_id = a.idLEFT JOIN course c ON c.id = b.course_idWHERE b.score = ( SELECT max(d.score) FROM score d WHERE d.stu_id = b.stu_id ); 执行计划 执行计划可视化 使用 profile 查看每个阶段耗时情况 TIPS：由于 d 表每次比较都需要重新计算，会比较耗时。 4.3 方案二：JOIN 查询（推荐）先按学生分组，求出最高分数，再将分好组的临时表与其它基表进行连接12345678910111213141516171819SELECT a.`name` AS stu_name, c.`name` AS course_name, b.scoreFROM student aLEFT JOIN score b ON b.stu_id = a.idLEFT JOIN course c ON c.id = b.course_idLEFT JOIN ( SELECT stu_id, max(score) max_score FROM score GROUP BY stu_id) d ON d.stu_id = b.stu_idWHERE b.score = d.max_score; 执行计划 执行计划可视化 使用 profile 查看每个阶段耗时情况 TIPS：虽然执行计划显示成本比较高，但方案一的子查询循环查询并未计算全部成本（只是显示计算一次的成本）。因此方案二还是略优于方案一（可以从 profile 返回的阶段情况判断）。 优化：提前过滤，降低笛卡尔积1234567891011121314151617181920SELECT a.`name` AS stu_name, c.`name` AS course_name, b.scoreFROM student aLEFT JOIN ( SELECT stu_id, MAX(score) max_score FROM score GROUP BY stu_id) d ON d.stu_id = a.idLEFT JOIN score b ON ( b.stu_id = a.id AND b.score = d.max_score)LEFT JOIN course c ON c.id = b.course_id; 4.4 方案三：JOIN + HAVING（有副作用）成绩表自连接，使用 HAVING 子句过滤123456789101112131415SELECT a.`name` AS stu_name, d.`name` AS course_name, b.scoreFROM student aLEFT JOIN score b ON b.stu_id = a.idLEFT JOIN score c ON c.stu_id = a.idLEFT JOIN course d ON d.id = b.course_idGROUP BY a.id, b.course_id, b.scoreHAVING b.score = max(c.score); 执行计划 执行计划可视化 使用 profile 查看每个阶段耗时情况 TIPS：JOIN 之后再 GROUP BY，并且 GROUP BY 过程用到文件排序，固然比方案二略差。但在数据量大情况下，比方案一更优。 4.5 方案四：子查询排名（扩展性强）先按学生分组，求出课程成绩在其所有课程成绩中的第 N 名，然后找出课程成绩为第 1 名的课程即可1234567891011121314151617181920212223242526SELECT s.`name` AS stu_name, b.`name` AS course_name, c.scoreFROM student sLEFT JOIN ( SELECT a.stu_id, a.course_id, a.score, ( SELECT count(id) FROM score t WHERE t.stu_id = a.stu_id AND t.score &gt;= a.score ) AS cnt FROM score a) c ON c.stu_id = s.idLEFT JOIN course b ON b.id = c.course_idWHERE c.cnt &lt;= 1; 执行计划 执行计划可视化 使用 profile 查看每个阶段耗时情况 TIPS：类似方案一，但扩展性比方案一更优。其可以查询出每个学生第 N 高分的课程。 5 索引优化分页查询5.1 方案一建立主键或唯一索引, 利用索引。可以取前一页的最大行数的 id，然后根据这个最大的 id 来限制下一页的起点1SELECT * FROM 表名称 WHERE id_pk &gt; (pageNum*10) LIMIT M; 5.2 方案二获取每一批的最小ID和最大ID1234567891011121314SELECT MIN(a.id) min_id, MAX(a.id) max_idFROM ( SELECT id FROM 表名称 WHERE id &gt; #&#123;minId&#125; ORDER BY id ASC LIMIT #&#123;batchSize&#125;) a TIPS：主表的 type 为 range 级别，且只扫描索引，比较高效 按区间查询1SELECT * FROM 表名称 where id BETWEEN #&#123;minId&#125; AND #&#123;maxId&#125; TIPS：主表的 type 为 range 级别，比较高效 Java 操作程序12345678910111213141516171819202122232425262728// 分批查询Long lastMinId = 0L;while (true) &#123; BatchSectionVO batchSectionVO = xxxDao.selectBatchSection(lastMinId, 1000); if (batchSectionVO == null) &#123; break; &#125; Long minId = batchSectionVO.getMinId(); Long maxId = batchSectionVO.getMaxId(); // 区间为空则表示已查询完毕 if (minId == null || maxId == null) &#123; break; &#125; List&lt;XXX&gt; xxxList = xxxDao.selectBySection(minId, maxId); if (CollectionUtils.isEmpty(xxxList)) &#123; break; &#125; // TODO 具体业务逻辑 // 检查是否为最后一批请求，若是则结束（减少处理最后一批后又去数据库取数据判断是否结束的开销） if (xxxList.size() &lt; 1000) &#123; break; &#125; lastMinId = maxId;&#125; TIPS：实际效果，比正常的分页语句 limit pageNo, pageSize 高效一个数量级！ 6 索引优化 count(*) 和 max(create_date)count 优化思路：count(*) 改为 count(id)，id 列上加上唯一索引。 max 优化思路：max(field) 的列上，综合考虑是否可以加上普通索引甚至唯一索引。 7 总结执行计划只能作参考，SQL 实际耗时需综合考虑。另外可使用 profile 进一步查看 SQL 执行效果。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql定位查询耗时阶段","slug":"Mysql定位查询耗时阶段","date":"2019-05-26T10:33:35.000Z","updated":"2020-11-03T13:04:34.171Z","comments":false,"path":"2019/05/26/Mysql定位查询耗时阶段/","link":"","permalink":"https://zhechu.github.io/2019/05/26/Mysql定位查询耗时阶段/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 使用 profile ，可以查看当前会话过程中执行的语句资源使用信息。 官方文档 https://dev.mysql.com/doc/refman/5.7/en/show-profile.html 当前会话启用 profile1set profiling = 1; 执行 select count(*) 查询1select count(*) from film; 执行 select * 查询1select * from film; 查看每一个查询消耗的总时间信息1show profiles; 查看具体查询每个阶段消耗时间信息1show profile cpu for query 2; TIPS：可以看到，最耗时的阶段是发送数据阶段。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql索引的使用","slug":"Mysql索引的使用","date":"2019-05-25T14:13:57.000Z","updated":"2020-11-03T13:04:34.177Z","comments":false,"path":"2019/05/25/Mysql索引的使用/","link":"","permalink":"https://zhechu.github.io/2019/05/25/Mysql索引的使用/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 官方文档 https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html 1 索引类型1.1 B 树索引mysql 默认选择的索引类型。 使用场景 全值匹配的查询，如：id = ‘xxx’ 的查询 匹配最左前缀的查询，如：联合索引的最左前缀匹配规则 匹配列前缀索引的查询，如：name like ‘xxx%’ 的查询 匹配范围值的查询，如：age &gt;= 20 and age =&lt; 30 的查询 精确匹配左前列并范围匹配另外一列 只访问索引的查询 使用限制 若不是按照索引最左列开始查找，则无法使用索引 使用索引时不能跳过索引中的列 not in 和 &lt;&gt; 操作无法使用索引 若查询中有某个列的范围查询，则其右边所有列都无法使用索引 1.2 Hash 索引使用场景 Hash 索引是基于 Hash 表实现的，只有查询条件精确匹配 Hash 索引中的所有列时，才会使用到 Hash 索引。 使用限制 必须进行二次查找 无法用于排序 Hash 码的计算可能存在 Hash 冲突 2 索引优化策略 索引列上不能使用表达式或函数 mysql 对索引的长度有限制。对于比较长的字符串字段值，建议使用列前缀索引 区分度越高的列，越适合建立索引。当然前提是有查询的需求 正确选择联合索引的索引列的顺序 尽量使用覆盖索引 2.1 使用索引优化排序排序有两种情况 使用索引进行排序 index 使用文件进行排序 filesort 优化限制 索引的列顺序和 ORDER BY 子句的顺序完全一致 索引中所有列的方向（升序和降序）和 ORDER BY 子句完全一致 ORDER BY 中的字段全部在关联表中的第一张表 2.1.1 测试数据准备测试表123456789101112131415161718DROP TABLE IF EXISTS `rental`;CREATE TABLE `rental` ( `rental_id` int(11) NOT NULL AUTO_INCREMENT, `rental_date` datetime NOT NULL, `inventory_id` mediumint(8) unsigned NOT NULL, `customer_id` smallint(5) unsigned NOT NULL, `return_date` datetime DEFAULT NULL, `staff_id` tinyint(3) unsigned NOT NULL, `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`rental_id`), UNIQUE KEY `rental_date` (`rental_date`,`inventory_id`,`customer_id`), KEY `idx_fk_inventory_id` (`inventory_id`), KEY `idx_fk_customer_id` (`customer_id`), KEY `idx_fk_staff_id` (`staff_id`), CONSTRAINT `fk_rental_customer` FOREIGN KEY (`customer_id`) REFERENCES `customer` (`customer_id`) ON UPDATE CASCADE, CONSTRAINT `fk_rental_inventory` FOREIGN KEY (`inventory_id`) REFERENCES `inventory` (`inventory_id`) ON UPDATE CASCADE, CONSTRAINT `fk_rental_staff` FOREIGN KEY (`staff_id`) REFERENCES `staff` (`staff_id`) ON UPDATE CASCADE) ENGINE=InnoDB AUTO_INCREMENT=16050 DEFAULT CHARSET=utf8; 示例数据12345678910INSERT INTO `rental` VALUES (&apos;1&apos;, &apos;2005-05-24 22:53:30&apos;, &apos;367&apos;, &apos;130&apos;, &apos;2005-05-26 22:04:30&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;2&apos;, &apos;2005-05-24 22:54:33&apos;, &apos;1525&apos;, &apos;459&apos;, &apos;2005-05-28 19:40:33&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;3&apos;, &apos;2005-05-24 23:03:39&apos;, &apos;1711&apos;, &apos;408&apos;, &apos;2005-06-01 22:12:39&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;4&apos;, &apos;2005-05-24 23:04:41&apos;, &apos;2452&apos;, &apos;333&apos;, &apos;2005-06-03 01:43:41&apos;, &apos;2&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;5&apos;, &apos;2005-05-24 23:05:21&apos;, &apos;2079&apos;, &apos;222&apos;, &apos;2005-06-02 04:33:21&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;6&apos;, &apos;2005-05-24 23:08:07&apos;, &apos;2792&apos;, &apos;549&apos;, &apos;2005-05-27 01:32:07&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;7&apos;, &apos;2005-05-24 23:11:53&apos;, &apos;3995&apos;, &apos;269&apos;, &apos;2005-05-29 20:34:53&apos;, &apos;2&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;8&apos;, &apos;2005-05-24 23:31:46&apos;, &apos;2346&apos;, &apos;239&apos;, &apos;2005-05-27 23:33:46&apos;, &apos;2&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;9&apos;, &apos;2005-05-25 00:00:40&apos;, &apos;2580&apos;, &apos;126&apos;, &apos;2005-05-28 00:22:40&apos;, &apos;1&apos;, &apos;2006-02-15 21:30:53&apos;);INSERT INTO `rental` VALUES (&apos;10&apos;, &apos;2005-05-25 00:02:21&apos;, &apos;1824&apos;, &apos;399&apos;, &apos;2005-05-31 22:44:21&apos;, &apos;2&apos;, &apos;2006-02-15 21:30:53&apos;); 2.1.2 优化示例2.1.2.1 优化反例使用普通字段进行排序，将会使用文件排序1select * from rental where rental_date &gt; &apos;2005-01-01&apos; order by last_update; 执行计划 执行计划可视化 2.1.2.2 主键排序使用主键进行排序，将会使用索引排序，不需文件排序1select * from rental where rental_date &gt; &apos;2005-01-01&apos; order by rental_id; 执行计划 执行计划可视化 2.1.2.3 联合索引排序使用 rental_date,inventory_id,customer_id 组合的联合索引进行排序，将会使用索引排序，不需文件排序1234567select * from rental where rental_date = &apos;2005-01-01&apos; order by inventory_id,customer_id;-- 等价于select * from rental where rental_date = &apos;2005-01-01&apos; order by inventory_id;-- 等价于select * from rental where rental_date = &apos;2005-01-01&apos; order by rental_date;-- 等价于select * from rental where rental_date = &apos;2005-01-01&apos; order by rental_date,inventory_id,customer_id; 执行计划 执行计划可视化 2.2 查看索引使用情况查看索引使用次数12345678910111213SELECT OBJECT_SCHEMA, OBJECT_NAME, INDEX_NAME, COUNT_STARFROM PERFORMANCE_SCHEMA .table_io_waits_summary_by_index_usageWHERE INDEX_NAME IS NOT NULLAND OBJECT_SCHEMA &lt;&gt; &apos;mysql&apos;ORDER BY OBJECT_SCHEMA, OBJECT_NAME; 查看表中索引的基数1show index from t; 2.3 删除多余索引测试表12345678910CREATE TABLE `t` ( `a` int(11) NOT NULL, `b` int(11) NOT NULL, `c` int(11) NOT NULL, `d` int(11) NOT NULL, PRIMARY KEY (`a`,`b`), KEY `c` (`c`), KEY `ca` (`c`,`a`), KEY `cb` (`c`,`b`)) ENGINE=InnoDB; 示例数据1234567INSERT INTO t (a, b, c, d)VALUES (1, 2, 3, 0), (1, 4, 3, 0), (2, 1, 3, 0), (2, 2, 2, 0), (2, 3, 4, 0); 需求：a、b 在业务上必须做联合主键，针对如下查询语句，是否可优化12select * from t where c=N order by a limit 1;select * from t where c=N order by b limit 1; 分析 主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序 索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键（主键部分只记录 b） 索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键（主键部分只记录 a） 结论：ca 可以去掉，cb 需保留 以如下语句查看执行计划验证12select * from t where c=3 order by a limit 1;select * from t where c=3 order by b limit 1; 2.4 重建索引重建索引可以整理碎片，释放磁盘空间，提高索引使用效率 重建表1ALTER TABLE T ENGINE = INNODB; 2.5 强制使用索引测试表12345678CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `b` (`b`)) ENGINE=InnoDB; 示例数据123456789101112delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=2000)do insert into t values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata(); 查看执行计划1explain select * from t where a between 100 and 200; 强制使用索引查看执行计划1explain select * from t force index(a) where a between 100 and 200; 2.6 使用索引优化被驱动表测试表12345678910111213141516CREATE TABLE `trade_log` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `t_modified` (`t_modified`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, `step_info` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 示例数据123456789101112131415insert into trade_log values(1, &apos;aaaaaaaa&apos;, 1000, now());insert into trade_log values(2, &apos;aaaaaaab&apos;, 1000, now());insert into trade_log values(3, &apos;aaaaaaac&apos;, 1000, now());insert into trade_detail values(1, &apos;aaaaaaaa&apos;, 1, &apos;add&apos;);insert into trade_detail values(2, &apos;aaaaaaaa&apos;, 2, &apos;update&apos;);insert into trade_detail values(3, &apos;aaaaaaaa&apos;, 3, &apos;commit&apos;);insert into trade_detail values(4, &apos;aaaaaaab&apos;, 1, &apos;add&apos;);insert into trade_detail values(5, &apos;aaaaaaab&apos;, 2, &apos;update&apos;);insert into trade_detail values(6, &apos;aaaaaaab&apos;, 3, &apos;update again&apos;);insert into trade_detail values(7, &apos;aaaaaaab&apos;, 4, &apos;commit&apos;);insert into trade_detail values(8, &apos;aaaaaaac&apos;, 1, &apos;add&apos;);insert into trade_detail values(9, &apos;aaaaaaac&apos;, 2, &apos;update&apos;);insert into trade_detail values(10, &apos;aaaaaaac&apos;, 3, &apos;update again&apos;);insert into trade_detail values(11, &apos;aaaaaaac&apos;, 4, &apos;commit&apos;); 关联查询1explain select d.* from trade_log l, trade_detail d where d.tradeid = l.tradeid and l.id = 2; trade_detail 表（被驱动表）加上索引后关联查询12alter table trade_detail add index(tradeid);explain select d.* from trade_log l, trade_detail d where d.tradeid = l.tradeid and l.id = 2; TIPS：trade_log 表数据较少，被选为驱动表，其读入内存后，再通过 tradeid 查找 trade_detail 表（被驱动表）匹配的数据，因此 trade_log 的 tradeid 不需加上索引 2.7 优化字符集隐式转换测试表1234567891011121314151617CREATE TABLE `trade_log` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `operator` int(11) DEFAULT NULL, `t_modified` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `t_modified` (`t_modified`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `trade_detail` ( `id` int(11) NOT NULL, `tradeid` varchar(32) DEFAULT NULL, `trade_step` int(11) DEFAULT NULL, `step_info` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`), KEY `tradeid` (`tradeid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 示例数据123456789101112131415insert into trade_log values(1, &apos;aaaaaaaa&apos;, 1000, now());insert into trade_log values(2, &apos;aaaaaaab&apos;, 1000, now());insert into trade_log values(3, &apos;aaaaaaac&apos;, 1000, now());insert into trade_detail values(1, &apos;aaaaaaaa&apos;, 1, &apos;add&apos;);insert into trade_detail values(2, &apos;aaaaaaaa&apos;, 2, &apos;update&apos;);insert into trade_detail values(3, &apos;aaaaaaaa&apos;, 3, &apos;commit&apos;);insert into trade_detail values(4, &apos;aaaaaaab&apos;, 1, &apos;add&apos;);insert into trade_detail values(5, &apos;aaaaaaab&apos;, 2, &apos;update&apos;);insert into trade_detail values(6, &apos;aaaaaaab&apos;, 3, &apos;update again&apos;);insert into trade_detail values(7, &apos;aaaaaaab&apos;, 4, &apos;commit&apos;);insert into trade_detail values(8, &apos;aaaaaaac&apos;, 1, &apos;add&apos;);insert into trade_detail values(9, &apos;aaaaaaac&apos;, 2, &apos;update&apos;);insert into trade_detail values(10, &apos;aaaaaaac&apos;, 3, &apos;update again&apos;);insert into trade_detail values(11, &apos;aaaaaaac&apos;, 4, &apos;commit&apos;); 关联查询12345explain select d.* from trade_log l, trade_detail d where d.tradeid = l.tradeid and l.id = 2;-- 等价于explain select d.* from trade_log l, trade_detail d where CONVERT(d.tradeid USING utf8mb4) = l.tradeid and l.id = 2; 关联查询显式转换1explain select d.* from trade_log l, trade_detail d where d.tradeid = CONVERT(l.tradeid USING utf8) and l.id = 2; TIPS：避免索引字段被隐式函数操作是关键","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql正确选择数据类型","slug":"Mysql正确选择数据类型","date":"2019-05-24T14:15:28.000Z","updated":"2020-11-03T13:04:34.175Z","comments":false,"path":"2019/05/24/Mysql正确选择数据类型/","link":"","permalink":"https://zhechu.github.io/2019/05/24/Mysql正确选择数据类型/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 官方文档 https://dev.mysql.com/doc/refman/5.7/en/data-types.html 当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符类型。对于相同级别的数据类型，应该优先占用空间小的数据类型。 1 整数类型 数据类型 存储空间 有符号取值范围 无符号取值范围 tinyint 1字节 -128~127 0~255 smallint 2字节 -32768~32767 0~65535 mediumint 3字节 -8388608~8388607 0~16777215 int 4字节 -2147483648~2147483647 0~4294967295 bigint 8字节 -9223372036854775808~9223372036854775807 0~18446744073709551615 TIPS：int(m) 在 integer 数据类型中，m 表示最大显示宽度。在 int(m) 中，m 的值跟 int(m) 所占多少存储空间并无任何关系。如：int(3)、int(4)、int(8) 在磁盘上都是占用 4 个字节的存储空间。 表创建有符号和无符号数据类型字段示例12345CREATE TABLE `book` ( `age` int DEFAULT NULL, -- 有符号，取值范围：-2147483648~2147483647 `bookid` int unsigned DEFAULT NULL, -- 无符号，取值范围：0~4294967295 `title` char(20) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2 实数类型 数据类型 存储空间 是否精确类型 float 4字节 否 double 8字节 否 decimal 每4个字节存9个数字，小数点占一个字节 是 TIPS：存储金额等数据，建议使用 decimal 数据类型。 3 字符串类型 数据类型 存储空间 备注 char(m) m 为0~255之间的整数 适合存储长度较固定的数据，如：性别标识字段 varchar(m) m 为0~65536之间的整数 适合存储变长数据，如：姓名字段 blob 存储示例 小图片二进制格式数据 text 存储示例 新闻纯文本格式数据 enum 存储示例 分类枚举值 4 日期和时间类型 数据类型 范围 备注 date ‘1000-01-01’~’9999-12-31’ datetime ‘1000-01-01 00:00:00.000000’~’9999-12-31 23:59:59.999999’ timestamp ‘1970-01-01 00:00:01.000000’~’2038-01-19 03:14:07.999999’ 依赖 mysql 数据库的时区，时区不同，显示的值则不同 使用 default 和 on update 自动初始化和更新到当前时间示例1234567891011121314-- 创建表create table t_datetime(id int, create_time datetime default now(), update_time datetime default now() on update now());-- 插入数据insert into t_datetime(id) values(1);commit;-- 更新数据update t_datetime set id = 2 where id = 1;commit;-- 检查结果select * from t_datetime; TIPS：适用于表记录的创建时间字段的初始化和更新最后操作时间字段的自动更新。但需要注意，now() 函数依赖于 mysql 数据库的时区。 修改 mysql 数据库时区，永久生效查看当前的时区设置1show variables like &quot;%time_zone%&quot;; 在 my.ini 添加如下配置（Windows）123[mysqld]# 时区，东8区default-time_zone = &apos;+8:00&apos; TIPS：重启 mysql 数据后才会生效。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql千万级数据快速去重","slug":"Mysql千万级数据快速去重","date":"2019-05-19T11:37:56.000Z","updated":"2020-11-03T13:04:34.170Z","comments":false,"path":"2019/05/19/Mysql千万级数据快速去重/","link":"","permalink":"https://zhechu.github.io/2019/05/19/Mysql千万级数据快速去重/","excerpt":"","text":"问题：card 表的 card_number 字段忘记加唯一约束，造成大量数据重复，需要去重。 1 测试数据准备创建表123456CREATE TABLE `card` ( `card_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;ID&apos;, `card_number` varchar(100) DEFAULT NULL COMMENT &apos;卡号&apos;, `other_field` varchar(100) DEFAULT NULL COMMENT &apos;其它字段&apos;, PRIMARY KEY (`card_id`)) ENGINE=InnoDB AUTO_INCREMENT=142665 DEFAULT CHARSET=utf8; 新建存储过程，准备 10 万条数据123456789101112131415DROP PROCEDURE IF EXISTS proc1;DELIMITER $$SET AUTOCOMMIT = 0$$CREATE PROCEDURE proc1()BEGINDECLARE v_cnt DECIMAL (10) DEFAULT 0 ;dd:LOOP INSERT INTO card (card_number, other_field) VALUES (UUID(), UUID()); COMMIT; SET v_cnt = v_cnt+1 ; IF v_cnt = 100000 THEN LEAVE dd; END IF; END LOOP dd ;END;$$DELIMITER ; 调用存储过程1call proc1; 执行完存储过程后检查数据条数1select count(card_id) from card; 构建 1 万条卡号重复的数据（大概10%重复）1234insert into card(card_number) select card_number from card limit 5000;commit;insert into card(card_number) select card_number from card limit 5000;commit; 2 检测重复数据查询重复的卡号及其重复条数1select card_number, count(card_number) as count from card group by card_number having count(card_number) &gt; 1; 3 数据去重3.1 方案一：离线执行离线执行：在执行去重数据期间，其它程序不对 card 表做增删改操作。 思路：将所有数据导入一张结构与其一样的空的临时表，但临时表需先建立重复字段的唯一索引，然后导入数据时，忽略错误，达到去重的效果。最后修改表名即可。 新建临时表 card_temp123456CREATE TABLE `card_temp` ( `card_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;ID&apos;, `card_number` varchar(100) DEFAULT NULL COMMENT &apos;卡号&apos;, `other_field` varchar(100) DEFAULT NULL COMMENT &apos;其它字段&apos;, PRIMARY KEY (`card_id`)) ENGINE=InnoDB AUTO_INCREMENT=142665 DEFAULT CHARSET=utf8; 在临时表中为卡号添加唯一索引1alter table card_temp add unique index(card_number); 将 card 表的数据导入 card_temp 表，但重复的则忽略12insert ignore into card_temp(card_id, card_number, other_field) select card_id, card_number, other_field from card order by null;commit; TIPS：实际测试，50万条数据，40秒左右。若数据量达百万级以上，建议分批执行。 检查临时表数据条数1select count(card_id) from card_temp; 修改表名称12alter table card rename to card_old;alter table card_temp rename to card; 确认无误后删除旧数据表1drop table card_old; 3.2 方案二：在线执行在线执行：在执行去重数据期间，其它程序可以对 card 表做增删改操作。 3.2.1 通过中间表思路：将需保留的重复的数据导入一张结构与其一样的空的临时表，但临时表需先建立重复字段的唯一索引，确保数据无误，然后通过比对原始表，删除多余的重复数据。最后修改原始表的索引即可。 新建临时表 card_temp123456CREATE TABLE `card_temp` ( `card_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;ID&apos;, `card_number` varchar(100) DEFAULT NULL COMMENT &apos;卡号&apos;, `other_field` varchar(100) DEFAULT NULL COMMENT &apos;其它字段&apos;, PRIMARY KEY (`card_id`)) ENGINE=InnoDB AUTO_INCREMENT=142665 DEFAULT CHARSET=utf8; 在临时表中为卡号添加唯一索引1alter table card_temp add unique index(card_number); 在 card 表中为 card_number 建立普通索引，为后面优化去重效率1alter table card add index (card_number); 检查语句的消耗1234explain insert into card_tempselect b.card_id, a.card_number, a.other_fieldfrom card a inner join (select max(card_id) card_id from card group by card_number having count(card_id)&gt;1 order by null) bon a.card_id = b.card_id; 将 card 表需保留的重复数据导入 card_temp 表12345insert into card_tempselect b.card_id, a.card_number, a.other_fieldfrom card a inner join (select max(card_id) card_id from card group by card_number having count(card_id)&gt;1 order by null) bon a.card_id = b.card_id;commit; 检查删除语句的消耗1explain delete a.* from card a, card_temp b where b.card_number = a.card_number and a.card_id &lt; b.card_id; 删除 card 表重复的数据12delete a.* from card a, card_temp b where b.card_number = a.card_number and a.card_id &lt; b.card_id;commit; TIPS：实际测试，50万条数据，20秒左右。若数据量达百万级以上，建议分批执行。 在 card 表中为 card_number 删除普通索引，并建立唯一索引，防止数据再次重复12alter table card drop index card_number;alter table card add unique index(card_number); 确认无误后删除临时表1drop table card_temp; 3.2.2 直接删除即时统计并删除123456789101112131415161718DELETE aFROM card aJOIN ( SELECT card_number, count(card_number) AS count, max(card_id) AS card_id FROM card GROUP BY card_number HAVING count(card_number) &gt; 1) b ON a.card_number = b.card_numberWHERE a.card_id &lt; b.card_id;commit;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql定位慢查询","slug":"Mysql定位慢查询","date":"2019-05-19T05:06:04.000Z","updated":"2020-11-03T13:04:34.170Z","comments":false,"path":"2019/05/19/Mysql定位慢查询/","link":"","permalink":"https://zhechu.github.io/2019/05/19/Mysql定位慢查询/","excerpt":"","text":"环境说明 环境 说明 Mysql-5.7 关系型数据库 1 查看服务器状态信息官方文档 https://dev.mysql.com/doc/refman/5.7/en/show-status.html SHOW STATUS 语法 12SHOW [GLOBAL | SESSION] STATUS [LIKE &apos;pattern&apos; | WHERE expr] 1.1 查看服务器启动时间1SHOW GLOBAL STATUS LIKE &apos;uptime&apos;; TIPS：单位为秒。 1.2 查看 CRUD 语句的执行次数查看插入语句的执行次数1SHOW GLOBAL STATUS LIKE &apos;com_insert&apos;; 查看删除语句的执行次数1SHOW GLOBAL STATUS LIKE &apos;com_delete&apos;; 查看修改语句的执行次数1SHOW GLOBAL STATUS LIKE &apos;com_update&apos;; 查看查询语句的执行次数1SHOW GLOBAL STATUS LIKE &apos;com_select&apos;; TIPS：显示的是服务器启动后的执行次数。若服务器重启，之前的执行次数会清零。 2 查看慢查询2.1 查看慢查询判定时间查看查询语句花费多少时间才被判定为慢查询1SHOW VARIABLES LIKE &apos;long_query_time&apos;; TIP：单位为秒。默认值为10。 修改慢查询判定时间1SET GLOBAL long_query_time = 0.2; TIPS：需要重新打开会话才能查到最新的值。但服务器重启后，会重置。要永久生效，需在 mysql 配置文件 my.ini 配置。 2.2 查看慢查询语句的执行次数1SHOW GLOBAL STATUS LIKE &apos;slow_queries&apos;; 可以结合慢查询日志来定位慢查询语句 https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html 2.3 开启慢查询日志查询是否开启慢查询日志。默认是不开启慢查询日志。1SHOW VARIABLES LIKE &apos;slow_query_log&apos;; TIPS：ON表示开启，OFF表示关闭。 先关闭 mysql 服务（Windows）1net stop mysql 修改 my.ini 配置文件，加上如下配置，永久开启慢查询日志12345678910[mysqld]# 开启慢查询日志slow_query_log=ON# 设置慢查询日志文件slow_query_log_file=F:/mysql-5.7.10-winx64/data/slow.log# 设置慢查询判定时间为1秒long_query_time=1 启动 mysql 服务（Windows）1net start mysql 检查配置是否生效12SHOW VARIABLES LIKE &apos;%slow_query%&apos;;SHOW VARIABLES LIKE &apos;long_query_time&apos;; 2.4 mysqldumpslow 汇总慢查询日志文件官方文档 https://dev.mysql.com/doc/refman/5.7/en/mysqldumpslow.html 查看帮助1perl mysqldumpslow.pl --help 参数说明1234567891011121314151617181920212223--verbose verbose--debug debug--help write this text to standard output-v verbose-d debug-s ORDER what to sort by (al, at, ar, c, l, r, t), 'at' is default al: average lock time ar: average rows sent at: average query time c: count l: lock time r: rows sent t: query time-r reverse the sort order (largest last instead of first)-t NUM just show the top n queries-a don't abstract all numbers to N and strings to 'S'-n NUM abstract numbers with at least n digits within names-g PATTERN grep: only consider stmts that include this string-h HOSTNAME hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all-i NAME name of server instance (if using mysql.server startup script)-l don't subtract lock time from total time 获取返回记录最多的2条 SQL1perl mysqldumpslow.pl -s r -t 2 &gt; d:/slow.txt 获取平均访问次数最多的2条 SQL1perl mysqldumpslow.pl -s ar -t 2 &gt; d:/slow.txt 获取平均访问次数最多，并且里面含有 dept 字符的2条 SQL1perl mysqldumpslow.pl -s ar -t 2 -g \"dept\" &gt; d:/slow.txt 指定慢查询日志文件1perl mysqldumpslow.pl -s ar -t 2 -g \"dept\" F:/mysql-5.7.10-winx64/data/slow.log &gt; d:/slow.txt 2.5 pt-query-digest 分析慢查询日志官方文档 https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html pt-query-digest 比 mysqldumpslow 功能更强大，但更加复杂。 下载 pt-query-digest.pl perl 脚本文件1curl -o pt-query-digest.pl https://www.percona.com/get/pt-query-digest 查看帮助1perl pt-query-digest.pl --help 获取最慢的 SQL1perl pt-query-digest.pl F:/mysql-5.7.10-winx64/data/slow.log &gt; d:/slow.txt TIPS：Rows examine 表示扫描的行数，Rows sent 表示发送的行数。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"数据库设计三范式","slug":"数据库设计三范式","date":"2019-05-19T03:38:32.000Z","updated":"2020-11-03T13:04:34.287Z","comments":false,"path":"2019/05/19/数据库设计三范式/","link":"","permalink":"https://zhechu.github.io/2019/05/19/数据库设计三范式/","excerpt":"","text":"1 数据库设计三范式1.1 1NF确保每个字段的原子性。 1.2 2NF非键字段必须依赖于键字段。 1.3 3NF消除传递依赖。 2 反范式数据库的性能比数据库范式更重要。必要时需要冗余字段，以空间换时间。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://zhechu.github.io/tags/规范/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"IntelliJ IDEA 使用手册","slug":"IntelliJ-IDEA-使用手册","date":"2019-05-18T03:09:04.000Z","updated":"2020-11-03T13:04:34.104Z","comments":false,"path":"2019/05/18/IntelliJ-IDEA-使用手册/","link":"","permalink":"https://zhechu.github.io/2019/05/18/IntelliJ-IDEA-使用手册/","excerpt":"","text":"环境说明 环境 说明 IntelliJ IDEA 2019.2.3 Java 智能开发工具 安装文件及配置 https://pan.baidu.com/s/1IHesoUd-JOr7BajxYNxxyw 提取码：t9cq 1 快捷键Eclipse 风格快捷键没有的则列出默认快捷键。 1.1 搜索 功能点 Eclipse 风格快捷键 备注 搜索文本 Ctrl + F 文件内范围搜索 继续搜索 Ctrl + K 表示：向前搜索 ， Ctrl + Shift + K 表示：向后搜索 搜索文本的辅助快捷键 搜索方法 Ctrl + O 搜索文件内的方法 搜索类 Ctrl + Shift + T 搜索项目范围的类文件。若勾上 Include none-project items 则表示搜索范围将包括依赖包 搜索所有引用处 Ctrl + Alt + H 鼠标需放方法名上 全局搜索文本 Ctrl + H 查看类的继承关系 UML 图 Ctrl + Alt + Shift + U 1.2 编辑 功能点 Eclipse 风格快捷键 备注 自动代码补全 Alt + / 可能已被设置为其它用途，需修改 自动代码生成 Alt + I 默认是 Alt + Insert，不方便操作 快速修复错误 Ctrl + 1 可能已被设置为其它用途，需修改 删除当前行 Ctrl + D 注释/取消注释 Ctrl + / 注释选中的代码 Ctrl + Shift + / 补全当前行 Ctrl + Shift + Enter 常用的场景时补全当前行后的；号，并将光标定位到下一行 查看最近复制的内容 Ctrl + Shift + V 粘贴历史 查看最近编辑的文件 Ctrl + E 对比最近的修改 Alt + Shift + C 格式化代码 Ctrl + Shift + F 整理 import Ctrl + Shift + O 1.3 跳转 功能点 Eclipse 风格快捷键 备注 显示方法层次 Ctrl + Shift + H 鼠标需放方法名上。常用于查找方法的声明处 跳到方法定义处 Ctrl + 鼠标 跳到方法实现处 Ctrl + Alt + B 上/下一查看处 Alt + 左箭头 ， Alt + 右箭头 跳到指定行 Ctrl + L 1.4 重构 功能点 Eclipse 风格快捷键 备注 改名 Alt + Shift + R 添加包围语句 Alt + Shift + Z 如：添加 try catch 1.5 运行 功能点 Eclipse 风格快捷键 备注 启动调试 Alt + Shift + F9 启动运行 Alt + Shift + F10 单步进入 F5 单步跳过 F6 执行选中语句 Alt + F8 1.6 窗口 功能点 Eclipse 风格快捷键 备注 打开配置窗口 Ctrl + Alt + S 打开项目配置窗口 Ctrl + Alt + Shift + S 关闭打开的窗口 Ctrl + F4 或 ESC 窗口缩放 Ctrl + M 默认是 Ctrl + Shift + F12，不方便操作 隐藏窗口 Shift + ESC 关闭当前文件 Ctrl + F4 水平分屏 Ctrl + Shift + 减号 垂直分屏 Ctrl + Shift + \\ 切换窗口 Ctrl + Tab 2 注意事项2.1 Maven 项目 Java 文件夹 Mark Directory as Sources Root2.2 编译问题: 源发行版 1.8 需要目标发行版 1.82.3 Maven 项目模块间相互调用设置2.4 UTF-8 编码设置idea64.exe.vmoptions1-Dfile.encoding=UTF-8 2.5 项目取消 Git 关联3.6 IDEA 的 VM 参数设置16G 内存机器上 IntelliJ IDEA 2019.2.3 x64 的 VM 参数设置（idea64.exe.vmoptions）123-Xms1024m-Xmx4096m-XX:ReservedCodeCacheSize=512m 3.7 清除缓存和索引3.8 Editor Tabs 多行显示3.9 禁用重启时打开最近使用的项目3.10 智能生成 serialVersionUID3.11 编辑注释模板，留下开发者的脚印4 插件4.1 JRebel 热部署插件使用教程 https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/jrebel-setup.md 4.2 MybatisX 快速开发插件使用教程 https://mp.baomidou.com/guide/mybatisx-idea-plugin.html#%E5%8A%9F%E8%83%BD 4.3 阿里 p3c 编程规范插件官方文档 https://github.com/alibaba/p3c/blob/master/idea-plugin/README_cn.md 4.4 mybatis-log-plugin 还原 SQL 插件官方文档 https://github.com/kookob/mybatis-log-plugin 4.5 lombok4.6 Translation 翻译插件 快捷键 作用 ctrl + shift + y 选中后翻译。由于其与字母大小写切换快捷键冲突，建议设置为：ctrl + shift + alt + y ctrl + shift + s 切换翻译源","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://zhechu.github.io/tags/IDEA/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"SpringSecurityOAuth2实现App身份认证","slug":"SpringSecurityOAuth2实现App身份认证","date":"2019-05-14T15:19:43.000Z","updated":"2020-11-03T13:04:34.213Z","comments":false,"path":"2019/05/14/SpringSecurityOAuth2实现App身份认证/","link":"","permalink":"https://zhechu.github.io/2019/05/14/SpringSecurityOAuth2实现App身份认证/","excerpt":"","text":"Spring Boot 集成 Spring Security OAuth2 实现 App 的身份认证。 环境说明 环境 说明 SpringBoot-1.5.6 应用框架 SpringCloud-Dalston.SR2 框架集合 示例代码 https://github.com/zhechu/spring-boot-security-oauth-demo/tree/basic","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://zhechu.github.io/tags/OAuth2/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://zhechu.github.io/tags/SpringSecurity/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringSecurity实现基本身份认证","slug":"SpringSecurity实现基本身份认证","date":"2019-05-08T14:47:33.000Z","updated":"2020-11-03T13:04:34.214Z","comments":false,"path":"2019/05/08/SpringSecurity实现基本身份认证/","link":"","permalink":"https://zhechu.github.io/2019/05/08/SpringSecurity实现基本身份认证/","excerpt":"","text":"Spring Boot 集成 Spring Security 实现基本的身份认证。 环境说明 环境 说明 SpringBoot-1.5.6 应用框架 示例代码 https://github.com/zhechu/spring-boot-security-demo/tree/basic 1 总览相关类的作用 类 作用 UserDetailsService 处理用户信息获取逻辑 UserDetails 处理用户校验逻辑 PasswordEncoder 处理密码加密解密 AuthenticationSuccessHandler 登录成功的处理器 AuthenticationFailureHandler 登录失败的处理器 SecurityContextPersistenceFilter 处理当前用户信息 过滤器链 2 依赖配置Maven pom.xml 的相关配置123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- commons --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 开发注解小工具 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3 安全配置Spring Security 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import com.wise.async.listener.queue.demo.handler.CustomAuthenticationFailureHandler;import com.wise.async.listener.queue.demo.handler.CustomAuthenticationSuccessHandler;/** * 安全配置类 * @author lingyuwang * */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler; @Autowired private CustomAuthenticationFailureHandler customAuthenticationFailureHandler; /** * 密码处理器 * @return */ @Bean public PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 开启表单认证 .loginPage(\"/authentication/require\") // 未登录的处理 .loginProcessingUrl(\"/authentication/form\") // 登录处理 url .successHandler(customAuthenticationSuccessHandler) // 登录成功的处理器 .failureHandler(customAuthenticationFailureHandler) // 登录失败的处理器// http.httpBasic() // 开启 http basic 认证 .and() .authorizeRequests() // 表示要进行请求授权 .antMatchers(\"/authentication/require\", \"/signIn.html\").permitAll() // 表示登录页不需通过权限验证 .anyRequest() // 所有请求 .authenticated() // 需要认证后才能访问 .and() .csrf().disable() // 禁用 CSRF 检查 ; &#125;&#125; 4 自定义用户详情服务用于用户身份认证并返回用户信息123456789101112131415161718192021222324252627282930313233343536373839404142434445import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.authority.AuthorityUtils;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;/** * 自定义用户详情服务 * @author lingyuwang * */@Component@Slf4jpublic class CustomUserDetailsService implements UserDetailsService &#123; @Autowired private PasswordEncoder passwordEncoder; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; log.info(\"登录用户名：&#123;&#125;\", username); // 模拟获取数据库存储的密码 String password = passwordEncoder.encode(\"123456\"); log.info(\"数据库存储的密码是：&#123;&#125;\", password); return new User( username, password, true, // 账号是否没有被删除（可以表示账号不存在） true, // 账号是否没有过期 true, // 凭证是否没有过期 true, // 账号是否没有被锁定 AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\") // 以逗号分割的权限值 ); &#125;&#125; 5 登录成功的处理器登录成功后调用，可以用于登录成功后的一些逻辑处理及返回成功信息给客户端（App或浏览器）123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.stereotype.Component;import com.fasterxml.jackson.databind.ObjectMapper;import com.wise.async.listener.queue.demo.vo.ResultVo;import lombok.extern.slf4j.Slf4j;/** * 登录成功的处理器 * @author lingyuwang * */@Component@Slf4jpublic class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Autowired private ObjectMapper objectMapper; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; log.info(\"登录成功\"); response.setStatus(HttpStatus.OK.value()); response.setContentType(\"application/json;charset=UTF-8\"); response.getWriter().write(objectMapper.writeValueAsString(ResultVo.buildSuccessResult(authentication))); &#125;&#125; 6 登录失败的处理器登录失败后调用，可以用于登录失败后的一些逻辑处理及返回失败信息给客户端（App或浏览器）1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.stereotype.Component;import com.fasterxml.jackson.databind.ObjectMapper;import com.wise.async.listener.queue.demo.vo.ResultVo;import lombok.extern.slf4j.Slf4j;/** * 登录失败的处理器 * @author lingyuwang * */@Component@Slf4jpublic class CustomAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; @Autowired private ObjectMapper objectMapper; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; log.info(\"登录失败\"); response.setStatus(HttpStatus.UNAUTHORIZED.value()); response.setContentType(\"application/json;charset=UTF-8\"); response.getWriter().write(objectMapper.writeValueAsString(ResultVo.buildExceptionResult(exception.getMessage()))); &#125;&#125; 7 安全控制器当未登录时访问需权限的资源时的处理器（替换默认的跳转地址 /login），引导其跳转到自定义登录页或返回 JSON 格式提示信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.io.IOException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang.StringUtils;import org.springframework.http.HttpStatus;import org.springframework.security.web.DefaultRedirectStrategy;import org.springframework.security.web.RedirectStrategy;import org.springframework.security.web.savedrequest.HttpSessionRequestCache;import org.springframework.security.web.savedrequest.RequestCache;import org.springframework.security.web.savedrequest.SavedRequest;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.bind.annotation.RestController;import com.wise.async.listener.queue.demo.vo.ResultVo;import lombok.extern.slf4j.Slf4j;/** * 安全控制器 * @author lingyuwang * */@RestController@Slf4jpublic class SecurityController &#123; private RequestCache requestCache = new HttpSessionRequestCache(); private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy(); /** * 当需要身份认证时，跳转到这里 * * @param request * @param response * @return * @throws IOException */ @RequestMapping(value = \"/authentication/require\", method = RequestMethod.GET) @ResponseStatus(code = HttpStatus.UNAUTHORIZED) public ResultVo&lt;Object&gt; requireAuthentication(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; SavedRequest savedRequest = requestCache.getRequest(request, response); if (savedRequest != null) &#123; String targetUrl = savedRequest.getRedirectUrl(); log.info(\"引发跳转的请求是：&#123;&#125;\", targetUrl); if (StringUtils.endsWithIgnoreCase(targetUrl, \".html\")) &#123; redirectStrategy.sendRedirect(request, response, \"/signIn.html\"); &#125; &#125; return new ResultVo&lt;Object&gt;(HttpStatus.UNAUTHORIZED.value(), \"访问的服务需要身份认证，请引导用户到登录页\"); &#125;&#125; 8 自定义登录页1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;标准登录页面&lt;/h2&gt; &lt;h3&gt;表单登录&lt;/h3&gt; &lt;form action=\"/authentication/form\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码:&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 9 获取当前用户信息1234567891011121314151617181920212223import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import lombok.extern.slf4j.Slf4j;/** * 用户控制器 * @author lingyuwang * */@RestController@Slf4jpublic class UserController &#123; @RequestMapping(\"/user\") public Object user() &#123; log.info(\"获取用户信息：&#123;&#125;\", SecurityContextHolder.getContext().getAuthentication().getPrincipal()); return SecurityContextHolder.getContext().getAuthentication().getPrincipal(); &#125;&#125; 10 测试浏览器直接访问以下地址进行测试 访问页面将跳转到登录页 http://127.0.0.1:8087/order.html 登录完后访问订单信息将正常放回 http://127.0.0.1:8087/order 获取当前登录用户的信息 http://127.0.0.1:8087/user","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://zhechu.github.io/tags/SpringSecurity/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringBoot自定义验证器及异常处理","slug":"SpringBoot自定义验证器及异常处理","date":"2019-05-06T13:35:02.000Z","updated":"2020-11-03T13:04:34.207Z","comments":false,"path":"2019/05/06/SpringBoot自定义验证器及异常处理/","link":"","permalink":"https://zhechu.github.io/2019/05/06/SpringBoot自定义验证器及异常处理/","excerpt":"","text":"当默认的验证器无法满足需求时，可以自定义验证器。 示例代码 https://github.com/zhechu/spring-boot-validator-demo 1 控制器123456789101112131415161718192021222324252627282930import javax.validation.Valid;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import com.wise.validator.demo.entity.Order;import lombok.extern.slf4j.Slf4j;/** * 订单控制器 * @author lingyuwang * */@RestController@RequestMapping(\"/order\")@Slf4jpublic class OrderController &#123; @PostMapping public Order create(@Valid @RequestBody Order order) &#123; log.debug(\"新建订单信息：&#123;&#125;\", order); return order; &#125;&#125; 2 全局异常处理12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.HashMap;import java.util.Map;import org.springframework.http.HttpStatus;import org.springframework.web.bind.MethodArgumentNotValidException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.ResponseStatus;/** * 全局异常处理 * @author lingyuwang * */@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseBody @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public Map&lt;String, Object&gt; handleUserNotExistException(MethodArgumentNotValidException ex) &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); StringBuilder errmsg = new StringBuilder(); ex.getBindingResult().getAllErrors().forEach(x -&gt; &#123; errmsg.append(x.getDefaultMessage()).append(\",\"); &#125;); String errmsgStr = null; if (errmsg.lastIndexOf(\",\") &gt; 1) &#123; errmsgStr = errmsg.substring(0, errmsg.length() - 1); &#125; else &#123; errmsgStr = errmsg.toString(); &#125; result.put(\"errmsg\", errmsgStr); return result; &#125;&#125; 3 数据实体12345678910111213141516171819202122232425262728293031323334353637import java.io.Serializable;import java.math.BigDecimal;import java.util.Date;import javax.validation.constraints.Past;import org.hibernate.validator.constraints.NotBlank;import com.wise.validator.demo.web.validator.CustomConstraint;import lombok.Data;/** * 订单实体 * @author lingyuwang * */@Datapublic class Order implements Serializable &#123; /** * 序列号 */ private static final long serialVersionUID = 7326468588263698503L; private String id; @NotBlank(message = \"订单流水号不能为空\") private String orderSerialNumber; @Past(message = \"交易时间必须是过去的时间\") private Date tradeTime; @CustomConstraint(message = \"自定义验证器验证失败提示信息\") private BigDecimal tradeAmount;&#125; 4 自定义验证器1234567891011121314151617181920212223242526272829303132333435363738394041import java.math.BigDecimal;import javax.validation.ConstraintValidator;import javax.validation.ConstraintValidatorContext;import org.springframework.beans.factory.annotation.Autowired;import com.wise.validator.demo.repository.OrderRepository;import lombok.extern.slf4j.Slf4j;/** * 自定义验证器 * @author lingyuwang * */@Slf4j// 不需加 @Component 注解，Spring 会自动处理实现 ConstraintValidator 接口的类public class CustomValidator implements ConstraintValidator&lt;CustomConstraint, BigDecimal&gt; &#123; @Autowired OrderRepository orderRepository; @Override public void initialize(CustomConstraint constraintAnnotation) &#123; log.info(\"custom validator init\"); &#125; @Override public boolean isValid(BigDecimal value, ConstraintValidatorContext context) &#123; log.info(\"value:&#123;&#125;\", value); if (value != null &amp;&amp; value.compareTo(orderRepository.getTotalTradeAmount()) &gt;= 0) &#123; return true; &#125; return false; &#125;&#125; 5 自定义验证器注解123456789101112131415161718192021222324252627import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.Constraint;import javax.validation.Payload;/** * 自定义验证器注解 * @author lingyuwang * */@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = CustomValidator.class)public @interface CustomConstraint &#123; String message(); Class&lt;?&gt;[] groups() default &#123; &#125;; Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;; String field() default \"\";&#125; 6 测试","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"异步监听队列提高系统吞吐率","slug":"异步监听队列提高系统吞吐率","date":"2019-05-06T11:51:02.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2019/05/06/异步监听队列提高系统吞吐率/","link":"","permalink":"https://zhechu.github.io/2019/05/06/异步监听队列提高系统吞吐率/","excerpt":"","text":"异步监听队列（也可以监听分布式队列，如：MQ）提高系统吞吐率。 示例代码 https://github.com/zhechu/spring-boot-async-listener-queue-demo 1 订单控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.Callable;import org.apache.commons.lang.RandomStringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.context.request.async.DeferredResult;import com.wise.async.listener.queue.demo.web.async.DeferredResultHolder;import com.wise.async.listener.queue.demo.web.async.MockQueue;import lombok.extern.slf4j.Slf4j;/** * 订单控制器 * @author lingyuwang * */@RestController@RequestMapping(\"/order\")@Slf4jpublic class OrderController &#123; @Autowired private MockQueue mockQueue; @Autowired private DeferredResultHolder deferredResultHolder; @RequestMapping(\"/deferredResult\") public DeferredResult&lt;String&gt; deferredResult() throws Exception &#123; log.info(\"主线程开始\"); String orderNumber = RandomStringUtils.randomNumeric(8); mockQueue.setPlaceOrder(orderNumber); DeferredResult&lt;String&gt; result = new DeferredResult&lt;&gt;(); deferredResultHolder.getMap().put(orderNumber, result); return result; &#125; @RequestMapping(\"/callable\") public Callable&lt;String&gt; callable() &#123; log.info(\"主线程开始\"); return new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; log.info(\"副线程开始\"); Thread.sleep(1000); log.info(\"副线程返回\"); return \"success\"; &#125; &#125;; &#125;&#125; 2 DeferredResultHolder12345678910111213141516171819202122232425import java.util.HashMap;import java.util.Map;import org.springframework.stereotype.Component;import org.springframework.web.context.request.async.DeferredResult;/** * 简单模拟存储延迟结果 * @author lingyuwang * */@Componentpublic class DeferredResultHolder &#123; private Map&lt;String, DeferredResult&lt;String&gt;&gt; map = new HashMap&lt;String, DeferredResult&lt;String&gt;&gt;(); public Map&lt;String, DeferredResult&lt;String&gt;&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, DeferredResult&lt;String&gt;&gt; map) &#123; this.map = map; &#125;&#125; 3 队列监听器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextRefreshedEvent;import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;/** * 模拟监听队列 * @author lingyuwang * */@Component@Slf4jpublic class QueueListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Autowired private MockQueue mockQueue; @Autowired private DeferredResultHolder deferredResultHolder; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; new Thread(() -&gt; &#123; while (true) &#123; if (StringUtils.isNotBlank(mockQueue.getCompleteOrder())) &#123; String orderNumber = mockQueue.getCompleteOrder(); log.info(\"返回订单处理结果:\"+orderNumber); deferredResultHolder.getMap().get(orderNumber).setResult(orderNumber + \" : place order success\"); mockQueue.setCompleteOrder(null); &#125;else&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 4 队列12345678910111213141516171819202122232425262728293031323334353637383940414243import org.springframework.stereotype.Component;import lombok.extern.slf4j.Slf4j;/** * 简单模拟队列 * @author lingyuwang * */@Component@Slf4jpublic class MockQueue &#123; private String placeOrder; private String completeOrder; public String getPlaceOrder() &#123; return placeOrder; &#125; public void setPlaceOrder(String placeOrder) throws Exception &#123; new Thread(() -&gt; &#123; log.info(\"接到下单请求, \" + placeOrder); try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; this.completeOrder = placeOrder; log.info(\"下单请求处理完毕,\" + placeOrder); &#125;).start(); &#125; public String getCompleteOrder() &#123; return completeOrder; &#125; public void setCompleteOrder(String completeOrder) &#123; this.completeOrder = completeOrder; &#125;&#125; 5 测试浏览器访问 http://127.0.0.1:8087/order/deferredResult 控制台信息","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"异步","slug":"异步","permalink":"https://zhechu.github.io/tags/异步/"},{"name":"队列","slug":"队列","permalink":"https://zhechu.github.io/tags/队列/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringCloud集成OAuth2实现身份认证","slug":"SpringCloud集成OAuth2实现身份认证","date":"2019-05-04T09:52:39.000Z","updated":"2020-11-03T13:04:34.212Z","comments":false,"path":"2019/05/04/SpringCloud集成OAuth2实现身份认证/","link":"","permalink":"https://zhechu.github.io/2019/05/04/SpringCloud集成OAuth2实现身份认证/","excerpt":"","text":"1 参考资料https://stackoverflow.com/questions/30327269/spring-oauth-authorization-server-behind-spring-cloud-zuul-proxy https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/oauth2-vanilla/README.adoc https://github.com/wiselyman/uaa-zuul https://github.com/spring-projects/spring-security-oauth http://blog.didispace.com/spring-security-oauth2-xjf-3/ http://www.spring4all.com/article/833 2 推荐书籍 3 OAuth23.1 凭据类型 凭据共享（SSO） 全局密钥（开发者密钥） 特殊凭据（用户的特殊密钥） 授权访问（OAuth2） 3.2 授权许可类型 隐式许可a.只使用前端信道和授权服务器通信 b.只使用授权端点而不使用令牌端点，不要求客户端在授权端点上进行身份认证，客户端不需也无法持有客户端密钥 c.不可用于获取刷新令牌 b.适合完全运行在浏览器中的 JavaScript 应用 客户端凭据许可a.客户端代表自身从令牌端点获取令牌 b.适合后端系统之间直接通信 资源拥有者凭据许可a.缓解明文传输密码的风险 b.适合于客户端在每一个请求中直接向受保护资源使用用户凭据情况的优化 断言许可 授权码许可 3.3 refresh_token 的作用总的来说是提高应用的安全性。 若 access_token 受到劫持，其存在是短时间的（可以设置有效时间），因此对其的滥用是控制在一定范围内的。 但 refresh_token 被劫持，基本上无害的，攻击者需要得到 client_id 和 secrect_id (通常存储在服务器上)，再加上 refresh_token 才可以获取 access_token。 3.4 授权码许可中 code 的作用与 refresh_token 类似，提高安全性。若直接在重定向时返回的是 access_token（即隐式许可类型），则很容易被劫持（code 是直接通过重定向的查询参数返回的）。而返回 code，因其有效期非常短，且须结合 client_id 和 secrect_id (通常存储在服务器上)才能获取 access_token，即提高劫持 access_token 的成本，进而提高安全性。 3.5 授权码许可中 state 参数的作用防止跨站请求攻击，如：会话固化攻击、授权码暴力搜索（攻击者可能会用客户端向授权服务器暴力搜索有效的授权码，浪费客户端和授权服务器资源，而且还有可能导致客户端获取一个从未请求过的令牌）。 3.6 发送 bearer 令牌的方法 使用 HTTP Authorization 头部（官方推荐） 使用表单格式的请求体参数 使用 URL 编码的查询参数 3.7 客户端常见攻击3.7.1 CSRF 攻击方案：获取授权码时使用 state 参数。 3.7.2 凭据失窃方案：客户端动态注册，使得每个客户端实例的凭据都不一样。 3.7.3 重定向 URI 注册方案 精确匹配 redirect_uri。 客户端为每一个授权服务器注册不同的 redirect_uri。 3.7.4 授权码失窃3.7.5 令牌失窃方案：避免在查询参数传递 access_token。 3.8 受保护资源常见攻击3.8.1 XSS 攻击方案 选择合适的 Content-Type，如： application/json。避免使用 text/html。 入参出参需转义。 使用内容安全策略（content security policy，CSP），但存在浏览器兼容性问题。 3.9 授权服务器常见攻击3.9.1 会话劫持方案 使用 302 http 状态码，避免使用 307 状态码，导致用户凭据泄露。 授权码需绑定 client_id。 3.9.2 客户端假冒方案：获取访问令牌时也需带上 redirect_uri，并且与授权请求的 redirect_uri 的值必须相同（授权服务器在接收到获取访问令牌时也需判断其俩值是否一致）。 3.9.3 开放重定向器方案：授权码获取失败时，返回 http 400 状态码。 3.10 防止 OAuth 令牌攻击方案 使用 TLS 在权限范围的设置上尽量保守 授权服务器应该存储访问令牌的散列值，而不是令牌明文 授权服务器应该保持较短的访问令牌生命周期，以最小化因单个令牌泄露而导致的风险 资源服务器应该将访问令牌存储在瞬态内存中 PKCE 可用于提高授权码的安全性 3.11 避免授权服务器与受保护资源服务器共享数据方案：使用结构化令牌：JWT。 JWT 签名方式 HS256 对称签名 RS256 非对称签名 3.12 令牌失效原因 令牌到期 令牌被撤回","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://zhechu.github.io/tags/OAuth2/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"https://zhechu.github.io/tags/SpringSecurity/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Maven自动更新Snapshots依赖包方案","slug":"Maven自动更新Snapshots依赖包方案","date":"2019-04-29T14:56:38.000Z","updated":"2020-11-03T13:04:34.167Z","comments":false,"path":"2019/04/29/Maven自动更新Snapshots依赖包方案/","link":"","permalink":"https://zhechu.github.io/2019/04/29/Maven自动更新Snapshots依赖包方案/","excerpt":"","text":"强制更新 snapshot 类型的插件或依赖库，否则 Maven 一天只会更新一次 snapshot 依赖（版本不变更情况） 1 方案一在打包时强制更新1$ mvn clean package -U 2 方案二pom.xml 配置文件加上更新策略（updatePolicy）为 always123456789101112131415161718192021222324&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt;&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt;&lt;/pluginRepositories&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://zhechu.github.io/tags/Maven/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Maven常用命令","slug":"Maven常用命令","date":"2019-04-29T14:20:58.000Z","updated":"2020-11-03T13:04:34.167Z","comments":false,"path":"2019/04/29/Maven常用命令/","link":"","permalink":"https://zhechu.github.io/2019/04/29/Maven常用命令/","excerpt":"","text":"清空编译好的文件（target 文件夹）1$ mvn clean 将项目打包到 target 文件夹1$ mvn package 将项目打包安装到 Maven 本地仓库1$ mvn install 跳过测试安装1$ mvn install -DskipTests=true 导出 Maven 项目依赖的 JAR 包1$ mvn dependency:copy-dependencies 浏览项目依赖树（对于检查依赖冲突很有帮助）1$ mvn dependency:tree 发布项目到 Nexus（-P 参数为指定 profile）1$ mvn deploy -P prod 发布 JAR 包到 Nexus1$ mvn deploy:deploy-file -DgroupId=com.wise -DartifactId=taobao-sdk-java-auto -Dversion=1.0 -Dpackaging=jar -Dfile=D:\\taobao-sdk-java-auto.jar -Durl=http://192.168.163.41:8081/repository/maven-releases/ -DrepositoryId=releases","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://zhechu.github.io/tags/Maven/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringCloud集成TX-LCN分布式事务框架","slug":"SpringCloud集成TX-LCN分布式事务框架","date":"2019-04-27T04:59:42.000Z","updated":"2020-11-03T13:04:34.212Z","comments":false,"path":"2019/04/27/SpringCloud集成TX-LCN分布式事务框架/","link":"","permalink":"https://zhechu.github.io/2019/04/27/SpringCloud集成TX-LCN分布式事务框架/","excerpt":"","text":"环境 版本 SpringCloud Edgware.RELEASE SpringBoot 1.5.9.RELEASE TXLCN 5.0.2.RELEASE TXLCN 官方文档 https://txlcn.org/zh-cn/docs/start.html TXLCN 官方示例代码 https://github.com/codingapi/txlcn-demo/tree/1.5.boot 1 示例代码事务管理器示例 https://github.com/zhechu/txlcn-tm-demo 客户端服务示例 https://github.com/zhechu/springcloud-txlcn-demo 注册中心示例 https://github.com/zhechu/eureka-server 2 集成注意事项2.1 事务管理器建议将事务管理器单独出来管理，避免依赖错乱。 按官方步骤即可 初始化数据库（初始化脚本在 txlcn-demo.sql 文件） 配置 application.properties 新建启动类 2.2 注册中心配置笔者使用的是 eureka 作为注册中心，因此客户端服务（spring-demo-client、spring-demo-d、spring-demo-e）的 pom.xml 需引入 eureka 依赖替代 consul 1234567891011121314151617181920 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo-common&lt;/artifactId&gt; &lt;/dependency&gt;&lt;!-- consul --&gt;&lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt; &lt;/dependency&gt; --&gt;&lt;!-- eureka --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt; &lt;/dependencies&gt; 同时添加 eureka 配置1234567891011121314#################################################################################################################################### eureka ########################################################################################################################################eureka: client: serviceUrl: defaultZone: http://admin:123456@127.0.0.1:8761/eureka instance: preferIpAddress: true # Renew频率,默认是30秒 leaseRenewalIntervalInSeconds: 60 # 服务失效时间,默认是90秒 leaseExpirationDurationInSeconds: 120 instanceId: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125; 2.3 客户端服务初始化数据库初始化脚本在 txlcn-demo.sql 文件","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://zhechu.github.io/tags/SpringCloud/"},{"name":"分布式事务","slug":"分布式事务","permalink":"https://zhechu.github.io/tags/分布式事务/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringCloud配置中心&服务重启才生效","slug":"SpringCloud配置中心-服务重启才生效","date":"2019-04-21T14:09:05.000Z","updated":"2020-11-03T13:04:34.212Z","comments":false,"path":"2019/04/21/SpringCloud配置中心-服务重启才生效/","link":"","permalink":"https://zhechu.github.io/2019/04/21/SpringCloud配置中心-服务重启才生效/","excerpt":"","text":"示例代码注册中心https://github.com/zhechu/eureka-server 配置中心仓库https://github.com/zhechu/config-center-repo 配置中心https://github.com/zhechu/config-center-server 示例服务1https://github.com/zhechu/config-center-client-demo-one 示例服务2https://github.com/zhechu/config-center-client-demo-two 查看配置中心的服务配置http://127.0.0.1:8080/config-center-client-demo-one/dev/master http://127.0.0.1:8080/config-center-client-demo-two/dev/master 访问服务检查配置是否刷新http://127.0.0.1:8081/hello http://127.0.0.1:8082/hello","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"配置中心","slug":"配置中心","permalink":"https://zhechu.github.io/tags/配置中心/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"SpringCloud配置中心&支持动态刷新","slug":"SpringCloud配置中心-支持动态刷新","date":"2019-04-21T13:21:27.000Z","updated":"2020-11-03T13:04:34.212Z","comments":false,"path":"2019/04/21/SpringCloud配置中心-支持动态刷新/","link":"","permalink":"https://zhechu.github.io/2019/04/21/SpringCloud配置中心-支持动态刷新/","excerpt":"","text":"示例代码注册中心https://github.com/zhechu/eureka-server 配置中心仓库https://github.com/zhechu/config-center-repo 配置中心https://github.com/zhechu/config-center-server-refresh-cloud-bus 示例服务1https://github.com/zhechu/config-center-client-demo-one-refresh-cloud-bus 示例服务2https://github.com/zhechu/config-center-client-demo-two-refresh-cloud-bus 查看配置中心的服务配置http://127.0.0.1:8080/config-center-client-demo-one-refresh-cloud-bus/dev/master http://127.0.0.1:8080/config-center-client-demo-two-refresh-cloud-bus/dev/master 访问服务检查配置是否刷新http://127.0.0.1:8081/hello http://127.0.0.1:8082/hello 动态刷新服务配置12345$ curl -u admin:123456 -X POST http://127.0.0.1:8080/bus/refresh$ curl -u admin:123456 -X POST http://127.0.0.1:8080/bus/refresh?destination=config-center-client-demo-one-refresh-cloud-bus:8081$ curl -u admin:123456 -X POST http://127.0.0.1:8080/bus/refresh?destination=config-center-client-demo-two-refresh-cloud-bus:**","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zhechu.github.io/tags/Spring/"},{"name":"微服务","slug":"微服务","permalink":"https://zhechu.github.io/tags/微服务/"},{"name":"配置中心","slug":"配置中心","permalink":"https://zhechu.github.io/tags/配置中心/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Docker安装Gitlab","slug":"Docker安装Gitlab","date":"2019-04-20T12:33:02.000Z","updated":"2020-11-03T13:04:34.061Z","comments":false,"path":"2019/04/20/Docker安装Gitlab/","link":"","permalink":"https://zhechu.github.io/2019/04/20/Docker安装Gitlab/","excerpt":"","text":"环境说明 环境 说明 Docker-1.13.1 应用容器引擎 Gitlab-11.9.8-ce.0 仓库管理系统 官方文档 https://docs.gitlab.com/omnibus/docker/README.html 下载官方镜像1$ docker pull gitlab/gitlab-ce:11.9.8-ce.0 启动容器1$ docker run -d -p 1443:443 -p 1180:1180 -p 1122:22 --name gitlab -v /data/gitlab/config:/etc/gitlab -v /data/gitlab/logs:/var/log/gitlab -v /data/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:11.9.8-ce.0 TIPS：将 gitlab 容器内默认的端口 80 改为 1180，便于修改克隆地址。 修改克隆地址12345$ vi /data/gitlab/config/gitlab.rbexternal_url \"http://192.168.163.41:1180\"nginx['listen_port'] = 1180gitlab_rails['gitlab_ssh_host'] = '192.168.163.41'gitlab_rails['gitlab_shell_ssh_port'] = 1122 重启容器1$ docker restart gitlab 查看日志1$ docker logs -f gitlab 访问浏览器 http://192.168.163.41:1180","categories":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"https://zhechu.github.io/categories/Git/"}]},{"title":"MQ&ELK收集日志","slug":"MQ-ELK收集日志","date":"2019-04-19T13:58:34.000Z","updated":"2020-11-03T13:04:34.162Z","comments":false,"path":"2019/04/19/MQ-ELK收集日志/","link":"","permalink":"https://zhechu.github.io/2019/04/19/MQ-ELK收集日志/","excerpt":"","text":"环境说明 环境 说明 rabbitmq-3.7-management 消息中间件 elasticsearch-5.6.9 搜索服务器 logstash-5.6.9 数据处理工具 kibana-5.6.9 分析数据和可视化平台 1 RabbitMQ + ELK1.1 选型理由由于服务较多，使用 ELK 单独接收日志并将其可视化，可提高排查故障的效率。若只使用 ELK，可能会发现日志有丢失的情况。因此将日志发送至 RabbitMQ，作为缓冲，可缓解日志丢失的问题。RabbitMQ 稳定性比较高，也可以做集群，因此选择它。 1.2 日志流 1.3 部署 RabbitMQRabbitMQ 官方镜像文档 https://hub.docker.com/_/rabbitmq/ 由于官方镜像默认的账号不支持远程访问控，因此此处进行薄层封装。 新建 Dockerfile1234567$ vi DockerfileFROM rabbitmq:3.7-managementMAINTAINER lingyuwang ling-yu-wang@qq.comADD run.sh /root/run.shRUN chmod 755 /root/run.shENTRYPOINT [\"/root/run.sh\"]CMD [\"\"] 新建 run.sh 作为镜像启动脚本12345678910111213141516171819$ vi run.sh#!/bin/bashdocker-entrypoint.sh rabbitmq-serversleep 5suser=guestpass=guestif [ $RABBITMQ_DEFAULT_USER ];then user=\"$RABBITMQ_DEFAULT_USER\"fiif [ $RABBITMQ_DEFAULT_PASS ];then pass=\"$RABBITMQ_DEFAULT_PASS\"fi# 新建用户rabbitmqctl add_user \"$user\" \"$pass\"# 用户授权rabbitmqctl set_permissions -p / \"$user\" \".*\" \".*\" \".*\"rabbitmqctl set_user_tags \"$user\" administrator 构建镜像 rabbitmq:3.7-management-plus1$ docker build -t rabbitmq:3.7-management-plus . 启动容器1$ docker run -d --name rabbitmq -v /var/lib/rabbitmq:/data/rabbitmq -p 5672:5672 -p 15672:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 rabbitmq:3.7-management-plus 浏览器进入 web 控制台 http://192.168.163.41:15672 admin/123456 1.4 与 spring-boot 集成示例代码 https://github.com/zhechu/spring-boot-rabbitmq-elk-demo 1.4.1 pom.xml 添加依赖123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;!-- logback --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt; &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- logback 日志JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.janino&lt;/groupId&gt; &lt;artifactId&gt;janino&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/dependency&gt; &lt;!-- rabbitmq --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; TIPS：logback 和 logstash-logback-encoder 的版本不要随便改（版本兼容性不好）。 1.4.2 application.yml支持日志打印在控制台、文件和发送到 RabbitMQ123456789101112131415161718###################################################################################################################################### 日志 ##########################################################################################################################################log: level: INFO console: enable: true file: enable: true destination: ./logs rabbitmq: enable: true host: 192.168.163.41 port: 5672 username: admin password: 123456 exchange: ex_logstash routingKey: runtime.logging jasypt-spring-boot 官方文档 https://github.com/ulisesbocchio/jasypt-spring-boot 参考文档 https://www.cnblogs.com/zz0412/p/jasypt-001.html TIPS：RabbitMQ 的密码可以用 jasypt 加密。本地开发建议将 log.rabbitmq.enable 设置为 false，表示不发日志到 MQ。 1.4.3 修复 JSON 解析 BUG新建 AmqpLogbackAppender.java 类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.wise.demo.log;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.logback.AmqpAppender;import ch.qos.logback.classic.spi.ILoggingEvent;import ch.qos.logback.core.encoder.Encoder;/** * 修复 json 解析 BUG * @author lingyuwang * */public class AmqpLogbackAppender extends AmqpAppender &#123; private Encoder&lt;ILoggingEvent&gt; encoder; /** * We remove the default message layout and replace with the JSON &#123;@link Encoder&#125; */ @Override public Message postProcessMessageBeforeSend(Message message, Event event) &#123; return new Message(this.encoder.encode(event.getEvent()), message.getMessageProperties()); &#125; @Override public void start() &#123; super.start(); encoder.setContext(getContext()); if (!encoder.isStarted()) &#123; encoder.start(); &#125; &#125; @Override public void stop() &#123; super.stop(); encoder.stop(); &#125; public Encoder&lt;ILoggingEvent&gt; getEncoder() &#123; return encoder; &#125; public void setEncoder(Encoder&lt;ILoggingEvent&gt; encoder) &#123; this.encoder = encoder; &#125;&#125; 1.4.4 logback-spring.xml新建 src/main/resources/logback-spring.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- level --&gt; &lt;springProperty name=\"logLevel\" source=\"log.level\" /&gt; &lt;!-- console --&gt; &lt;springProperty name=\"logConsoleEnable\" source=\"log.console.enable\" /&gt; &lt;!-- file --&gt; &lt;springProperty name=\"logFileEnable\" source=\"log.file.enable\" /&gt; &lt;springProperty name=\"logFileDestination\" source=\"log.file.destination\" /&gt; &lt;!-- rabbitmq --&gt; &lt;springProperty name=\"logRabbitmqEnable\" source=\"log.rabbitmq.enable\" /&gt; &lt;springProperty name=\"logRabbitmqHost\" source=\"log.rabbitmq.host\" /&gt; &lt;springProperty name=\"logRabbitmqPort\" source=\"log.rabbitmq.port\" /&gt; &lt;springProperty name=\"logRabbitmqUsername\" source=\"log.rabbitmq.username\" /&gt; &lt;springProperty name=\"logRabbitmqPassword\" source=\"log.rabbitmq.password\" /&gt; &lt;springProperty name=\"logRabbitmqExchange\" source=\"log.rabbitmq.exchange\" /&gt; &lt;springProperty name=\"logRabbitmqRoutingKey\" source=\"log.rabbitmq.routingKey\" /&gt; &lt;!-- app --&gt; &lt;springProperty scope=\"context\" name=\"appname\" source=\"spring.application.name\" /&gt; &lt;include resource=\"org/springframework/boot/logging/logback/defaults.xml\" /&gt; &lt;include resource=\"org/springframework/boot/logging/logback/console-appender.xml\" /&gt; &lt;contextName&gt;$&#123;appname&#125;&lt;/contextName&gt; &lt;!-- 文件输出 --&gt; &lt;if condition='property(\"logFileEnable\").equalsIgnoreCase(\"true\")'&gt; &lt;then&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!-- 输出格式 --&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;FILE_LOG_PATTERN&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;FileNamePattern&gt;$&#123;logFileDestination&#125;/$&#123;appname&#125;-%d&#123;yyyy-MM-dd&#125;.log&lt;/FileNamePattern&gt; &lt;!--日志文件保留天数--&gt; &lt;MaxHistory&gt;30&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;!--日志文件最大的大小--&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;/appender&gt; &lt;/then&gt; &lt;/if&gt; &lt;!-- RabbitMQ 输出 --&gt; &lt;if condition='property(\"logRabbitmqEnable\").equalsIgnoreCase(\"true\")'&gt; &lt;then&gt; &lt;appender name=\"AMQP\" class=\"com.wise.demo.log.AmqpLogbackAppender\"&gt; &lt;!-- layout is required but ignored as using the encoder for the AMQP message body --&gt; &lt;layout&gt;&lt;pattern&gt;&lt;![CDATA[ %level ]]&gt;&lt;/pattern&gt;&lt;/layout&gt; &lt;!-- 将 appname 作为自定义域加入日志，方便日志搜索 --&gt; &lt;encoder class=\"net.logstash.logback.encoder.LogstashEncoder\"&gt; &lt;customFields&gt;&#123;\"appname\": \"$&#123;appname&#125;\"&#125;&lt;/customFields&gt; &lt;/encoder&gt; &lt;host&gt;$&#123;logRabbitmqHost&#125;&lt;/host&gt; &lt;port&gt;$&#123;logRabbitmqPort&#125;&lt;/port&gt; &lt;username&gt;$&#123;logRabbitmqUsername&#125;&lt;/username&gt; &lt;password&gt;$&#123;logRabbitmqPassword&#125;&lt;/password&gt; &lt;exchangeName&gt;$&#123;logRabbitmqExchange&#125;&lt;/exchangeName&gt; &lt;routingKeyPattern&gt;$&#123;logRabbitmqRoutingKey&#125;&lt;/routingKeyPattern&gt; &lt;declareExchange&gt;true&lt;/declareExchange&gt; &lt;exchangeType&gt;topic&lt;/exchangeType&gt; &lt;generateId&gt;true&lt;/generateId&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;durable&gt;true&lt;/durable&gt; &lt;deliveryMode&gt;PERSISTENT&lt;/deliveryMode&gt; &lt;/appender&gt; &lt;/then&gt; &lt;/if&gt; &lt;!-- 根logger --&gt; &lt;root level=\"INFO\"&gt; &lt;!-- 控制台 --&gt; &lt;if condition='property(\"logConsoleEnable\").equalsIgnoreCase(\"true\")'&gt; &lt;then&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;/then&gt; &lt;/if&gt; &lt;!-- file --&gt; &lt;if condition='property(\"logFileEnable\").equalsIgnoreCase(\"true\")'&gt; &lt;then&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/then&gt; &lt;/if&gt; &lt;!-- rabbitmq --&gt; &lt;if condition='property(\"logRabbitmqEnable\").equalsIgnoreCase(\"true\")'&gt; &lt;then&gt; &lt;appender-ref ref=\"AMQP\" /&gt; &lt;/then&gt; &lt;/if&gt; &lt;/root&gt; &lt;logger name=\"com.wise\" level=\"$&#123;logLevel&#125;\" /&gt; &lt;logger name=\"org.springframework\" level=\"$&#123;logLevel&#125;\" /&gt; &lt;logger name=\"com.netflix\" level=\"$&#123;logLevel&#125;\" /&gt;&lt;/configuration&gt; 1.4.5 启动服务运行 com.wise.demo.Application 类 TIPS：日志文件的位置为当前工程目录下。 1.5 部署 Elasticsearchelasticsearch 官方镜像文档 https://hub.docker.com/_/elasticsearch/ 下载官方镜像1$ docker pull elasticsearch:5.6.9-alpine 启动容器1$ docker run -d --name elasticsearch -v /data/elasticsearch:/usr/share/elasticsearch/data -p 9200:9200 -p 9300:9300 elasticsearch:5.6.9-alpine 1.6 部署 kibanakibana 官方镜像文档 https://hub.docker.com/_/kibana/ 下载官方镜像1$ docker pull kibana:5.6.9 新建 kibana.yml 文件123456$ mkdir -p /etc/kibana$ vi /etc/kibana/kibana.ymlserver.host: '0.0.0.0'# 先不填，测试环境变量是否生效elasticsearch.url: ''logging.quiet: true TIPS：需要配置挂载，将此配置文件挂载到容器目录 /etc/kibana，将默认配置替换。主要是将 logging.quiet 设置为 true，默认是 false，表示“设置为 true 以禁止除错误消息之外的所有日志记录输出”。elasticsearch.url 环境变量会替换，这里可以不配。 kibana.yml 详细内容（包括注释）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# Kibana is served by a back end server. This setting specifies the port to use.#server.port: 5601# Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.# The default is 'localhost', which usually means remote machines will not be able to connect.# To allow connections from remote users, set this parameter to a non-loopback address.server.host: '0.0.0.0'# Enables you to specify a path to mount Kibana at if you are running behind a proxy. This only affects# the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests# to Kibana. This setting cannot end in a slash.#server.basePath: \"\"# The maximum payload size in bytes for incoming server requests.#server.maxPayloadBytes: 1048576# The Kibana server's name. This is used for display purposes.#server.name: \"your-hostname\"# The URL of the Elasticsearch instance to use for all your queries.elasticsearch.url: ''# When this setting's value is true Kibana uses the hostname specified in the server.host# setting. When the value of this setting is false, Kibana uses the hostname of the host# that connects to this Kibana instance.#elasticsearch.preserveHost: true# Kibana uses an index in Elasticsearch to store saved searches, visualizations and# dashboards. Kibana creates a new index if the index doesn't already exist.#kibana.index: \".kibana\"# The default application to load.#kibana.defaultAppId: \"discover\"# If your Elasticsearch is protected with basic authentication, these settings provide# the username and password that the Kibana server uses to perform maintenance on the Kibana# index at startup. Your Kibana users still need to authenticate with Elasticsearch, which# is proxied through the Kibana server.#elasticsearch.username: \"user\"#elasticsearch.password: \"pass\"# Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively.# These settings enable SSL for outgoing requests from the Kibana server to the browser.#server.ssl.enabled: false#server.ssl.certificate: /path/to/your/server.crt#server.ssl.key: /path/to/your/server.key# Optional settings that provide the paths to the PEM-format SSL certificate and key files.# These files validate that your Elasticsearch backend uses the same key files.#elasticsearch.ssl.certificate: /path/to/your/client.crt#elasticsearch.ssl.key: /path/to/your/client.key# Optional setting that enables you to specify a path to the PEM file for the certificate# authority for your Elasticsearch instance.#elasticsearch.ssl.certificateAuthorities: [ \"/path/to/your/CA.pem\" ]# To disregard the validity of SSL certificates, change this setting's value to 'none'.#elasticsearch.ssl.verificationMode: full# Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of# the elasticsearch.requestTimeout setting.#elasticsearch.pingTimeout: 1500# Time in milliseconds to wait for responses from the back end or Elasticsearch. This value# must be a positive integer.#elasticsearch.requestTimeout: 30000# List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side# headers, set this value to [] (an empty list).#elasticsearch.requestHeadersWhitelist: [ authorization ]# Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten# by client-side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.#elasticsearch.customHeaders: &#123;&#125;# Time in milliseconds for Elasticsearch to wait for responses from shards. Set to 0 to disable.#elasticsearch.shardTimeout: 0# Time in milliseconds to wait for Elasticsearch at Kibana startup before retrying.#elasticsearch.startupTimeout: 5000# Specifies the path where Kibana creates the process ID file.#pid.file: /var/run/kibana.pid# Enables you specify a file where Kibana stores log output.#logging.dest: stdout# Set the value of this setting to true to suppress all logging output.#logging.silent: false# Set the value of this setting to true to suppress all logging output other than error messages.logging.quiet: true# Set the value of this setting to true to log all events, including system usage information# and all requests.#logging.verbose: false# Set the interval in milliseconds to sample system and process performance# metrics. Minimum is 100ms. Defaults to 5000.#ops.interval: 5000# The default locale. This locale can be used in certain circumstances to substitute any missing# translations.#i18n.defaultLocale: \"en\" 启动容器1$ docker run -d --name kibana -v /etc/kibana:/etc/kibana -e ELASTICSEARCH_URL=\"http://192.168.163.41:9200\" -p 5601:5601 kibana:5.6.9 启动后检查环境变量的配置是否生效，1$ cat /etc/kibana/kibana.yml 浏览器访问 http://192.168.163.41:5601 TIPS：kibana 没有权限控制，可以通过使用 Nginx 代理添加用户名和密码。 1.7 部署 Logstashlogstash 官方镜像文档 https://hub.docker.com/_/logstash/ plugins-inputs-rabbitmq 官方文档 https://www.elastic.co/guide/en/logstash/5.6/plugins-inputs-rabbitmq.html plugins-outputs-elasticsearch 官方文档 https://www.elastic.co/guide/en/logstash/5.6/plugins-outputs-elasticsearch.html 下载官方镜像1$ docker pull logstash:5.6.9-alpine 新建 rabbitmq.conf 配置文件，监听 MQ 消息1234567891011121314151617181920212223$ mkdir -p /etc/logstash$ vi /etc/logstash/rabbitmq.confinput &#123; rabbitmq &#123; host =&gt; \"192.168.163.41\" queue =&gt; \"qu_logstash\" durable =&gt; true exchange =&gt; \"ex_logstash\" key =&gt; \"runtime.*\" threads =&gt; 2 type =&gt; \"topic\" prefetch_count =&gt; 200 port =&gt; 5672 user =&gt; \"admin\" password =&gt; \"123456\" &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; \"192.168.163.41:9200\" index =&gt; \"microserver-%&#123;+YYYY.MM.dd&#125;\" &#125;&#125; TIPS： 需要配置挂载，将此配置文件挂载到目录 /usr/share/logstash/config。并需配置启动命令参数 -f 和 /config-dir/rabbitmq.conf，表示启动指定配置文档。 当并发请求量比较大时，可以将 threads 参数配大点。 启动容器1$ docker run -d --name logstash -v /etc/logstash:/usr/share/logstash/config logstash:5.6.9-alpine -f /usr/share/logstash/config/rabbitmq.conf TIPS：外网不需访问，不需配置映射端口。需先启动 RabbitMQ 和 Elasticsearch，且 RabbitMQ 需要已存在 ex_logstash 交换器（由服务生成，先启动已集成的服务即可）。 1.8 测试kibana 官方使用手册 https://www.elastic.co/guide/cn/kibana/current/discover.html 启动 spring-boot 服务，打开 kibana 新建微服务索引 microserver-* 索引管理 查看日志 查询示例1appname: \"spring-boot-rabbitmq-elk-demo\" AND level:\"WARN\" 1.9 定时清理 elasticsearch 的日志每天0时清理7天前数据，即保留最近7天数据12345678910111213141516171819202122232425262728293031323334$ mkdir -p /usr/share/elasticsearch$ vi /usr/share/elasticsearch/clear_es.sh#!/bin/bash# @Author: lingyuwang# @Date: 2018-05-09 11:46:00# @Last Modified by: lingyuwang# @Last Modified time: 2018-05-10 11:46:00# 保留近N天,不包括今天,今天的数据会保留KEEP_DAYS=7ES_IP=192.168.163.41# 删除前N的所有天到前N+10天==&gt;每天执行function get_todelete_days()&#123; # declare -A DAY_ARR # DAY_ARR=\"\" for i in $(seq 1 10); do THIS_DAY=$(date -d \"$(($KEEP_DAYS+$i)) day ago\" +%Y.%m.%d) DAY_ARR=( \"$&#123;DAY_ARR[@]&#125;\" $THIS_DAY) done echo $&#123;DAY_ARR[*]&#125;&#125;# 返回数组的写法TO_DELETE_DAYS=(`get_todelete_days`)for day in \"$&#123;TO_DELETE_DAYS[@]&#125;\"do echo \"$day will be delete\" curl -XDELETE 'http://'$&#123;ES_IP&#125;':9200/*-'$&#123;day&#125;done 添加脚本执行权限1$ chmod +x /usr/share/elasticsearch/clear_es.sh 设置定时每天 0 点清理12$ crontab -e0 0 * * * /usr/share/elasticsearch/clear_es.sh 测试清理日志1$ /usr/share/elasticsearch/clear_es.sh 2 Kafka + ELK待更新。","categories":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"日志","slug":"日志","permalink":"https://zhechu.github.io/tags/日志/"},{"name":"队列","slug":"队列","permalink":"https://zhechu.github.io/tags/队列/"}],"keywords":[{"name":"ELK","slug":"ELK","permalink":"https://zhechu.github.io/categories/ELK/"}]},{"title":"代码生成系统","slug":"代码生成系统","date":"2019-04-17T15:19:47.000Z","updated":"2020-11-03T13:04:34.275Z","comments":false,"path":"2019/04/17/代码生成系统/","link":"","permalink":"https://zhechu.github.io/2019/04/17/代码生成系统/","excerpt":"","text":"lemur-generation 说明：本系统在 https://gitee.com/lemur/lemur-generation 的基础上进行二次开发，主要做了以下改进： 增加了对 Oracle 数据库的支持； 屏蔽部分功能。 感谢原作者的开源！ 代码托管地址 https://github.com/zhechu/lemur-generation 启动方法 下载代码 导入 gen.sql 的 SQL 运行 GenApplication TIPS：具体使用方法请看使用说明一节。 模板开发推荐使用 beetl 模板 1 变量说明1.1 全局变量 变量 说明 g.author 作者 g.codePackage 代码文件的包名 t.tableName 表名 t.name 类名 t.chinaName 类的功能描述 t.idName 主键属性名称 t.idType 主键属性类型 t.idFieldName 数据库主键名称 t.idJdbcType 主键 JDBC 类型 t.fields 表字段列表 1.2 表字段变量 变量 描述 fieldName 数据库字段名称 fieldType 数据库字段类型 name 字段属性名称 type 字段属性类型 jdbcType 字段 JDBC 类型 2 beetl 模板示例https://github.com/zhechu/lemur-generation/tree/master/gen-admin/src/main/resources/template 使用说明1 登录http://127.0.0.1:7890 账号和密码：admin/123456 2 数据库管理 数据库管理是对数据源进行管理，目前支持的数据源有两个：Oracle 和 Mysql。 新建数据库：开发环境 Oracle TIPS：账号必须为 sys as sysdba，密码保守设置为数字（因为 Oracle 远程连接数据库密码有大小写敏感问题）。 3 参数管理 参数是对服务进行配置，比如：服务的包名，还有开发的作者、代码文件的编码。 新建参数：公共服务管理 TIPS：这里 code 包对应的是服务的包名。 4 模板组管理 模板组的作用是对模板进行分类。 新建模板组：SpringBoot 5 模板管理 模板管理是对生成代码的模板进行管理。 新建模板：实体模板 TIPS：文件名称 %s 是占位符，将会被替换为类的名称。路径是实体相对的所在包名。本地路径是相对 src/main 的路径。类型推荐用 beetl 模板。 6 表管理 表管理是对数据库的表映射进行维护，方便代码生成。 DB 导入表：学生管理报到注册表 修改表的类名和功能描述 表字段设置 TIPS：修改表字段的名称、类型和选择主键（表导入时，程序会自动将类型设置好，但是特殊类型，不支持，所以要检查下，重要） 7 代码生成 将表导入并设置好之后，就可以进行生成代码了。 生成代码：测试表 生成代码会下载压缩文件，解压文件如下 TIPS：生成的代码，复制到实际工程去后，可能会存在依赖包没导入，即文件头的 import 语句那块，有些包可能没导入，需手工处理——与相应模板相关。","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"代码生成","slug":"代码生成","permalink":"https://zhechu.github.io/tags/代码生成/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"Redis完整缓存架构","slug":"Redis完整缓存架构","date":"2019-04-15T14:55:45.000Z","updated":"2020-11-03T13:04:34.182Z","comments":false,"path":"2019/04/15/Redis完整缓存架构/","link":"","permalink":"https://zhechu.github.io/2019/04/15/Redis完整缓存架构/","excerpt":"","text":"1 三级缓存Nginx 本地缓存（接入层） + Redis 分布式缓存 + JVM 缓存 缓存数据生产服务的工作流程（张开涛的方案） 监听多个kafka topic，每个kafka topic对应一个服务（简化一下，监听一个kafka topic） 如果一个服务发生了数据变更，那么就发送一个消息到kafka topic中 缓存数据生产服务监听到了消息以后，就发送请求到对应的服务中调用接口以及拉取数据，此时是从mysql中查询的 缓存数据生产服务拉取到了数据之后，会将数据在本地缓存中写入一份，就是ehcache中 同时会将数据在redis中写入一份 双层nginx 时效性要求非常高的数据：库存 时效性要求不高的数据：商品的基本信息（名称、颜色、版本、规格参数，等等） 1.1 时效性高的数据的缓存方案商品价格/库存等时效性要求高的数据，而且种类较少，采取相关的服务系统每次发生了变更的时候，直接采取数据库和 Redis 缓存双写的方案，这样缓存的时效性最高。 1.2 时效性不高的数据的缓存方案商品基本信息等时效性不高的数据，而且种类繁多，来自多种不同的系统，采取 MQ 异步通知的方式，使用独立的数据生产服务，监听 MQ 消息，然后异步拉取服务的数据，更新 JVM 缓存和 Redis 缓存。 2 缓存更新策略2.1 cache aside pattern示例代码（借用大神的代码） https://github.com/heyxyw/eshop-inventory 最经典的缓存 + 数据库读写的模式：cache aside pattern 读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应 更新的时候，先删除缓存，再更新数据库 2.2 异步串行更新数据库与缓存更新与读取操作进行异步串行化（JVM 队列，请求路由到同一个服务上）。 2.3 设置过期时间每隔 XX 分钟，自动过期。 2.4 LRUmaxmemory，设置 Redis 用来存放数据的最大的内存大小，一旦超出这个内存大小之后，就会立即使用 LRU 算法清理掉部分数据。 对于 64 bit 的机器，若 maxmemory 设置为0，则默认不限制内存的使用，直到耗尽机器中所有的内存为止; 但是对于 32 bit 的机器，有一个隐式的限制就是 3GB。 maxmemory-policy，可以设置内存达到最大限制后，采取什么策略来处理 noeviction: 若内存使用达到了 maxmemory，客户端继续写入数据，则直接报错给客户端 allkeys-lru: LRU 算法，将最近最少使用的数据从缓存中清除出去 volatile-lru: LRU 算法，但是仅仅针对那些设置了指定存活时间（TTL）的 key 才会清理掉 allkeys-random: 随机选择一些 key 来删除掉 volatile-random: 随机选择一些设置了 TTL 的 key 来删除掉 volatile-ttl: 移除掉部分 key，选择 TTL 时间比较短的 key 3 分布式重建缓存的并发冲突问题3.1 添加版本号添加版本号，新的版本将会覆盖旧版本（可以将数据的修改时间作为版本）。 3.2 添加分布式锁Redis 分布式锁 变更缓存重建以及空缓存请求重建，更新 Redis 之前，都需要先获取对应商品 id 的分布式锁 拿到分布式锁之后，需要根据时间版本去比较一下，若本身的版本新于 Redis 中的版本，则更新，否则就不更新 若拿不到分布式锁，则等待，直到获取到分布式锁 4 缓存穿透 预加载数据 null 数据也缓存 缓存没数据且访问数据时，加双重检测锁","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"},{"name":"架构","slug":"架构","permalink":"https://zhechu.github.io/tags/架构/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"Redis应用案例","slug":"Redis应用案例","date":"2019-04-14T08:59:29.000Z","updated":"2020-11-03T13:04:34.185Z","comments":false,"path":"2019/04/14/Redis应用案例/","link":"","permalink":"https://zhechu.github.io/2019/04/14/Redis应用案例/","excerpt":"","text":"1 用户活跃度评奖1.1 场景1亿个用户，每个用户登陆/做任意操作，记为今天活跃，否则记为不活跃。每周评出连续7天活跃的用户。 1.2 方案每天按日期生成一个位图，用户登陆后，把 user_id （数值，主键自动增长。若 user_id 是 UUID 字符串，则可以增加一列，设置为自动增长，表示是第几位注册用户）位上的值设为1，把1周的位图按 and 计算, 若结果的位值为1的,即是连续7天登陆的用户。 1.3 位图法 日期 所有用户活跃数据【二进制表示】 活跃人数 log20180705 1100010001…1 4 log20180706 1011110001…0 5 …… …… …… TIPS：第一个位只是方便存储，不表示任何意义。从第二个位开始，1表示活跃，0表示不活跃。如：1100010001…1表示第一个用户活跃，第二个用户不活跃，最后一个用户活跃。 1.4 例如：统计连续三天活跃的用户【用户数为8】演示数据准备123456789101112&gt; setbit log20180705 100000000 0&gt; setbit log20180705 3 1&gt; setbit log20180705 5 1&gt; setbit log20180705 7 1&gt; setbit log20180706 100000000 0&gt; setbit log20180706 3 1&gt; setbit log20180706 5 1&gt; setbit log20180706 8 1&gt; setbit log20180707 100000000 0&gt; setbit log20180707 3 1&gt; setbit log20180707 4 1&gt; setbit log20180707 6 1 统计并存储结果1&gt; bitop and result log20180705 log20180706 log20180707 查看第3个用户是否连续三天活跃【1表示活跃，0表示不活跃】1&gt; getbit result 3 查看第5个用户是否连续三天活跃1&gt; getbit result 5 1.5 总结优点 节约空间，1亿人每天的登陆情况，用1亿 bit，约 1200WByte，约10M的字符就能表示 计算方便 2 标签系统2.1 场景查找同时具有 WEB 和 PHP 标签的书。 2.2 方案根据书的标签构建反向索引。 2.3 Mysql 实现创建 book 表及初始化数据12345678910create table book (bookid int,title char(20))engine InnoDB charset utf8;insert into book values(5 , 'PHP圣经'),(6 , 'ruby实战'),(7 , 'mysql运维'),(8, 'ruby服务端编程'); 创建 tags 表及初始化数据1234567891011121314create table tags (tid int,bookid int,content char(20))engine InnoDB charset utf8;insert into tags values(10 , 5 , 'PHP'),(11 , 5 , 'WEB'),(12 , 6 , 'WEB'),(13 , 6 , 'ruby'),(14 , 7 , 'database'),(15 , 8 , 'ruby'),(16 , 8 , 'server'); 查找同时具有 WEB 和 PHP 标签的书123456789SELECT b.*FROM tagsINNER JOIN tags AS t ON tags.bookid = t.bookidLEFT JOIN book AS b ON tags.bookid = b.bookidWHERE tags.content = 'PHP'AND t.content = 'WEB'; 2.4 Redis 实现String 键值对存储 book1234&gt; set book:5:title 'PHP圣经'&gt; set book:6:title 'ruby实战'&gt; set book:7:title 'mysql运难'&gt; set book:8:title 'ruby server' TIPS：若存储的是 book 的多个属性，建议使用 Hash 数据结构。既节省内存，又方便控制。如：方便删除，删除全部 book 数据时只删除一个 Key 即可。 Set 无序集合存储 tag12345&gt; sadd tag:PHP 5&gt; sadd tag:WEB 5 6&gt; sadd tag:database 7&gt; sadd tag:ruby 6 8&gt; sadd tag:SERVER 8 查找同时具有 WEB 和 PHP 标签的书【求交集】1&gt; sinter tag:WEB tag:PHP 查找有 WEB 或 PHP 标签的书【求并集】1&gt; sunion tag:WEB tag:PHP 查找有 ruby 但没有 PHP 标签的书【求差集】1&gt; sdiff tag:WEB tag:PHP 2.5 总结Redis 实现的优点 性能更高 计算方便 3 缓存热门图片3.1 场景图片网站需存储大量的图片【通常存储在磁盘】，而少部分热门的图片访问频繁。 3.2 方案为了加快网站获取热门图片的效率，可以将热门图片缓存在 Redis 中。 4 缓存数据字典示例代码 https://github.com/zhechu/spring-boot-redis-dict-demo/tree/master 4.1 场景数据字典一般初始化后，很少会改动。而查询又比较频繁，尤其是作为查询条件时。另外就是列表查询需展示数据字典的中文，而非编码。因此列表查询时需要查中文。 4.2 方案可以使用 Redis 缓存查询条件下拉框的数据（根据父编码缓存），以及单独缓存数据字典本身数据，用于列表查询是转换编码为中文，提高查询效率（不需使用数据库连表查询）。 TIPS：关于列表查询编码转中文的方案，可能读者会使用 Java 的枚举类型解决。但是，若数据字典有改动，则需编程解决，这是非常忌讳的做法。 使用 Hash 结构存储，优点如下： 节省内存，Redis 对 Hash 结构存储的数据有优化，且为官方推荐做法 方便操作，如：需缓存多条数据，只需执行 hmset 一条命令即可。若使用 String 类型，还得考虑批操作 核心代码 运行 DictCacheRepositoryTest 执行测试效果","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"Markdown使用手册","slug":"Markdown使用手册","date":"2019-04-14T03:59:08.000Z","updated":"2020-11-03T13:04:34.166Z","comments":false,"path":"2019/04/14/Markdown使用手册/","link":"","permalink":"https://zhechu.github.io/2019/04/14/Markdown使用手册/","excerpt":"","text":"官方文档 https://daringfireball.net/projects/markdown/syntax 1 标题123456# H1## H2### H3#### H4##### H5###### H6 2 文本强调语法123*斜体***加粗*****粗斜体*** 效果 斜体 加粗 粗斜体 3 列表3.1 无序列表语法12345678910111213* 无序列表1* 无序列表2* 无序列表3+ 无序列表1+ 无序列表2+ 无序列表3- 无序列表1- 无序列表2- 无序列表3 效果 无序列表1 无序列表2 无序列表3 无序列表1 无序列表2 无序列表3 无序列表1 无序列表2 无序列表3 3.2 有序列表语法123456781. 第一行2. 第二行3. 第三行1. 第一行- 第二行- 第三行 效果 第一行 第二行 第三行 第一行 第二行 第三行 3.3 组合列表语法12345678* 产品特点 1. 特点1 - 特点2 - 特点3* 产品功能 1. 功能1 - 功能2 - 功能3 效果 产品特点 特点1 特点2 特点3 产品功能 功能1 功能2 功能3 4 链接4.1 内嵌方式语法1[显示文字](http://www.w3cschool.cn/ \"标题文字\") 效果 显示文字 4.2 自动链接语法1&lt;http://www.w3cschool.cn&gt; 效果 http://www.w3cschool.cn TIPS：链接可显示，同时可以点击。 5 图片5.1 内嵌方式语法1![替代文字](http://statics.w3cschool.cn/images/w3c/index-logo.png \"标题文字\") 效果 6 代码和语法高亮6.1 行内高亮语法123普通文本`高亮文本`普通文本或普通文本`` `高亮文本包含反引号` ``普通文本 效果 普通文本高亮文本普通文本 或 普通文本`高亮文本包含反引号`普通文本 6.2 语法高亮6.2.1 HTML语法 效果1&lt;div&gt;Syntax Highlighting&lt;/div&gt; 6.2.2 CSS语法 效果1body&#123;font-size:12px&#125; 6.2.3 JavaScript语法 效果12var s = \"JavaScript syntax highlighting\";alert(s); 6.2.4 Python语法 效果12s = \"Python syntax highlighting\"print s 6.2.5 Java语法 效果123456789public class JavaTest &#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125; 6.2.6 Shell语法 效果1echo 'hello' 7 代码区块语法123456&gt; Email-style angle brackets&gt; are used for blockquotes.&gt; &gt; And, they can be nested.&gt; #### Headers in blockquotes&gt; * You can quote a list.&gt; * Etc. 效果 Email-style angle bracketsare used for blockquotes. And, they can be nested.list You can quote a list. Etc. 8 换行语法123在一行的结尾处加上2个或2个以上的空格，也可以使用&lt;/br&gt;标签第一行文字，第二行文字 效果 在一行的结尾处加上2个或2个以上的空格，也可以使用标签第一行文字，第二行文字 9 水平分割线语法123**** * *- - - 效果 10 转义符语法1\\*literal asterisks\\* 效果 *literal asterisks* 支持转义的字符123456789101112\\反斜杠`反引号*星号_下划线&#123;&#125;花括号[]方括号()括弧#井字号+加号-减号.英文句!感叹号 11 字符实体语法14 &amp;lt; 5 效果 4 &lt; 5 TIPS：有些特殊字符不支持转义，可以使用字符实体试试。 12 引用站内文章语法1&#123;% post_link 文章文件名（不要后缀） 文章标题（可选） %&#125; 13 Markdown编辑器（windows）Atom MarkdownPad","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://zhechu.github.io/tags/Markdown/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"学习网站","slug":"学习网站","date":"2019-04-14T03:58:57.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2019/04/14/学习网站/","link":"","permalink":"https://zhechu.github.io/2019/04/14/学习网站/","excerpt":"","text":"牛人博客老男孩 编程随想 无知者云 阿里中间件技术团队 贤心 周立 翟永超 刘勇 梁桂钊 一叶知秋 陈皓 陈鹏 悠悠然然 丛宇鸿 徐焱飞 泥瓦匠 大数据 一米阳光博客 微博架构师博客 微博架构师鸟窝的博客 DBA的罗浮宫的博客 青云QingCloud容器平台负责人王渊命的博客 唯品会资深Java技术专家江南白衣的博客 淘宝网“秒杀”活动技术支持团队领导人林昊的博客 MQ大牛朱忠华的博客 EasyTransaction作者的博客 阿里高级工程师徐靖峰的博客 aoho求索 其它网站清华大学出版社 炼数成金 英图论坛 龙果学院 产品100教学网 IT营 慕课网 自动化运维论坛 java 框架生成 jeecms java框架 孔夫子旧书网 计算机书籍控 技术狂人论坛 视频教程网 学途无忧 项目文档制作视频 专业逻辑图视频 mysql dba 视频教程 17 素材网 妙味课堂 瓢城Web俱乐部 智能社 慕课网 麦子学院 ps 联盟 WEB组件视频教程 掘金论坛 腾讯 imweb 论坛 腾讯 alloyteam 全端论坛 div.io 前端论坛 前端论坛 前端模板网站 前端特效教程 jeesz 快速开发平台 metronic 模板 浪曦网 中国科技论文在线 爱创课堂 前端资源库 百度 cdn 解答如何进入阿里 中国数据库技术大会 大数据网站 高维在线 不学网","categories":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}],"tags":[{"name":"资料库","slug":"资料库","permalink":"https://zhechu.github.io/tags/资料库/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"https://zhechu.github.io/categories/Others/"}]},{"title":"Redis的Key设计技巧","slug":"Redis的Key设计技巧","date":"2019-04-14T03:14:17.000Z","updated":"2020-11-03T13:04:34.186Z","comments":false,"path":"2019/04/14/Redis的Key设计技巧/","link":"","permalink":"https://zhechu.github.io/2019/04/14/Redis的Key设计技巧/","excerpt":"","text":"1 前言Redis 的 Key 分段设计官方推荐的是 : （冒号），但是存在很多误用情况，使用 - （中划线） 或 _ （下划线）。无规矩不成方圆，推荐统一用冒号（Redis 可视化工具 RedisDesktopManager 会按分段显示，降低排查问题的复杂度）。 2 Redis key 设计技巧 把表名转换为 key 前缀，如：tag: 第2段放置用于区分 key 的字段名–对应 Mysql 中的主键的列名，如：userid 第3段放置主键值，如：1,2,3,4…… 第4段，要存储的列名 3 示例：Mysql 用户表数据转为 Redis String 键值对存储用户表数据【user】 userid username password email 1 zhangsan 123456 shangsan@qq.com Redis String 键值对存储用户数据123&gt; set user:userid:1:username zhangsan&gt; set user:userid:1:password 123456&gt; set user:userid:1:email zhangsan@qq.com 查找 userid 为1的用户信息1&gt; keys user:userid:1:* 1&gt; get user:userid:1:username 1&gt; get user:userid:1:email TIPS：上述示例只为演示所用，若要存储关联程度比较高的数据，比如：登录用户信息（多个属性），建议用 Hash 结构存储。若需按多个维度查询，如：根据 userid 或 username 唯一查询，则可以结合 Hash 和 Strings 结构进行设计。","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"Redis常用命令","slug":"Redis常用命令","date":"2019-04-13T12:17:01.000Z","updated":"2020-11-03T13:04:34.182Z","comments":false,"path":"2019/04/13/Redis常用命令/","link":"","permalink":"https://zhechu.github.io/2019/04/13/Redis常用命令/","excerpt":"","text":"环境说明 环境 说明 CentOS7 操作系统 Redis-3.2.9 Key-Value 内存数据库 官方文档 https://redis.io/documentation 中文文档 http://www.redis.cn/documentation.html 历史版本下载【linux】 http://download.redis.io/releases/ 历史版本下载【windows，zip解压即可使用】 https://github.com/MicrosoftArchive/redis/releases 可视化客户端【windows】 https://redisdesktop.com/download 使用场景 排行榜应用，取 TOP N 操作 需要精确设定过期时间的应用 计数器应用 唯一操作，如：分布式锁、生成全局 ID 实时系统，反垃圾系统 Pub/Sub 构建实时消息系统 构建队列系统 构建反向索引 缓存 1 Keys1.1 del Key1&gt; del key1 key2 ... Keyn TIPS：返回真正删除的 key 的数量。 1.1.1 示例：删除 site【不存在的情况】1&gt; del site 1.1.2 示例：删除 site【存在的情况】12&gt; set site www.wise.com&gt; del site 1.1.3 示例：删除多个键，如：site1 site2 site31234&gt; set site1 www.wise1.com&gt; set site2 www.wise2.com&gt; set site3 www.wise3.com&gt; del site1 site2 site3 1.2 rename Key把key改名为newkey1&gt; rename key newkey TIPS：若 newkey 已存在，则 newkey 的原值被覆盖 示例：把 site 改名为 website12&gt; set site www.wise.com&gt; get site 12&gt; rename site website&gt; get website 1&gt; get site 1.3 renamenx Key类似 rename 命令，但只有目标 key 不存在时，才会修改成功。 1.4 move Key将 ke y移到目的 db【db 默认值是：0-15】 1&gt; move key db 1.5 keys pattern查询 key【pattern 表示正则表达式】1&gt; keys pattern 在 redis 里，允许模糊查询 key，有3个通配符 *, ? ,[] *: 通配任意多个字符 ?: 通配单个字符 []: 通配括号内的某1个字符 设置多个 Strings 键值对1&gt; mset one 1 two 2 three 3 four 4 1.5.1 查询以 o 字母开头的 key1&gt; keys o* 1.5.2 查询以 o 字母结尾的 key1&gt; keys *o 1.6 exists Key判断是否存在 key1&gt; exists key TIPS：返回 0 表示不存在，返回 1 表示存在。 1.7 ttl Key查询 key 的生命周期1&gt; ttl key TIPS：返回秒数，-1表示永不过期，-2表示 key 不存在。 1.8 expire Key设置 key 的生命周期，以秒为单位1&gt; expire site 整型值 1.9 sort key1返回或存储 key 的 list、set 或 sorted set 中的元素1&gt; sort key [by pattern] [limit offset count] [get pattern] [asc|desc] [alpha] destination 1.9.1 示例：按值本身大小排序【默认升序】按值升序排序12&gt; rpush numbers 9 5 1 3 2&gt; sort numbers 或1&gt; sort numbers asc 按值降序排序1&gt; sort numbers desc 1.9.2 示例：按分值排序12&gt; zadd scores 4 peter 5 jack 6 tom&gt; zrange scores 0 -1 1.9.3 示例：基于外部键的值进行排序123&gt; sadd names peter jack torm&gt; mset peter-score 4 jack-score 5 tom-score 3&gt; sort names by *-score 1.9.4 示例：指定返回结果的数量12&gt; rpush numbers 8 1 3 9 2 0 4 6 7 5&gt; sort numbers limit 0 3 1.9.5 示例：存储排序结果123&gt; rpush numbers 8 1 3 9 2 0 4 6 7 5&gt; sort numbers store sorted-numbers&gt; lrange sorted-numbers 0 -1 2 Strings使用场景： 位图记录信息 存储时效数据 2.1 set key添加键值对1&gt; set key value [ex 秒数] / [px 毫秒数] [nx] / [xx] nx: 表示 key 不存在时，则执行操作 xx: 表示 key 存在时，则执行操作 TIPS：若 ex，px 同时写，则以后面的有效期为准。 2.2 mset key一次性添加一个或多个键值对1&gt; mset key1 v1 key2 v2 .... 2.3 get key获取 key 的值1&gt; get key 2.4 mget key一次性获取一个或多个 key 的值1&gt; mget key1 key2 … 2.5 setrange key把字符串的 offset 偏移字节，改成 value1&gt; setrange key offset value 示例：将为 hell o改为 hexlo123&gt; set greet hello&gt; setrange greet 2 x&gt; get greet TIPS：注：若偏移量大于字符长度, 该字符自动补 0x00。 2.6 getrange key获取字符串中 [start, stop] 范围的值1&gt; getrange key start stop start&gt;=length, 则返回空字符串 stop&gt;=length，则截取至字符结尾 若 start 所处位置在 stop 右边, 返回空字符串 TIPS：对于字符串的下标，左数从0开始，右数从-1开始。 示例：获取 title 值的部分字符串12&gt; set title 'chinese'&gt; getrange title 0 3 1&gt; getrange title 1 -2 2.7 incr key指定的 key 的值加1，并返回加1后的值1&gt; incr key TIPS：不存在的 key 当成0，再 incr 操作，范围为64位有符号。 2.8 incrby key指定的 key 的值加 n，并返回加 n 后的值1&gt; incrby key n 2.9 decr key指定的 key 的值减1，并返回减1后的值1&gt; decr key 2.10 decrby key指定的 key 的值减n，并返回减 n 后的值1&gt; decrby key n 2.11 getbit key使用场景：使用位图法记录大量信息。 获取值的二进制表示，对应位上的值(从左，从0编号)1&gt; getbit key offset 示例：获取字符A的二进制表示【01000001】12&gt; set char A&gt; getbit char 1 2.12 setbit key设置 offset 对应二进制位上的值1&gt; setbit key offset value 若 offset 过大，则会在中间填充0 offset 最大2^32-1，可推出最大的的字符串为512M TIPS：返回值为该位上的旧值。 示例：将Q【01010001】转为q【01110001】1234&gt; set upper Q&gt; get upper&gt; setbit upper 2 1&gt; get upper 2.13 bitop operation对 key1,key2..keyN 作 operation，并将结果保存到 destkey 上，operation 可以是 AND 、 OR 、 NOT 、 XOR1&gt; bitop operation destkey key1 [key2 ...] TIPS: 对于 NOT 操作, key 不能多个。 示例：将Q【01010001】转为q【01110001】1234567&gt; setbit lower 7 0&gt; setbit lower 2 1&gt; get lower&gt; set char Q&gt; get char&gt; bitop or char char lower&gt; get char 2.14 bitcount key统计字符串被设置为1的bit数1&gt; bitcount key [start end] TIPS：一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。 示例：统计 mykey 被设置为1的 bit 数123&gt; set mykey \"foobar\"&gt; get mykey&gt; bitcount mykey 1&gt; bitcount mykey 0 0 1&gt; bitcount mykey 1 1 3 运维3.1 切换数据库【默认0-15】1&gt; select n 3.2 显示服务器时间 , 时间戳(秒), 微秒数1&gt; time 3.3 显示当前数据库的key的数量1&gt; dbsize 3.4 后台进程重写日志【AOF】1&gt; bgrewriteaof 3.5 后台保存RDB快照【后台运行】1&gt; bgsave 3.6 保存RDB快照1&gt; bgsave 3.7 显示上次保存时间【恢复数据时使用，可以算出丢失多少数据】1&gt; lastsave 3.8 将当前实例设为master的slave【动态伸缩】1&gt; slaveof master-host port 3.9 清空所有库的所有键1&gt; flushall 3.10 清空当前库所有键1&gt; flushdb 3.11 关闭Redis服务【等价于systemctl stop redis】1&gt; shutdown [save/nosave] TIPS: 若不小心运行了 flushall, 立即 shutdown nosave ,关闭服务，以免AOF日志重写丢失数据。然后手工编辑 AOF 文件, 去掉文件中的 “flushall” 相关行, 最后开启服务,则恢复数据。若 flushall 之后，恰好 AOF 日志重写【bgrewriteaof】了，那么 AOF 文件就清空了，数据丢失。 3.12 显示慢查询1&gt; slowlog get TIPS：由 redis.conf 文件的 slowlog-log-slower-than 10000 指定【单位是微秒】。由 slowlog-max-len 128 指定最多存储慢查询条数。 查看 Redis 服务信息1&gt; info 重要参数 参数 说明 used_memory:859192 数据结构的空间 used_memory_rss:7634944 实占空间 mem_fragmentation_ratio:8.89 前 2 者的比例，1.N 为佳，若值过大,说明内存的碎片化严重，可以导出再导入一次 role:slave 角色【 master 或 slave 】 master_host:192.168.1.128 主节点 IP master_port:6379 主节点端口 master_link_status:up 主节点状态【 up 或 down 】 rdb_changes_since_last_save:0 上次 RDB 保存以后改变的 key 次数 rdb_last_save_time:1375224063 上次持久化时间 latest_fork_usec:936 上次导出 RDB 快照，持久化花费微秒","categories":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}],"tags":[{"name":"缓存","slug":"缓存","permalink":"https://zhechu.github.io/tags/缓存/"}],"keywords":[{"name":"Redis","slug":"Redis","permalink":"https://zhechu.github.io/categories/Redis/"}]},{"title":"Docker常用命令","slug":"Docker常用命令","date":"2019-04-12T13:04:57.000Z","updated":"2020-11-03T13:04:34.075Z","comments":false,"path":"2019/04/12/Docker常用命令/","link":"","permalink":"https://zhechu.github.io/2019/04/12/Docker常用命令/","excerpt":"","text":"环境说明 环境 说明 CentOS7 操作系统 Docker-1.12.6 应用容器引擎 官方文档 https://docs.docker.com/v1.12/engine/getstarted/ 1 查看帮助简便帮助1$ docker --help 详细帮助1$ man docker 2 登录仓库docker 登录镜像仓库语法1$ docker login [-e|-email=\"\"] [-p|--password=\"\"] [-u|--username=\"\"] [SERVER] 查看登录参数帮助12$ docker login –help$ man docker login 示例：登录私有镜像仓库1$ docker login 192.168.163.41:5000 -u user -p password 3 登出仓库docker 登出镜像仓库语法1$ docker logout [SERVER] 查看登录参数帮助12$ docker logout –help$ man docker logout 示例：登出联奕镜像仓库1$ docker logout 192.168.163.41:5000 4 镜像官方镜像库镜像搜索 https://hub.docker.com/explore/ 4.1 检索检索镜像语法1$ docker search [OPTIONS] TERM 查看帮助12$ docker search –help$ man docker search 应用场景 检索官方镜像库相关镜像，选择适合的镜像下载 检索私有镜像库相关镜像，下载适合的镜像或删除过期镜像 示例：检索官方镜像仓库 nginx 镜像1$ docker search nginx 私有镜像库检索可以使用 registry api https://docs.docker.com/registry/spec/api/#overview 4.2 历史查看镜像历史信息语法1$ docker history [OPTIONS] IMAGE 查看帮助12$ docker history –help$ man docker history 应用场景 查看镜像构建过程，排除故障或优化镜像 示例：查看 nginx 镜像历史信息，可以简单查看镜像构建过程1$ docker history nginx 4.3 拉取拉取镜像语法1$ docker pull [OPTIONS] NAME[:TAG|@DIGEST] 查看帮助12$ docker pull –help$ man docker pull 应用场景 拉取官方、远程或私有镜像库镜像 4.3.1 示例：拉取官方 nginx 镜像1$ docker pull nginx 4.3.2 示例：拉取私有仓库的 nginx 镜像1.配置安全策略1234567$ vi /etc/docker/daemon.json&#123; \"insecure-registries\": [ \"192.168.163.41:5000\" ]&#125;$ systemctl restart docker 2.登录镜像仓库1$ docker login 192.168.163.41:5000 -u user -p password 3.拉取 library/nginx:latest 镜像【默认 tag 是 latest】1$ docker pull 192.168.163.41:5000/library/nginx 4.4 推送推送镜像语法1$ docker push [OPTIONS] NAME[:TAG] 查看帮助12$ docker push –help$ man docker push 应用场景 分享镜像或镜像发布或迁移 示例：将 nginx 推送到私有镜像仓库1.查看本地nginx镜像1$ docker images | grep nginx 2.打目的 tag1$ docker tag nginx:latest 192.168.163.41:5000/library/nginx-test:v1 3.配置安全策略1234567$ vi /etc/docker/daemon.json&#123; \"insecure-registries\": [ \"192.168.163.41:5000\" ]&#125;$ systemctl restart docker 4.登录镜像仓库1$ docker login 192.168.163.41:5000 -u user -p password 5.推送到联奕镜像仓库1$ docker push 192.168.163.41:5000/library/nginx-test:v1 4.5 查看查看镜像语法1$ docker images [OPTIONS] [REPOSITORY[:TAG]] 示例：列出所有镜像1$ docker images 应用场景 查看本地镜像，可删除过期镜像 查看镜像详情，排除故障或修改镜像挂载目录 示例：列出所有 nginx 镜像1$ docker images | grep nginx 查看镜像详细信息语法1$ docker inspect [OPTIONS] CONTAINER|IMAGE|TASK [CONTAINER|IMAGE|TASK...] 查看帮助12$ docker inspect –help$ man docker inspect 示例：查看 nginx 镜像详细信息1$ docker inspect nginx 4.6 构建Docker 镜像构建有三种方式： 基于已有镜像的容器创建 基于本地模板导入 基于 Dockerfile 创建 TIPS：由于前两种较少使用，此文档只展示 Dockerfile 方式构建镜像。 4.6.1 Dockerfile官方文档【注意版本】 https://docs.docker.com/engine/reference/builder/#dockerfile-examples 4.6.1.1 构建 RabbitMQ 镜像问题描述：官方 RabbitMQ 镜像启动的容器默认用户为 guest/guest，不支持远程连接。只能手工添加用户远程连接权限。而容器重启后，配置的信息又会丢失。 解决方案：自写启动脚本，重新构建镜像，在 RabbitMQ 重启后，添加用户及其相应的权限。可通过环境变量传递用户名和密码。 官方镜像地址https://hub.docker.com/_/rabbitmq/ 进入工作目录（按个人习惯）1$ mkdir -p /usr/local/src/rabbitmq &amp;&amp; cd /usr/local/src/rabbitmq 新建 run.sh，用作 Dockerfile 启动命令1234567891011121314151617$ vi run.sh#!/bin/bashdocker-entrypoint.sh rabbitmq-serversleep 20suser=guestpass=guestif [ $RABBITMQ_DEFAULT_USER ];then user=\"$RABBITMQ_DEFAULT_USER\"fiif [ $RABBITMQ_DEFAULT_PASS ];then pass=\"$RABBITMQ_DEFAULT_PASS\"firabbitmqctl add_user \"$user\" \"$pass\"rabbitmqctl set_permissions -p / \"$user\" \".*\" \".*\" \".*\"rabbitmqctl set_user_tags \"$user\" administrator 新建 Dockerfile1234567$ vi DockerfileFROM 192.168.163.41:5000/rabbitmq:latestMAINTAINER lingyuwang &lt;a href=\"mailto:lingyuwang@wise.com\"&gt;lingyuwang@wise.com&lt;/a&gt;ADD run.sh /root/run.shRUN chmod 755 /root/run.shENTRYPOINT [\"/root/run.sh\"]CMD [\"\"] 构建 docker 镜像1$ docker build -t rabbitmq . 运行容器，RABBITMQ_DEFAULT_USER 是用户名，RABBITMQ_DEFAULT_PASS 是密码，若没有传环境变量，则会用默认用户和账号 guest/guest，可远程访问，支持 web 控制台，如：访问 http://192.168.163.41:15672 进行管理1$ docker run -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 -p 5672:5672 -p 15672:15672 rabbitmq 4.6.1.2 构建 UI 镜像静态页面打包1$ tar -zcvf wise-manage.tar.gz ./wise-manage 新建Dockerfile12345678910111213141516$ vi Dockerfile#基础镜像FROM 192.168.163.41:5000/nginx:latest#维护人信息MAINTAINER lingyuwang lingyuwang@wise.com#将静态页面复制到nginx的html目录下ADD wise-manage.tar.gz /usr/share/nginx/htmlCOPY nginx.conf /etc/nginx/#暴露端口EXPOSE 80#连接时执行的命令CMD [\"nginx\", \"-g\", \"daemon off; load_module /etc/nginx/modules/ngx_http_perl_module.so;\"] 构建 docker 镜像1$ docker build -t wise-ui . 运行容器1$ docker run -p 80:80 wise-ui 4.6.1.3 构建后端镜像服务构建1$ mvn clean package -U 新建 Dockerfile12345678910111213141516171819$ vi Dockerfile#基础镜像FROM 192.168.163.41:5000/library/centos-jdk:1.8.25#作者MAINTAINER lingyuwang lingyuwang@wise.com#添加文件ADD student/student-server/target/student-server.jar /usr/localRUN chmod u+x /usr/local/student-server.jar#开放端口EXPOSE 9093#启动时执行的命令CMD [\"/bin/bash\"]#启动时执行的命令ENTRYPOINT [\"java\",\"-jar\",\"/usr/local/student-server.jar\"] 构建 docker 镜像1$ docker build -t student-server . 运行容器1$ docker run -p 19093:9093 student-server 4.7 存出存出镜像语法1$ docker save [OPTIONS] IMAGE [IMAGE...] 查看帮助12$ docker save –help$ man docker save 应用场景 在网络有限的情况下，分享镜像或镜像发布或迁移 示例：存出 nginx 镜像12$ docker save -o nginx_latest.tar nginx:latest$ ls 4.8 存入存入镜像语法1$ docker load [OPTIONS] 查看帮助12$ docker load –help$ man docker load 应用场景 在网络有限的情况下，根据存出镜像的压缩包存入镜像 示例：存入 nginx 镜像1$ docker load -i nginx_latest.tar 1$ docker images 4.9 删除删除镜像语法1$ docker rmi [OPTIONS] IMAGE [IMAGE...] 查看帮助12$ docker rmi –help$ man docker rmi 4.9.1 示例：根据镜像名删除 nginx 镜像1$ docker rmi nginx 4.9.2 示例：根据镜像 id 删除 logstash 镜像1.查询 logstash 镜像信息1$ docker images | grep logstash 2.删除 logstash 镜像1$ docker rmi d4ba882d4867 4.9.3 示例：强制删除虚悬镜像1$ docker rmi -f $(docker images | grep \"&lt;none&gt;\" | awk '&#123;print $3&#125;') 4.9.4 示例：强制删除所有镜像1$ docker rmi -f $(docker images | awk '&#123;print $3&#125;') 5 容器5.1 新建新建容器语法1$ docker create [OPTIONS] IMAGE [COMMAND] [ARG...] TIPS：若 image 包含了 CMD 指令，那么在启动 container 时，不需指定 COMMAND，否则会使用指定的COMMAND 覆盖 image 中的 CMD。默认的 container 是在前台运行，会绑定 COMMAND 进程的 STDIN，STDOUT，STDERR 到 console 上。 查看帮助12$ docker create –help$ man docker create 应用场景 新建容器，待启动 例如：新建 nginx 容器1$ docker create --name nginx -it nginx:latest 5.2 启动启动容器语法1$ docker start [OPTIONS] CONTAINER [CONTAINER...] 查看帮助12$ docker start –help$ man docker start 应用场景 启动状态为 Exite d的容器 示例：启动 nginx 容器1$ docker ps -a 12$ docker start nginx$ docker ps 5.3 新建&amp;启动新建&amp;启动容器语法1$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 查看帮助12$ docker run –help$ man docker run 应用场景 一步新建和启动容器 示例：新建和启动 nginx 容器，浏览器访问 http://127.0.0.1 可看效果1$ docker run -it --name nginx -p 80:80 nginx:latest 示例：新建和启动 ngin x容器【守护进程启动】1$ docker run -dit --name nginx -p 80:80 nginx:latest 查看 nginx 容器日志1$ docker logs nginx 5.4 查看详情查看容器详情语法1$ docker inspect [OPTIONS] CONTAINER|IMAGE|TASK [CONTAINER|IMAGE|TASK...] 查看帮助12$ docker inspect –help$ man docker inspect 应用场景 查看容器具体配置 示例：查看 nginx 容器详细信息1$ docker inspect nginx 5.5 查看进程查看容器运行进程信息语法1$ docker top CONTAINER [ps OPTIONS] 查看帮助12$ docker top –help$ man docker top 应用场景 查看容器运行进程信息，排除故障 示例：查看 nginx 容器运行进程信息1$ docker top nginx 5.6 查看日志查看容器运行日志语法1$ docker logs [OPTIONS] CONTAINER 查看帮助12$ docker logs –help$ man docker logs 应用场景 查看容器运行日志信息，排除故障 5.6.1 示例：查看 nginx 容器运行日志1$ docker logs nginx 5.6.2 示例：实时查看 nginx 容器运行日志，并显示时间戳1$ docker logs -tf nginx 5.7 进入容器进入容器语法1$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 查看帮助12$ docker exec –help$ man docker exec 应用场景 进入容器，调试或排除故障 进入容器，执行命令 5.7.1 示例：进入 nginx 容器1$ docker exec -it nginx /bin/bash 5.7.2 示例：进入 registry 容器并执行垃圾收集命令1$ docker exec registry registry garbage-collect /etc/docker/registry/config.yml 5.8 终止容器终止容器语法1$ docker stop [OPTIONS] CONTAINER [CONTAINER...] 查看帮助12$ docker stop –help$ man docker stop 应用场景 终止容器，待启动 5.8.1 示例：终止 nginx 容器1$ docker stop nginx 5.8.2 示例：终止所有容器1$ docker ps -a -q | xargs docker stop 5.9 删除容器删除容器语法1$ docker rm [OPTIONS] CONTAINER [CONTAINER...] 查看帮助12$ docker rm –help$ man docker rm 应用场景 删除无用容器，释放磁盘空间 示例：删除 nginx 容器1$ docker rm nginx 5.9.1 示例：强制删除正在运行的 nginx 容器1$ docker rm -f nginx 5.9.2 示例：删除停止运行的所有容器1$ docker container prune TIPS：Docker 1.13 版本以后才可使用。 5.9.3 示例：强制删除所有容器1$ docker ps -a -q | xargs docker rm -f 5.10 导出导出容器语法1$ docker export [OPTIONS] CONTAINER 查看帮助12$ docker export –help$ man docker export 应用场景 导出容器，跟存出镜像类似。在网络有限的情况下，分享容器或容器发布或迁移 示例：导出 nginx 容器12$ docker export -o nginx_latest.tar nginx$ ls 5.11 导入导入容器语法1$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] 查看帮助12$ docker import –help$ man docker import 应用场景 容器迁移 示例：导入 nginx 容器【运行容器需加上命令，原因未知】123$ docker import nginx_latest.tar nginx:latest$ docker images$ docker run -dit --name nginx -p 80:80 nginx:latest /bin/bash 5.12 挂载目录示例：私有仓库数据目录挂载【/opt/data/registry为主机目录】1$ docker run --name registry -d -p 5000:5000 -v /opt/data/registry:/var/lib/registry registry:2.4.1","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"Java指令重排","slug":"Java指令重排","date":"2019-04-11T14:09:07.000Z","updated":"2020-11-03T13:04:34.158Z","comments":false,"path":"2019/04/11/Java指令重排/","link":"","permalink":"https://zhechu.github.io/2019/04/11/Java指令重排/","excerpt":"","text":"分类 编译器重排序 处理器重排序 1 happens-before规则 程序顺序规则：单个线程中的每个操作，总是前一个操作先行发生于该线程中的任意后续操作 监视器规则：对同一个锁的解锁，总是先行发生于随后对这个锁的加锁 volatile 变量规则：对一个 volatile 域的写，先行发生于任意后续对这个 volatile 域的读 传递性 Start 规则：如果线程A执行操 ThreadB.start() （启动线程B），那么A线程的 ThreadB.start() 操作先行发生于线程B中的任意操作 Join 规则：如果线程A执行操作 ThreadB.join() 并成功返回，那么线程B中的任意操作先行发生于线程A调用 ThreadB.join() 后的任意操作 2 final2.1 规则规则 写 final 域的重排序规则：禁止把 final 域的写重排序到构造方法之外 读 final 域的重排序规则：在一个线程中，初次读对象引用和初次读该对象所包含的 final 域，Java 内存模型禁止处理器重排序这两个操作 final 域为抽象类型：在构造方法内对一个 final 引用的对象的成员域的写入，与随后在构造方法外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序 2.2 实例变量初始化2.2.1 示例：直接初始化1234567891011public class FinalTest1 &#123; private final int c = 1; public FinalTest1() &#123;&#125; public static void main(String[] args) &#123; FinalTest1 ft = new FinalTest1(); System.out.println(ft.c); &#125;&#125; 2.2.2 示例：代码块初始化123456789101112131415161718public class FinalTest2 &#123; private final int c; public FinalTest2() &#123; System.out.println(\"构造方法后于代码块执行...\"); &#125; &#123; System.out.println(\"代码块先于构造方法执行...\"); c = 1; &#125; public static void main(String[] args) &#123; FinalTest2 ft = new FinalTest2(); System.out.println(ft.c); &#125;&#125; 2.2.3 示例：构造函数初始化12345678910111213public class FinalTest3 &#123; private final int c; public FinalTest3() &#123; c = 1; &#125; public static void main(String[] args) &#123; FinalTest3 ft = new FinalTest3(); System.out.println(ft.c); &#125;&#125; 2.3 静态变量初始化2.3.1 示例：直接初始化123456789public class StaticFinalTest1 &#123; private static final int c = 1; public static void main(String[] args) &#123; System.out.println(StaticFinalTest1.c); &#125;&#125; 2.3.2 示例：静态代码块初始化12345678910111213public class StaticFinalTest2 &#123; private static final int c; static &#123; c = 1; &#125; public static void main(String[] args) &#123; System.out.println(StaticFinalTest2.c); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java线程池","slug":"Java线程池","date":"2019-04-11T13:58:10.000Z","updated":"2020-11-15T08:36:49.364Z","comments":false,"path":"2019/04/11/Java线程池/","link":"","permalink":"https://zhechu.github.io/2019/04/11/Java线程池/","excerpt":"","text":"1 简介线程池优势 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控 核心方法 prestartAllCoreThreads：预初始化核心线程（线程预热） allowCoreThreadTimeOut：是否允许核心线程超时回收（适合非核心业务） 2 示例示例：实现累加求和12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ThreadPoolExecutor threadPool = new ThreadPoolExecutor( 10, // 线程池的基本大小 50, // 线程池最大大小，线程池允许创建的最大线程数 10, // 线程活动保持时间的时间值 TimeUnit.DAYS, // 线程活动保持时间的单位 new ArrayBlockingQueue&lt;&gt;(10), // 一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序 new ThreadPoolExecutor.CallerRunsPolicy() // 执行被阻塞时，使用调用者所在线程来运行任务 ); AtomicInteger count = new AtomicInteger(); for (int i = 0; i &lt; 1000; i ++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); count.getAndIncrement(); &#125; &#125;); &#125; threadPool.shutdown(); // threadPool.shutdownNow(); // 立刻终止，即使队列还有任务 while (Thread.activeCount() &gt; 1) &#123; &#125; System.out.println(count.get()); &#125;&#125; 执行情况 TIPS：由于线程不够用，所以主线程（main）也被利用起来。 3 自动关闭3.1 核心线程为0时核心线程池为0时，超时后线程池会自动关闭1234567891011121314151617181920212223242526272829import lombok.extern.slf4j.Slf4j;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;@Slf4jpublic class ThreadPoolTest &#123; public static void main(String[] args) &#123; zeroCorePoolSize(); &#125; /** * 核心线程池为0时，5秒后线程池自动关闭 */ private static void zeroCorePoolSize() &#123; // 重点关注 corePoolSize 和 keepAliveTime，其他参数不重要 ThreadPoolExecutor executor = new ThreadPoolExecutor(0, 5, 5L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(15)); for (int i = 0; i &lt; 20; i++) &#123; executor.execute(() -&gt; &#123; // 简单地打印当前线程名称 log.info(Thread.currentThread().getName()); &#125;); &#125; &#125;&#125; 验证：控制台等待5秒后打印如下语句，并且进程退出1Process finished with exit code 0 3.2 核心线程大于0时核心线程池大于0时，线程池超时则自动关闭123456789101112131415161718192021222324252627282930import lombok.extern.slf4j.Slf4j;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;@Slf4jpublic class ThreadPoolTest &#123; public static void main(String[] args) &#123; notZeroCorePoolSizeAutoShutdown(); &#125; /** * 核心线程池大于0时，线程池超时则自动关闭 */ private static void notZeroCorePoolSizeAutoShutdown() &#123; // 重点关注 corePoolSize 和 keepAliveTime，其他参数不重要 ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 5, 5L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(15)); executor.allowCoreThreadTimeOut(true); for (int i = 0; i &lt; 20; i++) &#123; executor.execute(() -&gt; &#123; // 简单地打印当前线程名称 log.info(Thread.currentThread().getName()); &#125;); &#125; &#125;&#125; 验证：控制台等待5秒后打印如下语句，并且进程退出1Process finished with exit code 0 4 手动关闭描述：JVM 进程启动时，注册 ShutdownHook，待 JVM 进程正常退出前优雅释放资源 原理：手动关闭目的是尽快释放资源 12345678// 注册JVM钩子函数Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable&lt;Void&gt;() &#123; @Override public Void call() throws Exception &#123; controller.shutdown(); return null; &#125;&#125;)); TIPS：来自 RocketMQ 源码 org.apache.rocketmq.namesrv.NamesrvStartup 类","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"},{"name":"池化技术","slug":"池化技术","permalink":"https://zhechu.github.io/tags/池化技术/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java并发容器","slug":"Java并发容器","date":"2019-04-10T15:30:00.000Z","updated":"2020-11-03T13:04:34.155Z","comments":false,"path":"2019/04/10/Java并发容器/","link":"","permalink":"https://zhechu.github.io/2019/04/10/Java并发容器/","excerpt":"","text":"1 CopyOnWriteArrayList描述：写时复制线程安全集合。读不加锁，写复制副本并加锁。弱一致性。 使用场景：读多写少。 2 Vector描述：线程安全列表集合。 使用场景：数据量少，强一致性。 3 ConcurrentHashMap描述：线程安全的 Map 集合。 使用场景：百万级以下数据量，且弱一致性。 4 HashTable描述：键值对安全集合。 使用场景：少量数据，强一致性。 5 ConcurrentLinkedQueue描述：基于链表的无界非阻塞队列。 示例：生产者与消费者（当队列没有内容时，消费者可能拿到 null）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.ConcurrentLinkedQueue;public class MainThread &#123; public static void main(String args[]) &#123; ConcurrentLinkedQueue&lt;String&gt; queue = new ConcurrentLinkedQueue&lt;String&gt;(); for (int i = 0; i &lt; 2; i++) &#123; Productor task = new Productor(queue); Thread t = new Thread(task, \"生产者线程\" + i); t.start(); &#125; for (int i = 0; i &lt; 2; i++) &#123; Consumer task = new Consumer(queue); Thread t = new Thread(task, \"消费者线程\" + i); t.start(); &#125; &#125;&#125;class Consumer implements Runnable &#123; private ConcurrentLinkedQueue&lt;String&gt; queue; public Consumer(ConcurrentLinkedQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"消费者--&gt; \" + queue.poll()); &#125; &#125;&#125;class Productor implements Runnable &#123; private ConcurrentLinkedQueue&lt;String&gt; queue; public Productor(ConcurrentLinkedQueue&lt;String&gt; queue) &#123; this.queue = queue; &#125; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String content = String.valueOf(System.nanoTime()); System.out.println(\"生产者==&gt; \" + content); queue.add(content); &#125; &#125;&#125; 6 ArrayBlockingQueue描述：由数组结构组成的有界阻塞队列。 使用场景：队列较大，数据量大的场景。 示例：生产者与消费者 商品类123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;public class Tmall &#123; public final int MAX_COUNT = 10; private BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(MAX_COUNT); public void push() &#123; try &#123; int product = (int) (Math.random() * 1000); System.out.println(Thread.currentThread().getName() + \"生产：\" + product); queue.put(product); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void take() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \"消费：\" + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void size() &#123; while (true) &#123; System.out.println(\"当前队列的长度为：\" + queue.size()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 生产者类123456789101112131415161718192021public class PushTarget implements Runnable &#123; private Tmall tmall; public PushTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.push(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类123456789101112131415161718192021public class TakeTarget implements Runnable &#123; private Tmall tmall; public TakeTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.take(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; Tmall tmall = new Tmall(); PushTarget p = new PushTarget(tmall); TakeTarget t = new TakeTarget(tmall); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; tmall.size(); &#125; &#125;).start(); &#125;&#125; 7 LinkedBlockingQueue描述：由链表结构组成的有界阻塞队列。 使用场景：队列较小，数据量小的场景（因为内存占用较大，相当于以空间换时间）。 示例：生产者与消费者 商品类123456789101112131415161718192021222324252627282930313233343536373839import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;public class Tmall &#123; public final int MAX_COUNT = 10; private BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(MAX_COUNT); public void push() &#123; try &#123; int product = (int) (Math.random() * 1000); System.out.println(Thread.currentThread().getName() + \"生产：\" + product); queue.put(product); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void take() &#123; try &#123; System.out.println(Thread.currentThread().getName() + \"消费：\" + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void size() &#123; while (true) &#123; System.out.println(\"当前队列的长队为：\" + queue.size()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 生产者类123456789101112131415161718192021public class PushTarget implements Runnable &#123; private Tmall tmall; public PushTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.push(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类123456789101112131415161718192021public class TakeTarget implements Runnable &#123; private Tmall tmall; public TakeTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.take(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; Tmall tmall = new Tmall(); PushTarget p = new PushTarget(tmall); TakeTarget t = new TakeTarget(tmall); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; tmall.size(); &#125; &#125;).start(); &#125;&#125; 8 ArrayBlockingQueue VS LinkedBlockingQueue 队列中锁的实现不同 ArrayBlockingQueue 实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁； LinkedBlockingQueue 实现的队列中的锁是分离的，即生产用的是 putLock，消费是 takeLock。 在生产或消费时操作不同 ArrayBlockingQueue 实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的； LinkedBlockingQueue 实现的队列中在生产和消费的时候，需要把枚举对象转换为 Node&lt;E&gt; 进行插入或移除，会影响性能。 队列大小初始化方式不同 ArrayBlockingQueue 实现的队列中必须指定队列的大小； LinkedBlockingQueue 实现的队列中可以不指定队列的大小，但是默认是 Integer.MAX_VALUE。 关键 在使用 LinkedBlockingQueue 时，若用默认大小且当生产速度大于消费速度时候，有可能会内存溢出 在使用 ArrayBlockingQueue 和 LinkedBlockingQueue 分别对 1000000 个简单字符做入队操作时，LinkedBlockingQueue的消耗是ArrayBlockingQueue消耗的10倍左右。 9 PriorityBlockingQueue描述：无界的优先级阻塞队列。 10 DelayQueue描述：无界的延迟阻塞队列。 使用场景：生产者消费者模式中，实现延迟消费（需要等到某个时间后才能消费）。 11 SynchronousQueue描述：同步阻塞队列。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"},{"name":"集合","slug":"集合","permalink":"https://zhechu.github.io/tags/集合/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java线程异常处理","slug":"Java线程异常处理","date":"2019-04-10T14:57:58.000Z","updated":"2020-11-03T13:04:34.160Z","comments":false,"path":"2019/04/10/Java线程异常处理/","link":"","permalink":"https://zhechu.github.io/2019/04/10/Java线程异常处理/","excerpt":"","text":"1 线程内捕捉异常示例：线程内捕捉异常12345678910111213141516171819202122232425public class ThreadExceptionTest1 &#123; /** * 线程内捕捉异常 * @param args */ public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread t = Thread.currentThread(); System.out.println(\"运行线程：\" + t); System.out.println(\"异常处理器：\" + t.getUncaughtExceptionHandler()); throw new RuntimeException(\"抛出运行时异常\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125; 2 定义异常处理器示例：定义异常处理器捕捉异常1234567891011121314151617181920212223242526272829303132333435import java.lang.Thread.UncaughtExceptionHandler;public class ThreadExceptionTest2 &#123; /** * 定义异常处理器捕捉异常 * @param args */ public static void main(String[] args) &#123; Thread t = new Thread(new Runnable() &#123; @Override public void run() &#123; Thread t = Thread.currentThread(); System.out.println(\"运行线程：\" + t); System.out.println(\"异常处理器：\" + t.getUncaughtExceptionHandler()); throw new RuntimeException(\"抛出运行时异常\"); &#125; &#125;); // 设置异常处理器 t.setUncaughtExceptionHandler(new UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"抛出异常的线程：\" + t); System.out.println(\"捕获到异常：\" + e); &#125; &#125;); t.start(); &#125;&#125; 3 线程池异常处理器示例：线程池自定义异常处理器12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.lang.Thread.UncaughtExceptionHandler;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadFactory;public class ThreadExceptionTest3 &#123; /** * 线程池自定义线程工厂 * @param args */ public static void main(String[] args) &#123; ExecutorService executor = Executors.newCachedThreadPool(new ThreadFactory() &#123; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(r); t.setUncaughtExceptionHandler(new UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"抛出异常的线程：\" + t); System.out.println(\"捕获到异常：\" + e); &#125; &#125;); return t; &#125; &#125;); executor.execute(new Runnable() &#123; @Override public void run() &#123; Thread t = Thread.currentThread(); System.out.println(\"运行线程：\" + t); System.out.println(\"异常处理器：\" + t.getUncaughtExceptionHandler()); throw new RuntimeException(\"抛出运行时异常\"); &#125; &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"},{"name":"异常处理","slug":"异常处理","permalink":"https://zhechu.github.io/tags/异常处理/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java线程通讯","slug":"Java线程通讯","date":"2019-04-10T13:12:43.000Z","updated":"2020-11-03T13:04:34.161Z","comments":false,"path":"2019/04/10/Java线程通讯/","link":"","permalink":"https://zhechu.github.io/2019/04/10/Java线程通讯/","excerpt":"","text":"1 wait&amp;notify1.1 交替执行示例：线程1执行后，线程2才执行12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class WaitNotifyDemo &#123; /** * volatitle 修饰的变量会在线程间共享 */ private volatile int signal; public void set (int value) &#123; this.signal = value; &#125; public int get () &#123; return signal; &#125; public static void main(String[] args) &#123; WaitNotifyDemo d = new WaitNotifyDemo(); // 线程1 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"修改状态的线程执行...\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; d.set(1); System.out.println(\"状态值修改成功。。。\"); // 在调用wait()或者notify()之前，必须使用synchronized语义绑定住被wait/notify的对象 synchronized (d) &#123; d.notify(); &#125; &#125; &#125;).start(); // 线程2 new Thread(new Runnable() &#123; @Override public void run() &#123; // 等待signal为1开始执行，否则不能执行 while(d.get() != 1) &#123; try &#123; // 在调用wait()或者notify()之前，必须使用synchronized语义绑定住被wait/notify的对象 synchronized (d) &#123; d.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 当信号为1 的时候，执行代码 System.out.println(\"模拟代码的执行...\"); &#125; &#125;).start(); &#125;&#125; 1.2 生产者与消费者示例：生产者与消费者 商品类1234567891011121314151617181920212223242526272829303132333435public class Tmall &#123; private int count; public final int MAX_COUNT = 10; public synchronized void push () &#123; while (count &gt;= MAX_COUNT) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 库存数量达到上限，生产者停止生产。\"); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count ++; System.out.println(Thread.currentThread().getName() + \" 生产者生产，当前库存为：\" + count); notifyAll(); &#125; public synchronized void take () &#123; while (count &lt;= 0) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 库存数量为零，消费者等待。\"); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count --; System.out.println(Thread.currentThread().getName() + \" 消费者消费，当前库存为：\" + count); notifyAll(); &#125;&#125; 生产者类123456789101112131415161718192021public class PushTarget implements Runnable &#123; private Tmall tmall; public PushTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.push(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类123456789101112131415161718192021public class TakeTarget implements Runnable &#123; private Tmall tmall; public TakeTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.take(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; Tmall tmall = new Tmall(); PushTarget p = new PushTarget(tmall); TakeTarget t = new TakeTarget(tmall); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125;&#125; 2 condition2.1 交替执行示例：三个线程交替执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Demo &#123; private int signal; Lock lock = new ReentrantLock(); Condition a = lock.newCondition(); Condition b = lock.newCondition(); Condition c = lock.newCondition(); public void a() &#123; lock.lock(); while (signal != 0) &#123; try &#123; a.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"a\"); signal ++; b.signal(); lock.unlock(); &#125; public void b() &#123; lock.lock(); while (signal != 1) &#123; try &#123; b.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"b\"); signal ++; c.signal(); lock.unlock(); &#125; public void c () &#123; lock.lock(); while (signal != 2) &#123; try &#123; c.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"c\"); signal = 0; a.signal(); lock.unlock(); &#125; public static void main(String[] args) &#123; Demo d = new Demo(); A a = new A(d); B b = new B(d); C c = new C(d); new Thread(a).start(); new Thread(b).start(); new Thread(c).start(); &#125;&#125;class A implements Runnable &#123; private Demo demo; public A(Demo demo) &#123; this.demo = demo; &#125; @Override public void run() &#123; while (true) &#123; demo.a(); &#125; &#125;&#125;class B implements Runnable &#123; private Demo demo; public B(Demo demo) &#123; this.demo = demo; &#125; @Override public void run() &#123; while (true) &#123; demo.b(); &#125; &#125;&#125;class C implements Runnable &#123; private Demo demo; public C(Demo demo) &#123; this.demo = demo; &#125; @Override public void run() &#123; while (true) &#123; demo.c(); &#125; &#125;&#125; 2.2 生产者与消费者2.2.1 示例：生产者与消费者商品类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Tmall &#123; private int count; private Lock lock = new ReentrantLock(); Condition p = lock.newCondition(); Condition t = lock.newCondition(); public final int MAX_COUNT = 10; public void push() &#123; lock.lock(); while (count &gt;= MAX_COUNT) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 库存数量达到上限，生产者停止生产。\"); p.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count++; System.out.println(Thread.currentThread().getName() + \" 生产者生产，当前库存为：\" + count); t.signal(); lock.unlock(); &#125; public void take() &#123; lock.lock(); while (count &lt;= 0) &#123; try &#123; System.out.println(Thread.currentThread().getName() + \" 库存数量为零，消费者等待。\"); t.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; count--; System.out.println(Thread.currentThread().getName() + \" 消费者消费，当前库存为：\" + count); p.signal(); lock.unlock(); &#125;&#125; 生产者类123456789101112131415161718192021public class PushTarget implements Runnable &#123; private Tmall tmall; public PushTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.push(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类123456789101112131415161718192021public class TakeTarget implements Runnable &#123; private Tmall tmall; public TakeTarget(Tmall tmall) &#123; this.tmall = tmall; &#125; @Override public void run() &#123; while (true) &#123; tmall.take(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Tmall tmall = new Tmall(); PushTarget p = new PushTarget(tmall); TakeTarget t = new TakeTarget(tmall); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125;&#125; 2.2.2 示例：生产者与消费者（队列）队列类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyQueue&lt;E&gt; &#123; private Object[] obj; private int addIndex; private int removeIndex; private int queueSize; private Lock lock = new ReentrantLock(); Condition addCondition = lock.newCondition(); Condition removeCondition = lock.newCondition(); public MyQueue(int count) &#123; obj = new Object[count]; &#125; public void add(E e) &#123; lock.lock(); while (queueSize == obj.length) &#123; try &#123; addCondition.await(); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + \" 生产：\" + e); obj[addIndex] = e; if (++addIndex == obj.length) &#123; addIndex = 0; &#125; queueSize++; removeCondition.signal(); lock.unlock(); &#125; public void remove() &#123; lock.lock(); while (queueSize == 0) &#123; try &#123; removeCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + \" 消费：\" + obj[removeIndex]); obj[removeIndex] = null; if (++removeIndex == obj.length) &#123; removeIndex = 0; &#125; queueSize--; addCondition.signal(); lock.unlock(); &#125;&#125; 生产者类123456789101112131415161718192021public class PushTarget implements Runnable &#123; private MyQueue&lt;Integer&gt; myQueue; public PushTarget(MyQueue&lt;Integer&gt; myQueue) &#123; this.myQueue = myQueue; &#125; @Override public void run() &#123; while (true) &#123; myQueue.add((int) (Math.random() * 100)); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 消费者类123456789101112131415161718192021public class TakeTarget implements Runnable &#123; private MyQueue&lt;Integer&gt; myQueue; public TakeTarget(MyQueue&lt;Integer&gt; myQueue) &#123; this.myQueue = myQueue; &#125; @Override public void run() &#123; while (true) &#123; myQueue.remove(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试类123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; MyQueue&lt;Integer&gt; myQueue = new MyQueue&lt;&gt;(10); PushTarget p = new PushTarget(myQueue); TakeTarget t = new TakeTarget(myQueue); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(p).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); new Thread(t).start(); &#125;&#125; 2.3 数据库连接池示例：自定义数据库连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.LinkedList;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * 示例代码，无法运行，仅供参考 * @author lingyuwang * */public class MyDataSource &#123; /** * 连接池 */ private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;&gt;(); /** * 初始化连接 */ private static final int INIT_CONNECTIONS = 10; private static final String USER = \"\"; private static final String PASSWORD = \"\"; private static final String URL = \"\"; /** * 锁 */ private Lock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); public MyDataSource() &#123; for (int i = 0; i &lt; INIT_CONNECTIONS; i++) &#123; try &#123; Connection conn = DriverManager.getConnection(URL, USER, PASSWORD); pool.addLast(conn); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public Connection getConnect() &#123; Connection result = null; lock.lock(); try &#123; while (pool.size() &lt;= 0) &#123; try &#123; c1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (!pool.isEmpty()) &#123; result = pool.removeFirst(); &#125; return result; &#125; finally &#123; lock.unlock(); &#125; &#125; public void release(Connection conn) &#123; if (conn != null) &#123; lock.lock(); try &#123; pool.addLast(conn); c1.signal(); // 只唤醒一个线程 &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; TIPS：示例代码，无法运行，仅供参考。 3 ThreadLocal示例：线程局部计数器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 线程局部计数器，两线程各自计算互不影响 * @author lingyuwang * */public class Demo &#123; private ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;() &#123; protected Integer initialValue() &#123; return new Integer(0); &#125;; &#125;; public int getNext() &#123; Integer value = count.get(); value++; count.set(value); return value; &#125; public static void main(String[] args) &#123; Demo d = new Demo(); // 线程1 new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + \" \" + d.getNext()); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); // 线程2 new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + \" \" + d.getNext()); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 4 CountDownLatch示例：模拟命令发送与响应12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CountDownLatchTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final CountDownLatch cdOrder = new CountDownLatch(1); // 表示需要一个线程解阻塞 final CountDownLatch cdAnswer = new CountDownLatch(3); // 表示需要三个线程解阻塞 for (int i = 0; i &lt; 3; i++) &#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; System.out.println(\"线程\" + Thread.currentThread().getName() + \"正准备接受命令\"); cdOrder.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"已接受命令\"); Thread.sleep((long)(Math.random()*10000)); System.out.println(\"线程\" + Thread.currentThread().getName() + \"回应命令处理结果\"); cdAnswer.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; try &#123; Thread.sleep((long)(Math.random()*10000)); System.out.println(\"线程\" + Thread.currentThread().getName() + \"即将发布命令\"); cdOrder.countDown(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"已发送命令，正在等待结果\"); cdAnswer.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"已收到所有响应结果\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; service.shutdown(); &#125;&#125; 2.5 CyclicBarrier2.5.1 示例：线程都到达某目的点后再继续执行1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.CyclicBarrier;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final CyclicBarrier cb = new CyclicBarrier(3); for (int i = 0; i &lt; 3; i++)&#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; Thread.sleep((long)(Math.random()*10000)); System.out.println(\"线程\" + Thread.currentThread().getName() + \"即将到达集合地点1，当前已有\" + (cb.getNumberWaiting()+1) + \"个已经到达，\" + (cb.getNumberWaiting()==2?\"都到齐了，继续走啊\":\"正在等候\")); cb.await(); Thread.sleep((long)(Math.random()*10000)); System.out.println(\"线程\" + Thread.currentThread().getName() + \"即将到达集合地点2，当前已有\" + (cb.getNumberWaiting()+1) + \"个已经到达，\" + (cb.getNumberWaiting()==2?\"都到齐了，继续走啊\":\"正在等候\")); cb.await(); Thread.sleep((long)(Math.random()*10000)); System.out.println(\"线程\" + Thread.currentThread().getName() + \"即将到达集合地点3，当前已有\" + (cb.getNumberWaiting() + 1) + \"个已经到达，\" + (cb.getNumberWaiting()==2?\"都到齐了，继续走啊\":\"正在等候\")); cb.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125;&#125; 2.5.2 示例：模拟开会123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.util.Random;import java.util.concurrent.CyclicBarrier;public class CyclicBarrierTest &#123; /** * 是否停止监控线程 */ private volatile boolean running = true; Random random = new Random(); /** * 开会 * @param barrier */ public void meeting(CyclicBarrier barrier) &#123; try &#123; Thread.sleep(random.nextInt(4000)); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" 到达会议室，等待开会..\"); // 模拟重置 /*if (Thread.currentThread().getName().equals(\"Thread-7\")) &#123; try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; barrier.reset(); &#125;*/ try &#123; barrier.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; CyclicBarrierTest demo = new CyclicBarrierTest(); CyclicBarrier barrier = new CyclicBarrier(10, new Runnable() &#123; @Override public void run() &#123; System.out.println(\"好！我们开始开会...\"); demo.running = false; &#125; &#125;); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; demo.meeting(barrier); &#125; &#125;).start(); &#125; // 监控等待线程数 new Thread(new Runnable() &#123; @Override public void run() &#123; while (demo.running) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"等待的线程数 \" + barrier.getNumberWaiting()); System.out.println(\"is broken \" + barrier.isBroken()); &#125; &#125; &#125;).start(); &#125;&#125; 2.6 Semaphore示例：模拟限流1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final Semaphore sp = new Semaphore(3); for (int i = 0; i &lt; 10; i++) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; try &#123; sp.acquire(); // 拿到许可 &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println(\"线程\" + Thread.currentThread().getName() + \"进入，当前已有\" + (3-sp.availablePermits()) + \"个并发\"); try &#123; Thread.sleep((long)(Math.random()*10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程\" + Thread.currentThread().getName() + \"即将离开\"); sp.release(); // 释放许可 // 下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元 System.out.println(\"线程\" + Thread.currentThread().getName() + \"已离开，当前已有\" + (3-sp.availablePermits()) + \"个并发\"); &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125;&#125; 2.7 FutureTask示例：自定义FutureTask，模拟购买商品过程 Future类12345678910111213141516171819202122232425262728public class Future&lt;V&gt; &#123; private V v; private boolean down; public synchronized void setProduct (V v) &#123; if (down) &#123; return; &#125; this.v = v; this.down = true; notifyAll(); &#125; public synchronized V get () &#123; while (!down) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return v; &#125;&#125; 商品工厂类12345678910111213141516171819202122import java.util.Random;public class ProductFactory &#123; public Future&lt;Product&gt; createProduct(String name) &#123; Future&lt;Product&gt; f = new Future&lt;&gt;(); // 创建一个订单 System.out.println(\"下单成功，你可以去上班了》。。\"); // 生产产品 new Thread(new Runnable() &#123; @Override public void run() &#123; Product p = new Product(new Random().nextInt(), name); f.setProduct(p); &#125; &#125;).start(); return f; &#125;&#125; 商品类12345678910111213141516171819202122232425262728293031323334353637383940public class Product &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"Product [id=\" + id + \", name=\" + name + \"]\"; &#125; public Product(int id, String name) &#123; System.out.println(\"开始生产 \" + name); try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.id = id; this.name = name; System.out.println(name + \" 生产完毕\"); &#125;&#125; 测试类12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; ProductFactory pf = new ProductFactory(); // 下单，交钱 Future&lt;Product&gt; f = pf.createProduct(\"蛋糕\"); System.out.println(\"我去上班了，下了班我来取蛋糕...\"); // 拿着订单获取产品 System.out.println(\"我拿着蛋糕回家.\" + f.get()); &#125;&#125; 2.8 Fork/Join示例：递归子任务做累加计算1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private static final long serialVersionUID = -8571816159838668751L; private static final int THRESHOLD = 2; // 阈值 private int start; private int end; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; boolean canCompute = (end - start) &lt;= THRESHOLD; if (canCompute) &#123; // 若任务足够小，则计算任务 for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; &#125; else &#123; // 若任务大于阈值，则分裂成两个子任务计算 int middle = (start + end) &gt;&gt; 1; // 等价于 (start + end) / 2 CountTask leftTask = new CountTask(start, middle); CountTask rightTask = new CountTask(middle+1, end); // 执行子任务 leftTask.fork(); rightTask.fork(); // 等待子任务执行完，并得到其结果 int leftResult = leftTask.join(); int rightResult = rightTask.join(); // 合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; public static void main(String[] args) throws Exception &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); // 生成一个计算任务，负责计算 1+2+3+4 CountTask task = new CountTask(1, 4); // 执行一个任务 Future&lt;Integer&gt; result = forkJoinPool.submit(task); System.out.println(result.get()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java线程锁","slug":"Java线程锁","date":"2019-04-08T14:45:14.000Z","updated":"2020-11-03T13:04:34.161Z","comments":false,"path":"2019/04/08/Java线程锁/","link":"","permalink":"https://zhechu.github.io/2019/04/08/Java线程锁/","excerpt":"","text":"锁的内存语义 当线程获取锁时，JVM 会把线程对应的本地内存置为无效，然后临界区的代码从主存中读入共享变量到工作内存 当线程释放锁时，JVM 会把该线程对应的本地内存中的共享变量刷新到主内存中 1 synchronizedsynchronized 修饰类的实例方法 修饰类的静态方法 修饰代码块 偏向锁 每次获取锁和释放锁会浪费资源 很多情况下，竞争锁不是有多个线程，而是只有一个线程在使用 轻量级锁 在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗 适应场景是线程交替执行同步块的情况，若存在同一时间访问同一锁的情况，就会导致轻量级锁升级为重量级锁 2 volatilevolatile 写读的内存语义 当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量值刷新到主内存中 当读一个 volatile 变量时，JVM 会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量 volatile 有序的内存语义 volatile 读之后的操作不会被重排序到 volatile 读之前 volatile 写之前的操作不会被重排序到 volatile 写之后 先 volatile 写–后 volatile 读，不可重排序 示例：线程1执行完毕后才执行线程2的逻辑12345678910111213141516171819202122232425262728293031323334353637public class ThreadSpinDemo &#123; public volatile boolean run = false; public static void main(String[] args) &#123; ThreadSpinDemo d = new ThreadSpinDemo(); new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i = 1;i&lt;=5;i++) &#123; System.out.println(\"线程1执行了第 \" + i + \" 次\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; d.run = true; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while(!d.run) &#123; // 不执行 &#125; // 线程1执行完毕后才执行打印 System.out.println(\"线程2执行了...\"); &#125; &#125;).start(); &#125;&#125; 3 原子类3.1 原子更新基本类型示例：安全地创建自增序列12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicInteger;public class SequenceDemo &#123; private AtomicInteger value = new AtomicInteger(0); public int getNext() &#123; return value.getAndIncrement(); &#125; public static void main(String[] args) &#123; SequenceDemo s = new SequenceDemo(); int size = 1000; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \" \" + s.getNext()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125; 3.2 原子更新数组示例：安全地更新数组12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicIntegerArray;public class AtomicIntegerArrayDemo &#123; private AtomicIntegerArray a = new AtomicIntegerArray(new int[]&#123;2,1,4,6&#125;); public int get(int index) &#123; return a.incrementAndGet(index); &#125; public static void main(String[] args) &#123; AtomicIntegerArrayDemo s = new AtomicIntegerArrayDemo(); int size = 1000; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \" \" + s.get(0)); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125; 3.3 原子更新抽象类型示例：安全地更新对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceDemo &#123; AtomicReference&lt;User&gt; userR = new AtomicReference&lt;&gt;(new User(\"name\", 0)); public User get(User user) &#123; return userR.getAndSet(user); &#125; public static void main(String[] args) &#123; AtomicReferenceDemo s = new AtomicReferenceDemo(); int size = 10; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; int old = i + 1; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \" \" + s.get(new User(\"name\", old))); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125;class User &#123; private String name; public int old; public User(String name, int old) &#123; super(); this.name = name; this.old = old; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getOld() &#123; return old; &#125; public void setOld(int old) &#123; this.old = old; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", old=\" + old + \"]\"; &#125;&#125; 3.4 原子更新字段示例：安全地更新对象属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.ArrayList;import java.util.List;import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;public class AtomicIntegerFieldUpdaterDemo &#123; AtomicIntegerFieldUpdater&lt;User&gt; old = AtomicIntegerFieldUpdater.newUpdater(User.class, \"old\"); public int getNext(User user) &#123; return old.getAndIncrement(user); &#125; public static void main(String[] args) &#123; AtomicIntegerFieldUpdaterDemo s = new AtomicIntegerFieldUpdaterDemo(); User user = new User(\"name\", 0); int size = 100; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \" \" + s.getNext(user)); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125;class User &#123; private String name; public volatile int old; public User(String name, int old) &#123; super(); this.name = name; this.old = old; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getOld() &#123; return old; &#125; public void setOld(int old) &#123; this.old = old; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", old=\" + old + \"]\"; &#125;&#125; 4 Lock 接口优势 非阻塞的获取锁 能被中断的获取锁 超时获取锁 4.1 可重入锁4.1.1 安全地创建自增序列示例123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class SequenceDemo &#123; private int value; Lock lock = new ReentrantLock(); public int getNext() &#123; lock.lock(); int t = value ++; lock.unlock(); return t; &#125; public static void main(String[] args) &#123; SequenceDemo s = new SequenceDemo(); int size = 100; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \" \" + s.getNext()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125; 4.1.2 自定义可重入锁示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;public class MyReentrantLock implements Lock &#123; private boolean isLocked = false; private Thread lockBy = null; private int lockCount = 0; @Override public synchronized void lock() &#123; Thread currentThread = Thread.currentThread(); while (isLocked &amp;&amp; currentThread != lockBy) try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; isLocked = true; lockBy = currentThread; lockCount ++; &#125; @Override public synchronized void unlock() &#123; if (lockBy == Thread.currentThread() &amp;&amp; --lockCount == 0) &#123; notify(); isLocked = false; lockBy = null; &#125; &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; &#125; @Override public boolean tryLock() &#123; return false; &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return false; &#125; @Override public Condition newCondition() &#123; return null; &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Lock;public class MyReentrantLockTest &#123; Lock lock = new MyReentrantLock(); public void a() &#123; lock.lock(); System.out.println(\"a\"); b(); lock.unlock(); &#125; public void b() &#123; lock.lock(); System.out.println(\"b\"); c(); lock.unlock(); &#125; public void c() &#123; lock.lock(); System.out.println(\"c\"); lock.unlock(); &#125; public static void main(String[] args) &#123; MyReentrantLockTest d = new MyReentrantLockTest(); int size = 100; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; d.a(); &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; threadList.clear(); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; d.b(); &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125; 4.2 AQS4.2.1 自定义可重入锁示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.AbstractQueuedSynchronizer;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;public class MyReentrantLock implements Lock &#123; private Helper helper = new Helper(); private class Helper extends AbstractQueuedSynchronizer &#123; /** * 序列号 */ private static final long serialVersionUID = 5431505653625388890L; @Override protected boolean tryAcquire(int arg) &#123; int state = getState(); Thread t = Thread.currentThread(); if (state == 0) &#123; if (compareAndSetState(0, arg)) &#123; setExclusiveOwnerThread(t); return true; &#125; &#125; else if (getExclusiveOwnerThread() == t) &#123; setState(state + 1); return true; &#125; return false; &#125; @Override protected boolean tryRelease(int arg) &#123; if (Thread.currentThread() != getExclusiveOwnerThread()) &#123; throw new RuntimeException(); &#125; int state = getState() - arg; boolean flag = false; if (state == 0) &#123; setExclusiveOwnerThread(null); flag = true; &#125; setState(state); return flag; &#125; Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; @Override public void lock() &#123; helper.acquire(1); &#125; @Override public void lockInterruptibly() throws InterruptedException &#123; helper.acquireInterruptibly(1); &#125; @Override public boolean tryLock() &#123; return helper.tryAcquire(1); &#125; @Override public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return helper.tryAcquireNanos(1, unit.toNanos(time)); &#125; @Override public void unlock() &#123; helper.release(1); &#125; @Override public Condition newCondition() &#123; return helper.newCondition(); &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.ArrayList;import java.util.List;import java.util.concurrent.locks.Lock;public class MyReentrantLockTest &#123; Lock lock = new MyReentrantLock(); public void a() &#123; lock.lock(); System.out.println(\"a\"); b(); lock.unlock(); &#125; public void b() &#123; lock.lock(); System.out.println(\"b\"); c(); lock.unlock(); &#125; public void c() &#123; lock.lock(); System.out.println(\"c\"); lock.unlock(); &#125; public static void main(String[] args) &#123; MyReentrantLockTest d = new MyReentrantLockTest(); int size = 100; List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;(size); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; d.a(); &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; threadList.clear(); for (int i = 0; i &lt; size; i++) &#123; threadList.add(new Thread(new Runnable() &#123; @Override public void run() &#123; d.b(); &#125; &#125;)); &#125; for (Thread t : threadList) &#123; t.start(); &#125; &#125;&#125; 4.2.2 自定义共享锁共享访问数据库链接的整体要求如下： 所有请求加在一起的 mysql 链接数，最大不能超过 10（包含 10），一旦超过 10，直接报错。 共享锁实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import lombok.extern.slf4j.Slf4j;import java.io.Serializable;import java.util.concurrent.locks.AbstractQueuedSynchronizer;/** * @description: 共享不公平锁 * @author: lingyuwang **/@Slf4jpublic class ShareLock implements Serializable &#123; // 同步器 private final Sync sync; // 用于确保不能超过最大值 private final int maxCount; /** * 初始化时给同步器 sync 赋值 * count 代表可以获得共享锁的最大值 */ public ShareLock(int count) &#123; this.sync = new Sync(count); maxCount = count; &#125; /** * 获得锁 * @return true 表示成功获得锁，false 表示失败 */ public boolean lock()&#123; return sync.acquireByShared(1); &#125; /** * 释放锁 * @return true 表示成功释放锁，false 表示失败 */ public boolean unLock()&#123; return sync.releaseShared(1); &#125; class Sync extends AbstractQueuedSynchronizer &#123; // 表示最多有 count 个共享锁可以获得 public Sync(int count) &#123; setState(count); &#125; // 获得 i 个锁 public boolean acquireByShared(int i) &#123; // 自旋保证 CAS 一定可以成功 for(;;)&#123; if(i&lt;=0)&#123; return false; &#125; int state = getState(); // 如果没有锁可以获得，直接返回 false if(state &lt;=0 )&#123; return false; &#125; int expectState = state - i; // 如果要得到的锁不够了，直接返回 false if(expectState &lt; 0 )&#123; return false; &#125; // CAS 尝试得到锁,CAS 成功获得锁，失败继续 for 循环 if(compareAndSetState(state,expectState))&#123; return true; &#125; &#125; &#125; // 释放 i 个锁 @Override protected boolean tryReleaseShared(int arg) &#123; for(;;)&#123; if(arg&lt;=0)&#123; return false; &#125; int state = getState(); int expectState = state + arg; // 超过了 int 的最大值，或者 expectState 超过了我们的最大预期 if(expectState &lt; 0 || expectState &gt; maxCount)&#123; log.error(\"state 超过预期，当前 state is &#123;&#125;,计算出的 state is &#123;&#125;\",state ,expectState); return false; &#125; if(compareAndSetState(state, expectState))&#123; return true; &#125; &#125; &#125; &#125;&#125; 数据库连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305import java.sql.*;import java.util.Map;import java.util.Properties;import java.util.concurrent.Executor;public class MysqlConnection &#123; private final ShareLock lock; // maxConnectionSize 表示最大链接数 public MysqlConnection(int maxConnectionSize) &#123; lock = new ShareLock(maxConnectionSize); &#125; // 对外获取 mysql 链接的接口 // 这里不用try finally 的结构，获得锁实现底层不会有异常 // 即使出现未知异常，也无需释放锁 public Connection getLimitConnection() &#123; if (lock.lock()) &#123; return getConnection(); &#125; return null; &#125; // 对外释放 mysql 链接的接口 public boolean releaseLimitConnection() &#123; return lock.unLock(); &#125; // 得到一个 mysql 链接，底层实现省略 private Connection getConnection()&#123; return new Connection() &#123; @Override public Statement createStatement() throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return null; &#125; @Override public CallableStatement prepareCall(String sql) throws SQLException &#123; return null; &#125; @Override public String nativeSQL(String sql) throws SQLException &#123; return null; &#125; @Override public void setAutoCommit(boolean autoCommit) throws SQLException &#123; &#125; @Override public boolean getAutoCommit() throws SQLException &#123; return false; &#125; @Override public void commit() throws SQLException &#123; &#125; @Override public void rollback() throws SQLException &#123; &#125; @Override public void close() throws SQLException &#123; &#125; @Override public boolean isClosed() throws SQLException &#123; return false; &#125; @Override public DatabaseMetaData getMetaData() throws SQLException &#123; return null; &#125; @Override public void setReadOnly(boolean readOnly) throws SQLException &#123; &#125; @Override public boolean isReadOnly() throws SQLException &#123; return false; &#125; @Override public void setCatalog(String catalog) throws SQLException &#123; &#125; @Override public String getCatalog() throws SQLException &#123; return null; &#125; @Override public void setTransactionIsolation(int level) throws SQLException &#123; &#125; @Override public int getTransactionIsolation() throws SQLException &#123; return 0; &#125; @Override public SQLWarning getWarnings() throws SQLException &#123; return null; &#125; @Override public void clearWarnings() throws SQLException &#123; &#125; @Override public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException &#123; return null; &#125; @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency) throws SQLException &#123; return null; &#125; @Override public Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() throws SQLException &#123; return null; &#125; @Override public void setTypeMap(Map&lt;String, Class&lt;?&gt;&gt; map) throws SQLException &#123; &#125; @Override public void setHoldability(int holdability) throws SQLException &#123; &#125; @Override public int getHoldability() throws SQLException &#123; return 0; &#125; @Override public Savepoint setSavepoint() throws SQLException &#123; return null; &#125; @Override public Savepoint setSavepoint(String name) throws SQLException &#123; return null; &#125; @Override public void rollback(Savepoint savepoint) throws SQLException &#123; &#125; @Override public void releaseSavepoint(Savepoint savepoint) throws SQLException &#123; &#125; @Override public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException &#123; return null; &#125; @Override public CallableStatement prepareCall(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException &#123; return null; &#125; @Override public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException &#123; return null; &#125; @Override public Clob createClob() throws SQLException &#123; return null; &#125; @Override public Blob createBlob() throws SQLException &#123; return null; &#125; @Override public NClob createNClob() throws SQLException &#123; return null; &#125; @Override public SQLXML createSQLXML() throws SQLException &#123; return null; &#125; @Override public boolean isValid(int timeout) throws SQLException &#123; return false; &#125; @Override public void setClientInfo(String name, String value) throws SQLClientInfoException &#123; &#125; @Override public void setClientInfo(Properties properties) throws SQLClientInfoException &#123; &#125; @Override public String getClientInfo(String name) throws SQLException &#123; return null; &#125; @Override public Properties getClientInfo() throws SQLException &#123; return null; &#125; @Override public Array createArrayOf(String typeName, Object[] elements) throws SQLException &#123; return null; &#125; @Override public Struct createStruct(String typeName, Object[] attributes) throws SQLException &#123; return null; &#125; @Override public void setSchema(String schema) throws SQLException &#123; &#125; @Override public String getSchema() throws SQLException &#123; return null; &#125; @Override public void abort(Executor executor) throws SQLException &#123; &#125; @Override public void setNetworkTimeout(Executor executor, int milliseconds) throws SQLException &#123; &#125; @Override public int getNetworkTimeout() throws SQLException &#123; return 0; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; return false; &#125; &#125;; &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132import lombok.extern.slf4j.Slf4j;/** * @description: * @author: lingyuwang **/@Slf4jpublic class LockTest &#123; public static void main(String[] args) &#123; log.info(\"模仿开始获得 mysql 链接\"); MysqlConnection mysqlConnection = new MysqlConnection(10); log.info(\"初始化 Mysql 链接最大只能获取 10 个\"); for(int i =0 ;i&lt;12;i++)&#123; if(null != mysqlConnection.getLimitConnection())&#123; log.info(\"获得第&#123;&#125;个数据库链接成功\",i+1); &#125;else &#123; log.info(\"获得第&#123;&#125;个数据库链接失败：数据库连接池已满\",i+1); &#125; &#125; log.info(\"模仿开始释放 mysql 链接\"); for(int i =0 ;i&lt;12;i++)&#123; if(mysqlConnection.releaseLimitConnection())&#123; log.info(\"释放第&#123;&#125;个数据库链接成功\",i+1); &#125;else &#123; log.info(\"释放第&#123;&#125;个数据库链接失败\",i+1); &#125; &#125; log.info(\"模仿结束\"); &#125;&#125; 打印效果12345678910111213141516171819202122232425262728293011:41:02.913 [main] INFO com.wise.example.lock.LockTest - 模仿开始获得 mysql 链接11:41:02.924 [main] INFO com.wise.example.lock.LockTest - 初始化 Mysql 链接最大只能获取 10 个11:41:02.926 [main] INFO com.wise.example.lock.LockTest - 获得第1个数据库链接成功11:41:02.929 [main] INFO com.wise.example.lock.LockTest - 获得第2个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第3个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第4个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第5个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第6个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第7个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第8个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第9个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第10个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第11个数据库链接失败：数据库连接池已满11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 获得第12个数据库链接失败：数据库连接池已满11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 模仿开始释放 mysql 链接11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 释放第1个数据库链接成功11:41:02.930 [main] INFO com.wise.example.lock.LockTest - 释放第2个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第3个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第4个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第5个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第6个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第7个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第8个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第9个数据库链接成功11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第10个数据库链接成功11:41:02.931 [main] ERROR com.wise.example.lock.ShareLock - state 超过预期，当前 state is 10,计算出的 state is 1111:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第11个数据库链接失败11:41:02.931 [main] ERROR com.wise.example.lock.ShareLock - state 超过预期，当前 state is 10,计算出的 state is 1111:41:02.931 [main] INFO com.wise.example.lock.LockTest - 释放第12个数据库链接失败11:41:02.931 [main] INFO com.wise.example.lock.LockTest - 模仿结束 4.3 读写锁读写锁：读-读能共存，读-写不能共存，写-写不能共存 锁降级：写锁降级成为读锁 4.3.1 HashMap 加读写锁示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class ReadWriteLockDemo &#123; private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private ReadWriteLock rwl = new ReentrantReadWriteLock(); private Lock r = rwl.readLock(); private Lock w = rwl.writeLock(); public Object get(String key) &#123; r.lock(); System.out.println(Thread.currentThread().getName() + \" 读操作在执行..\"); try &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return map.get(key); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + \" 读操执行完毕..\"); r.unlock(); &#125; &#125; public void put(String key, Object value) &#123; w.lock(); System.out.println(Thread.currentThread().getName() + \" 写操作在执行..\"); try &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + \" 写操作执行完毕..\"); w.unlock(); &#125; &#125; public static void main(String[] args) &#123; ReadWriteLockDemo d = new ReadWriteLockDemo(); d.put(\"key1\", \"value1\"); new Thread(new Runnable() &#123; @Override public void run() &#123; d.put(\"key1\", \"value1\"); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.get(\"key1\")); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; d.put(\"key3\", \"value3\"); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.get(\"key1\")); &#125; &#125;).start(); &#125;&#125; 4.3.2 HashMap 加读写锁（乐观锁）示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.StampedLock;public class StampedLockDemo &#123; private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); private StampedLock sl = new StampedLock(); public Object get(String key) &#123; long stamp = sl.tryOptimisticRead(); System.out.println(Thread.currentThread().getName() + \" 读操作在执行..\"); Object result = map.get(key); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (!sl.validate(stamp)) &#123; stamp = sl.readLock(); try &#123; result = map.get(key); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + \" 读操执行完毕..\"); sl.unlockRead(stamp); &#125; &#125; return result; &#125; public void put(String key, Object value) &#123; long stamp = sl.writeLock(); System.out.println(Thread.currentThread().getName() + \" 写操作在执行..\"); try &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; map.put(key, value); &#125; finally &#123; System.out.println(Thread.currentThread().getName() + \" 写操作执行完毕..\"); sl.unlockWrite(stamp); &#125; &#125; public static void main(String[] args) &#123; StampedLockDemo d = new StampedLockDemo(); d.put(\"key\", \"value1\"); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.get(\"key\")); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; d.put(\"key\", \"value2\"); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.get(\"key\")); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; d.put(\"key\", \"value3\"); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.get(\"key\")); &#125; &#125;).start(); &#125;&#125; 4.3.3 锁升级，优化性能示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import java.util.concurrent.locks.StampedLock;public class StampedLockDemo &#123; private int balance; private StampedLock sl = new StampedLock(); /** * 悲观写 * @param value */ public void write(int value) &#123; long stamp = sl.writeLock(); System.out.println(Thread.currentThread().getName() + \" 悲观写操作在执行..\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; balance += value; &#125; finally &#123; System.out.println(Thread.currentThread().getName() + \" 悲观写操作执行完毕..\"); sl.unlockWrite(stamp); &#125; &#125; /** * 条件写 * @param value */ public void conditionWrite (int value) &#123; long stamp = sl.readLock(); System.out.println(Thread.currentThread().getName() + \" 条件写操作在执行..\"); try &#123; // 先判断 balance 是否符合更新的条件 while (balance &gt; 0) &#123; long writeStamp = sl.tryConvertToWriteLock(stamp); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (writeStamp != 0L) &#123; // 成功转换成为写锁 stamp = writeStamp; balance += value; System.out.println(Thread.currentThread().getName() + \" 条件写操作执行完毕..\"); break; &#125; else &#123; System.out.println(Thread.currentThread().getName() + \" 条件写的读锁未转换为写锁..\"); // 没有转换成写锁，先释放读锁，然后再拿到写锁 sl.unlockRead(stamp); // 获取写锁 stamp = sl.writeLock(); &#125; &#125; &#125; finally &#123; sl.unlock(stamp); &#125; &#125; /** * 乐观读 */ public int optimisticRead() &#123; long stamp = sl.tryOptimisticRead(); System.out.println(Thread.currentThread().getName() + \" 乐观读操作在执行..\"); int result = balance; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 可能会出现了写操作，因此要进行判断 if (!sl.validate(stamp)) &#123; // 重新读取 stamp = sl.readLock(); System.out.println(Thread.currentThread().getName() + \" 乐观读的乐观读锁转换为悲观读锁..\"); try &#123; result = balance; System.out.println(Thread.currentThread().getName() + \" 悲观读操作执行完毕..\"); &#125; finally &#123; sl.unlockRead(stamp); &#125; &#125; System.out.println(Thread.currentThread().getName() + \" 乐观读操作执行完毕..\"); return result; &#125; public static void main(String[] args) &#123; StampedLockDemo d = new StampedLockDemo(); d.conditionWrite(1); d.write(2); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.optimisticRead()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; d.conditionWrite(3); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.optimisticRead()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; d.conditionWrite(4); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(d.optimisticRead()); &#125; &#125;).start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"},{"name":"锁","slug":"锁","permalink":"https://zhechu.github.io/tags/锁/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java线程本质问题","slug":"Java线程本质问题","date":"2019-04-07T14:37:37.000Z","updated":"2020-11-03T13:04:34.160Z","comments":false,"path":"2019/04/07/Java线程本质问题/","link":"","permalink":"https://zhechu.github.io/2019/04/07/Java线程本质问题/","excerpt":"","text":"1 活跃性问题线程的活跃性问题 死锁 饥饿 活锁 2 安全性问题线程安全性问题 多个线程对竞态资源进行非原子性读写操作。 2.1 饥饿与公平饥饿与公平的表现 高优先级吞噬所有低优先级的 CPU 时间片。方案：设置合理的优先级。 线程被永久堵塞在一个等待进入同步块的状态。方案：使用锁来代替同步块。 等待的线程永远不被唤醒。 2.2 安全地发布对象要安全地发布一个对象，对象的引用以及对象的状态必须同时对其它线程可见。一个正确构造的对象可以通过一下方式来安全地发布： 在静态初始化函数中初始化一个对象引用。 将对象的引用保存到 volatile 类型的域或者 AtomicReferance 对象中。 将对象的引用保存到某个正确构造对象的 final 类型域中。 将对象的引用保存到一个由锁保护的域中。 共享对象策略 线程封闭（栈内创建和访问） 只读共享 线程安全共享 保护对象，被保护的对象只能通过持有特定的锁来访问 2.3 修复共享变量 BUG若多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。 有三种方式可以修复这个问题： 不在线程之间共享改状态变量 将状态变量修改为不可变的变量 在访问状态变量时使用同步","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java并发基础","slug":"Java并发基础","date":"2019-04-07T12:34:33.000Z","updated":"2020-11-03T13:04:34.154Z","comments":false,"path":"2019/04/07/Java并发基础/","link":"","permalink":"https://zhechu.github.io/2019/04/07/Java并发基础/","excerpt":"","text":"1 进程与线程的关系进程与线程的关系 进程是资源分配的基本单位 进程中包含多个线程，线程共享进程的资源 线程是处理器调度的基本单位 2 线程的状态 启动 就绪 执行 睡眠 等待 阻塞 死亡 3 线程中断描述：调用 Thread.interrupt() 会导致线程中断。此方法通过修改被调用线程的中断状态告知其被中断。对于非阻塞中的线程, 只改变中断状态, 即 Thread.isInterrupted() 将返回 true; 对于可取消阻塞状态中的线程, 比如等待在这些函数上的线程, Thread.sleep(), Object.wait(), Thread.join()，此线程收到中断信号后, 会抛出 InterruptedException 异常，同时会把中断状态置为 true。但调用 Thread.interrupted() 可以对中断状态进行复位。 3.1 中断正在阻塞状态的线程若线程被阻塞，它便不能核查共享变量，也就不能停止。这在许多情况下会发生，例如调用 Object.wait()、ServerSocket.accept() 和 DatagramSocket.receive() 时，它们都可能永久的阻塞线程。即使发生超时，在超时期满之前持续等待也是不可行和不恰当的。所以，要使用某种机制使得线程更早地退出被阻塞的状态。很不幸运，不存在这样一种机制对所有的情况都适用。但是，根据情况不同却可以使用特定的技术。使用 Thread.interrupt() 中断线程正如示例中所描述的，Thread.interrupt() 方法不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被 Object.wait, Thread.join 和 Thread.sleep 三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。因此，若线程被上述几种方法阻塞，正确的停止线程方式是设置共享变量，并调用 interrupt()（注意变量应该先设置）。若线程没有被阻塞，这时调用 interrupt() 将不起作用；否则，线程就将得到异常（该线程必须事先预备好处理此状况），接着逃离阻塞状态。在任何一种情况中，最后线程都将检查共享变量然后再停止。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BlockThread extends Thread &#123; volatile boolean stop = false; public static void main(String args[]) throws Exception &#123; BlockThread thread = new BlockThread(); System.out.println(\"Starting thread...\"); thread.start(); Thread.sleep(3000); System.out.println(\"Asking thread to stop...\"); /* * 如果线程阻塞，将不会检查此变量,调用interrupt之后，线程就可以尽早的终结被阻 * 塞状态，才能够检查这一变量。 * */ thread.stop = true; /* * 在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态 * */ thread.interrupt(); Thread.sleep(3000); System.out.println(\"Stopping application...\"); System.exit(0); &#125; public void run() &#123; while (!stop) &#123; System.out.println(\"Thread running...\"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; // 接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态 System.out.println(\"Thread interrupted...\"); &#125; &#125; System.out.println(\"Thread exiting under request...\"); &#125;&#125; 3.2 中断非阻塞状态的线程123456789101112131415161718192021222324252627282930public class NoBlockThread extends Thread &#123; @Override public void run()&#123; while (true) &#123; if (Thread.currentThread().isInterrupted()) &#123; System.out.println(\"Someone interrupted me.\"); break; &#125; else &#123; System.out.println(\"Thread is Going...\"); &#125; &#125; &#125; /** * 分析: * 在main线程sleep的过程中由于t线程中isInterrupted()为false所以不断的输出”Thread is going”。 * 当调用t线程的interrupt()后t线程中isInterrupted()为true。此时会输出Someone interrupted me. * 而且线程并不会因为中断信号而停止运行。因为它只是被修改一个中断信号而已。 * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; NoBlockThread t = new NoBlockThread(); t.start(); Thread.sleep(2); t.interrupt(); &#125;&#125; 3.3 中断的经典案例12345678910111213141516171819202122232425262728293031323334353637383940public class ClassicsInterruptThread &#123; /** * while循环有一个决定因素就是需要不停的检查自己的中断状态。当外部线程调用该线程的interrupt 时，使得中断状态置位即变为true。 * 这时该线程将终止循环，不在执行循环中的do more work了。 * 这说明: interrupt中断的是线程的某一部分业务逻辑，前提是线程需要检查自己的中断状态(isInterrupted())。 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Thread t = new InterruptedJob(); t.start(); Thread.sleep(2000); t.interrupt(); &#125; static class InterruptedJob extends Thread &#123; @Override public void run() &#123; try&#123; while(!Thread.currentThread().isInterrupted())&#123; // do more work; System.out.println(\"do more work\"); Thread.sleep(1000); &#125; &#125; catch(InterruptedException e)&#123; // thread was interrupted during sleep or wait System.out.println(\"thread was interrupted during sleep or wait\"); &#125; finally&#123; // cleanup, if required System.out.println(\"cleanup, if required\"); &#125; &#125; &#125;&#125; 4 线程的创建方式4.1 继承 Thread 类略。 4.2 实现 Runnable 接口略。 4.3 匿名内部类略。 4.4 带返回值示例：创建带返回值的线程12345678910111213141516171819202122232425262728293031import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;public class CallableDemo implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(\"正在进行紧张的计算....\"); Thread.sleep(3000); return 1; &#125; public static void main(String[] args) throws Exception &#123; CallableDemo d = new CallableDemo(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(d); Thread t = new Thread(task); t.start(); System.out.println(\"我先干点别的。。。\"); // 会一直阻塞在这，直到拿到线程的执行结果 Integer result = task.get(); System.out.println(\"线程执行的结果为：\" + result); System.out.println(\"我再干点别的。。。\"); &#125;&#125; 4.5 定时器示例：创建定时任务12345678910111213141516171819202122import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; public static void main(String[] args) &#123; Timer timer = new Timer(); // 每隔一秒执行一次 timer.schedule(new TimerTask() &#123; @Override public void run() &#123; // 实现定时任务 System.out.println(\"timertask is run\"); &#125; &#125;, 0, 1000); &#125;&#125; 4.6 线程池示例：线程池的使用1234567891011121314151617181920212223import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 根据需要创建新线程，但将在可用时重用先前构建的线程，空闲时间为60秒，超过空闲时间则会被移除 ExecutorService threadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 4.7 Lambda 表达式实现示例：实现累加计算功能123456789101112131415161718import java.util.Arrays;import java.util.List;public class LambdaDemo &#123; public static void main(String[] args) &#123; // 实现并发计算 List&lt;Integer&gt; values = Arrays.asList(10,20,30,40); int res = new LambdaDemo().add(values); System.out.println(\"计算的结果为：\" + res); &#125; public int add (List&lt;Integer&gt; values) &#123; // values.parallelStream().forEach(System.out :: println); return values.parallelStream().mapToInt( i -&gt; i * 2).sum(); &#125;&#125; 4.8 Spring 多线程官方文档 https://spring.io/guides/gs/async-method/ 5 并发编程设计模式5.1 线程上下文设计模式5.2 Thread-Per-Message 设计模式5.4 Worker-Thread 设计模式","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java性能优化","slug":"Java性能优化","date":"2019-04-07T02:16:47.000Z","updated":"2020-11-03T13:04:34.156Z","comments":false,"path":"2019/04/07/Java性能优化/","link":"","permalink":"https://zhechu.github.io/2019/04/07/Java性能优化/","excerpt":"","text":"1 性能评估指标参考指标 执行时间 占用CPU时间 内存分配 磁盘吞吐量 网络吞吐量 响应时间 2 瓶颈资源 磁盘I/O 网络操作 CPU：降低用户态CPU使用率和系统态CPU使用率、减少停滞和改善CPU高速缓存使用率 异常 数据库 锁竞争 内存 3 位运算将十进制转换为位运算提高运算效率。 3.1 交换示例：两数交换12345678// a 与 b 交换int a = 1;int b = 2;a=a^b;b=b^a;a=b^a;System.out.println(a); // 2System.out.println(b); // 1 3.2 2的整次幂取模示例：对8取模123456789101112// 8 取模int target = 8;System.out.println((target - 1) &amp; 0); // 0System.out.println((target - 1) &amp; 1); // 1System.out.println((target - 1) &amp; 2); // 2System.out.println((target - 1) &amp; 3); // 3System.out.println((target - 1) &amp; 4); // 4System.out.println((target - 1) &amp; 5); // 5System.out.println((target - 1) &amp; 6); // 6System.out.println((target - 1) &amp; 7); // 7System.out.println((target - 1) &amp; 8); // 0System.out.println((target - 1) &amp; 9); // 1 3.3 哈希算法示例：Java8 HashMap 中的哈希算法123456Integer target = 1;String key = String.valueOf(target);int h;int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);System.out.println(hash); 知乎详解 https://www.zhihu.com/question/20733617 3.4 乘法和除法尽量使用位运算12345678// 常用int i = 16;int a = i * 8;int b = i / 2;// 使用位运算a = i &lt;&lt; 3; // 等价于 a = i * 8b = i &gt;&gt; 1; // 等价于 b = i / 2 4 基本数据类型转为字符串12345Integer id = 10;// Integer id = null;System.out.println(id.toString()); // 最快，但不安全，有可能发生空指针异常System.out.println(String.valueOf(id)); // 次之System.out.println(id + \"\"); // 最慢 5 使用 final 关键字带有 final 修饰符的类是不可派生的，为类指定 final 修饰符可以让类不可继承，为方法指定 final 修饰符可以让方法不可被重写。如果一个类指定类 final，则该类的所有方法都是 final 的。JVM 会寻找机会内联所有 final 方法，内联对于提升 Java 运行效率作用重大。 6 循环展开循环展开是一种牺牲程序的尺寸来加快程序的执行速度的优化方法。可以由程序员完成，也可由编译器自动优化完成。 循环展开最常用来降低循环开销，为具有多个功能单元的处理器提供指令级并行。也有利于指令流水线的调度。 示例：初始化数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.junit.Test;/** * 循环展开 性能测试 * @author lingyuwang * */public class WhileTest &#123; /** * 未展开测试 */ @Test public void noOpenTest () &#123; int[] ary = new int[100000000]; long begin = System.currentTimeMillis(); int size = ary.length; for (int i = 0; i &lt; size; i++) &#123; ary[i] = i; &#125; System.out.println(\"未展开：\"+(System.currentTimeMillis()-begin) + \"毫秒\"); &#125; /** * 展开测试 */ @Test public void openTest () &#123; int[] ary = new int[100000000]; long begin2 = System.currentTimeMillis(); int size2 = ary.length; for (int i = 0; i &lt; size2; i += 5) &#123; ary[i] = i; ary[i + 1] = i + 1; ary[i + 2] = i + 2; ary[i + 3] = i + 3; ary[i + 4] = i + 4; &#125; System.out.println(\"展开：\"+(System.currentTimeMillis()-begin2) + \"毫秒\"); &#125;&#125; 测试情况（单位：毫秒） 第一次 第二次 第三次 平均 未展开 114 137 114 121 展开 111 114 112 112 TIPS：展开循环比未展开循环要快9毫秒。注意，在复杂的情况下，性能受影响的因素也多，结果有可能相反。建议采用展开循环方式优化程序性能前，严格测试。 7 避免重复计算示例：重复计算集合的大小12345678910//造成重复计算的例子for(int i = 0; i &lt; list.size(); i++)&#123;...&#125;//避免重复计算的例子int length = list.size();for(int i = 0; i &lt; length; i++)&#123;...&#125; TIPS：第一个例子每次循环，都要运行一遍 size() 方法获取列表元素大小，若循环的次数很大，会严重影响运行的效率。当然，编译器可能对其有优化，但我们不能太依赖编译器。 8 减少过程调用过程调用需要虚拟机维护更多的堆栈信息，固然更耗性能。若能减少其调用，则减少其调用。但是，需要综合考虑具体情况。有时为了增加程序的阅读性，需增加过程调用。 示例：初始化数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import org.junit.Test;public class PerfTest &#123; @Test public void procedureCallTest () &#123; arrayLength1Test(); arrayLength2Test(); &#125; private void arrayLength1Test () &#123; int[] ary = new int[100000000]; long begin = System.currentTimeMillis(); for (int i = 0; i &lt; ary.length; i++) &#123; ary[i] = i; &#125; int size = ary.length; for (int i = 0; i &lt; size; i++) &#123; ary[i] = i; &#125; System.out.println(\"不使用过程调用：\"+(System.currentTimeMillis()-begin) + \"毫秒\"); &#125; private void arrayLength2Test () &#123; int[] ary = new int[100000000]; long begin = System.currentTimeMillis(); source(ary); perf(ary); System.out.println(\"使用过程调用：\"+(System.currentTimeMillis()-begin) + \"毫秒\"); &#125; private void source (int[] ary) &#123; for (int i = 0; i &lt; ary.length; i++) &#123; ary[i] = i; &#125; &#125; private void perf (int[] ary) &#123; int size = ary.length; for (int i = 0; i &lt; size; i++) &#123; ary[i] = i; &#125; &#125;&#125; 测试情况（单位：毫秒） 第一次 第二次 第三次 平均 未使用过程调用 237 224 225 228 使用过程调用 339 332 338 336 TIPS：未使用过程调用比使用过程调用要快108毫秒。 9 消除过期对象的引用所谓过期对象的引用可以理解为对往后的程序执行没有任何价值的对象的引用。 示例：使用数组实现栈1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;import java.util.EmptyStackException;public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); return elements[--size]; &#125; /** * 保证至少有一个以上的元素的空间，每次队列需要增长时大约使容量加倍 * */ private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; 分析：若栈增长然后收缩，从栈弹出的对象不会被垃圾回收，即使程序已经没有对它们的引用。这是因为栈维持着对这些对象的过期引用(obsolete reference)。 改进后的代码（改进pop方法，消除过期引用）12345678910111213141516171819202122232425262728293031323334353637import java.util.Arrays;import java.util.EmptyStackException;public class Stack &#123; private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() &#123; elements = new Object[DEFAULT_INITIAL_CAPACITY]; &#125; public void push(Object e) &#123; ensureCapacity(); elements[size++] = e; &#125; public Object pop() &#123; if (size == 0) throw new EmptyStackException(); Object result = elements[--size]; elements[size] = null; // 消除过期引用 return result; &#125; /** * 保证至少有一个以上的元素的空间，每次队列需要增长时大约使容量加倍 * */ private void ensureCapacity() &#123; if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size + 1); &#125;&#125; TIPS：上述示例比较简单，很容易看出过期对象的引用。但是在复杂的场景下，比较容易犯这种低级错误。 10 线程池合理设置线程池的参数。 查看操作系统上下文切换 vmstat：全局 pidstat：具体到进程 ID 11 其它优化方式或方向 静态方法比非静态方法要快 对于大对象，可考虑使用 clone() 代替 new 使用 IO 尽可能使用 Buffer 对于数组的复制，使用 System.arraycopy() 布尔运算比位运算快 提取表达式 尽可能为集合定义初始大小，如：预期已确定集合的大小 在 finally 块中关闭 stream 尽可能将 try/catch 块移出循环 对于 boolean 值，避免不必要的等式判断 尽量重用对象，如：StringBuffer 在对象使用完毕后，手动设置成 null，及时释放内存，如：在局部方法中使用完对象后立即置 null，便于 GC 及时收集 尽量使用基本数据类型代替对象 二维数组比一维数组占用更多的内存空间，大概是10倍 实现 RandomAccess 接口的集合（如 ArrayList） ，应当使用最普通的 for 循环而不是 foreach 循环来遍历 尽量使用 HashMap、ArrayList、StringBuilder。除非线程需要，否则不推荐使用 HashTable、Vector、StringBuffer，后三者由于使用了同步机制而导致性能开销 正则表达式使用懒惰模式和独占模式避免回溯","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java性能调优案例","slug":"Java性能调优案例","date":"2019-04-07T02:00:09.000Z","updated":"2020-11-03T13:04:34.156Z","comments":false,"path":"2019/04/07/Java性能调优案例/","link":"","permalink":"https://zhechu.github.io/2019/04/07/Java性能调优案例/","excerpt":"","text":"1 导出 OOM 信息JVM 配置导出内存溢出异常信息1-XX:+HeapDumpOnOutOfMemoryError 2 使用串行收集器2.1 使用示例1-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC 2.2 验证对象优先在Eden上分配（Eden为8M）1-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 3 设定大对象边界示例：设定6M为大对象，当分配7M内存时，直接进入老年代（-XX:PretenureSizeThreshold）1-verbose:gc -XX:+PrintGCDetails -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=6M 4 系统卡顿调优问题：经常长时间出现卡顿现象。 检查情况：Full GC 耗时20-30秒（JVM堆内存指定50G）。 解决方案：部署多个 Tomcat，JVM堆内存指定4G，使用 Nginx 做负载均衡（IP哈希算法）。 总结：JVM 堆内存不宜过大。这不仅会导致 JVM 寻址时间变长，也会影响 GC。 5 堆外内存溢出问题：经常出现内存溢出异常。 检查情况：JVM 堆内存正常，NIO 申请堆外内存失败（堆外内存太小导致）。 解决方案：加大堆外内存。 总结：Java 程序也依赖堆外内存。 6 JVM 崩溃问题：JVM 崩溃。 检查情况：生产消息太快，服务器处理不过来。 解决方案：加 MQ 缓冲。 总结：当生产者生产消息能力过大时，可以加缓冲中间件。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"JVM工具","slug":"JVM工具","date":"2019-04-07T01:00:16.000Z","updated":"2021-03-05T01:15:58.720Z","comments":false,"path":"2019/04/07/JVM工具/","link":"","permalink":"https://zhechu.github.io/2019/04/07/JVM工具/","excerpt":"","text":"1 JPS官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html 作用：查看 Java 程序运行状态。 1.1 查看帮助1$ jps --help 参数 说明 m 运行时传入主类的参数 l 运行的主类全名 v 虚拟机参数 1.2 查看所有 Java 进程的 PID1$ jps -mlvV 2 JSTAT官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html 作用：Java 虚拟机统计监视工具。 2.1 查看 Java 进程的 GC 情况1$ jstat -gcutil 6476 2.2 监控10次 GC，每隔1秒打印一次1$ jstat -gcutil 6476 1000 10 3 JINFO官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html 作用：实时查看和动态调整虚拟机各项参数。 3.1 查看 Java 程序是否使用串行化收集器1$ jinfo -flag UseSerialGC 3120 3.2 查看虚拟机参数1$ jinfo -flags 3120 3.3 查看系统配置信息1$ jinfo -sysprops 6476 4 JMAP官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html 作用：导出 Java 程序内存映射信息。 4.1 导出 JConsole 内存映射信息1$ jmap -dump:format=b,file=d:\\jconsole.dump 6476 TIPS：可以使用 Eclipse Memory Analyzer 分析导出的文件。 4.2 查看当前存活的对象1$ jmap -histo:live 6588 5 JHAT官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jhat.html 作用：堆分析工具。 5.1 通过 jmap 导出内存映射文件1$ jmap -dump:format=b,file=d:\\app.dump 2848 使用 jhat 分析内存映射文件1$ jhat d:\\app.dump 浏览器访问 http://127.0.0.1:7000/ 6 JSTACK官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html 作用：堆栈跟踪工具。 6.1 查看线程的堆栈跟踪信息1$ jstack -l 2848 7 JAVAP官方文档 https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html 作用：Java 类文件反汇编程序。 参数 说明 p 显示所有类和成员 v 显示尽可能多的信息 7.1 查看 .class 文件反汇编结果1$ javap -verbose D:\\mywork\\wise_workspace\\jvm-test\\bin\\com\\wise\\stack\\InvokeTest.class 8 VisualVM官方文档 https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/index.html 插件 https://visualvm.github.io/pluginscenters.html 作用：JVM 强大的可视化监控工具。 9 JConsole进入jdk1.8.0_45_64bit\\bin目录双击jconsole.exe即可启动监控程序 启动成功界面 9.1 监控示例9.1.1 本地监控示例：监控本地 Spring Boo t程序。 打开监控首页后，选择本地进程（PID为进程号） 为了方便使用，没有开启SSL，选中不安全连接进入监控 成功打开监控界面 9.1.2 远程监控示例：监控远程主机上的 Spring Boot 程序（Spring Boot 程序和 JConsole 不在同一台机器上）。 监控前，要给被监控的程序配置 JVM 参数 JVM 参数如下123456-Djava.rmi.server.hostname=172.22.2.146-Dcom.sun.management.jmxremote=true-Dcom.sun.management.jmxremote.port=12345-Dcom.sun.management.jmxremote.rmi.port=12345-Dcom.sun.management.jmxremote.ssl=false-Dcom.sun.management.jmxremote.authenticate=false 配置完后，启动 Spring Boot 程序。打开 JConsole 监控首页后，选择远程进程（IP 为-Djava.rmi.server.hostname，PORT 为-Dcom.sun.management.jmxremote.port） 成功打开监控界面 10 JMC11 NMT参考博文 https://www.cnblogs.com/helloz/p/11582109.html 12 ASMTools字节码汇编器反汇编器。 http://openjdk.java.net/projects/code-tools/ 13 JOL查看 JVM 中对象的内存分布情况。 http://openjdk.java.net/projects/code-tools/ 14 ASM 字节码框架字节码分析及修改框架。 https://asm.ow2.io/ 15 Arthas官方文档 https://arthas.aliyun.com/ 开源案例 https://github.com/alibaba/arthas/issues?q=label%3Auser-case 15.1 热更新代码51.1.1 在线添加打印日志代码导出源码script1$ jad --source-only service.impl.OauthServiceImpl &gt; /tmp OauthServiceImpl.java 编辑源码script1$ vim /tmp/OauthServiceImpl.java 12345678910111213141516171819202122package service.impl;import dto.OauthTokenDTO;import rpc.feign.OauthFeign;import service.OauthService;import vo.OauthTokenVO;import org.springframework.stereotype.Service;@Servicepublic class OauthServiceImplimplements OauthService &#123; private final OauthFeign oauthFeign; public OauthTokenVO oauthToken(OauthTokenDTO oauthTokenDTO) &#123; // TODO 添加打印日志代码 return this.oauthFeign.oauthToken(oauthTokenDTO); &#125; public OauthServiceImpl(OauthFeign oauthFeign) &#123; this.oauthFeign = oauthFeign; &#125;&#125; 获取类的加载器script1$ sc -d *OauthServiceImpl TIPS：得到类的加载器为org.springframework.boot.loader.LaunchedURLClassLoader 编译修改过的源码script1$ mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/OauthServiceImpl.java -d /tmp 重新加载编译过的代码script1$ redefine /tmp/service/impl/OauthServiceImpl.class 重置热更新的代码（诊断完毕后恢复原状）script1$ reset 15.2 反编译代码15.2.1 版本确认反编译代码（确认某个类部署的版本是否与预期一致）script1$ jad service.impl.UserServiceImpl TIPS：可以确认部署的版本是否是最新的 15.3 确认方法入参与出参15.3.1 入参过滤满足入参 username 为 zhechu 才捕获script1$ watch service.impl.OauthServiceImpl oauthToken \"&#123;params,target,returnObj&#125;\" \"params[0].username==\\\"zhechu\\\"\" -x 2 TIPS：-x 2表示指定输出结果的属性遍历深度为2 15.3.2 耗时过滤满足耗时大于200毫秒才捕获script1$ watch service.impl.OauthServiceImpl oauthToken \"&#123;params,target,returnObj&#125;\" '#cost&gt;200' -x 2 15.3.3 异常过滤异常时才捕获script1$ watch service.impl.OauthServiceImpl oauthToken \"&#123;params,target,throwExp&#125;\" -e TIPS：-e表示在方法异常之后观察 15.4 查看系统信息查看所有的System Properties信息script1$ sysprop 查看所有环境变量script1$ sysenv 查看 jvm 信息script1$ jvm 实时面板script1$ dashboard","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zhechu.github.io/tags/JVM/"},{"name":"工具","slug":"工具","permalink":"https://zhechu.github.io/tags/工具/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"JVM备忘","slug":"JVM备忘及性能调优","date":"2019-04-06T14:28:07.000Z","updated":"2020-11-03T13:04:34.137Z","comments":false,"path":"2019/04/06/JVM备忘及性能调优/","link":"","permalink":"https://zhechu.github.io/2019/04/06/JVM备忘及性能调优/","excerpt":"","text":"JDK-1.8 官方文档 https://docs.oracle.com/javase/8/docs/ 1 内存分布1.1 内存分配策略 优先分配到Eden 大对象直接分配到老年代 长期存活的对象分配到老年代 空间分配担保 动态对象年龄判断 1.2 栈上分配没有逃逸的对象会在栈上分配，而不是在堆分配。JDK-1.8 默认开启逃逸分析。 1.3 查看 JDK 是否开启逃逸分析1$ jinfo -flag DoEscapeAnalysis 7920 2 垃圾回收2.1 判定对象为垃圾对象 引用计数法 可达性分析法 2.2 回收策略 标记-清除算法 复制算法（新生代） 标记-整理算法（老年代） 分代收集算法 2.3 垃圾回收器 Serial：最基本，发展历史最悠久，单线程，桌面应用 Parnew Parallel Cms G1：并行与并发，分代收集，空间整合，可预测的停顿 2.4 打印垃圾回收的日志1-verbose:gc -XX:+PrintGCDetails 2.5 作为 GC Roots 的对象 虚拟机栈 方法区的类属性所引用的对象 方法区中常量所引用的对象 本地方法栈中引用的对象 2.6 局部变量表 Slot 复用当一个变量的 PC 寄存器的值大于 Slot 作用域时，Slot 可以复用。 TIPS：在局部方法中用完对象后，建议置为null，方便GC尽快回收。 2.7 垃圾收集器选型 若应用程序的数据集较小（小于100MB），选择串行收集器 若应用程序运行于单核处理器且没有暂停时间的要求，可以交由 JVM 选择收集器或选择串行收集器 若需优先考虑应用程序峰值性能，没有暂停时间要求或可以接受1秒甚至更长的暂停时间，可以交由 JVM 选择收集器或选择并行收集器 若应用程序响应时间比整体吞吐量更重要，垃圾回收暂停时间必须短于1秒，则可以选择并发收集器 3 类加载3.1 类加载过程 加载 连接 验证 文件格式验证 元数据验证 字节码验证 符号引用验证 准备 解析 初始化 使用 卸载 3.2 类的初始化时机 使用 new 关键字实例化对象 读取或设置一个类的静态字段（被 final 修饰、已在编译期将结果放入常量池的静态字段除外） 调用类的静态方法时 进行反射调用时 初始化类时，发现其父类还未初始化时，会先初始化父类 虚拟机启动时指定执行的主类 3.3 类不被初始化的情况 通过子类引用父类的静态字段，子类不需初始化 通过数组定义引用类 调用类的常量 3.4 加载源 文件 网络 计算生成一个二进制流 数据库 3.5 类加载器 启动类加载器：由C++实现，是虚拟机的一部分，用于加载Java Home下的lib目录下的类 扩展类加载器：加载Java Home下/lib/ext目录中的类 应用程序类加载器：加载用户类路径上所指定的类库 自定义类加载器 高度的灵活性 通过自定义类加载器可以实现热部署 代码加密 3.6 双亲委派模型 3.7 自定义类加载器示例12345678910111213141516171819202122232425262728293031323334353637383940import java.io.InputStream;public class ClassLoaderDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; ClassLoader classLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\"; InputStream ins = getClass().getResourceAsStream(fileName); if (ins == null) &#123; return super.loadClass(name); &#125; try &#123; byte[] buff = new byte[ins.available()]; ins.read(buff); return defineClass(name, buff, 0, buff.length); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(); &#125; &#125; &#125;; Object c = classLoader.loadClass(\"com.wise.loader.ClassLoaderDemo\"); System.out.println(c.getClass()); // java.lang.Class // 不同加载器加载的类比较 System.out.println(c instanceof ClassLoaderDemo); // false &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java8 Base64编码与解码","slug":"Java8-Base64编码与解码","date":"2019-04-06T13:55:13.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2019/04/06/Java8-Base64编码与解码/","link":"","permalink":"https://zhechu.github.io/2019/04/06/Java8-Base64编码与解码/","excerpt":"","text":"示例123456789final String text = \"Base64 finally in Java 8!\";// 编码final String encoded = Base64.getEncoder().encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );System.out.println( encoded );// 解码final String decoded = new String(Base64.getDecoder().decode( encoded ), StandardCharsets.UTF_8 );System.out.println( decoded );","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java8时间和日期","slug":"Java8时间和日期","date":"2019-04-06T13:07:02.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2019/04/06/Java8时间和日期/","link":"","permalink":"https://zhechu.github.io/2019/04/06/Java8时间和日期/","excerpt":"","text":"1 将时间转为指定格式字符串示例123456789// 获取当前时间LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy年MM月dd日 HH:mm:ss\");String format = ldt.format(dtf);// 输出打印System.out.println(format); 2 将字符串转为时间示例1234567// 时间字符串String timeStr = \"2018-07-05 12:24:12\";DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");LocalDateTime parse = LocalDateTime.parse(timeStr, dtf);// 输出打印System.out.println(parse); 3 时间常用 API示例1234567891011121314151617181920212223// 获取当前时间LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);// 通过指定参数获取时间LocalDateTime ld2 = LocalDateTime.of(2016, 11, 21, 10, 10, 10);System.out.println(ld2);// 加年份LocalDateTime ldt3 = ld2.plusYears(20);System.out.println(ldt3);// 减月份LocalDateTime ldt4 = ld2.minusMonths(2);System.out.println(ldt4);// 输出打印System.out.println(ldt.getYear());System.out.println(ldt.getMonthValue());System.out.println(ldt.getDayOfMonth());System.out.println(ldt.getHour());System.out.println(ldt.getMinute());System.out.println(ldt.getSecond()); 4 时间戳常用 API示例1234567891011121314// 获取当前时间（默认使用 UTC 时区）Instant ins = Instant.now();System.out.println(ins);// 偏移 8 小时OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(8));System.out.println(odt);// 按纳秒打印System.out.println(ins.getNano());// 1970-01-01T00:00:00Z 偏移 5 秒Instant ins2 = Instant.ofEpochSecond(5);System.out.println(ins2); 5 计算时间和日期间隔示例123456789101112131415161718Instant ins1 = Instant.now();System.out.println(\"--------------------\");try &#123; Thread.sleep(1000);&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;System.out.println(\"执行所耗费时间为：\" + Duration.between(ins1, Instant.now()).getNano() + \"纳秒\");System.out.println(\"----------------------------------\");// 将相差的年月日分开Period period = Period.between(LocalDate.of(2011, 1, 1), LocalDate.now());System.out.println(period.getYears());System.out.println(period.getMonths());System.out.println(period.getDays()); 6 时间校正器示例1234567891011121314151617181920212223242526272829// 获取当前时间LocalDateTime ldt = LocalDateTime.now();System.out.println(ldt);// 校正为这月的第10天LocalDateTime ldt2 = ldt.withDayOfMonth(10);System.out.println(ldt2);// 校正为下一个周日LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));System.out.println(ldt3);// 自定义：下一个工作日LocalDateTime ldt5 = ldt.with((l) -&gt; &#123; LocalDateTime ldt4 = (LocalDateTime) l; DayOfWeek dow = ldt4.getDayOfWeek(); if (dow.equals(DayOfWeek.FRIDAY)) &#123; return ldt4.plusDays(3); &#125; else if (dow.equals(DayOfWeek.SATURDAY)) &#123; return ldt4.plusDays(2); &#125; else &#123; return ldt4.plusDays(1); &#125;&#125;);// 输出打印System.out.println(ldt5); 7 带时区的时间示例12345678/*Set&lt;String&gt; set = ZoneId.getAvailableZoneIds(); // 获取所有时区set.forEach(System.out::println);*/LocalDateTime ldt = LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\"));System.out.println(ldt);ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(\"US/Pacific\"));System.out.println(zdt);","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java8函数式接口","slug":"Java8函数式接口","date":"2019-04-06T09:56:58.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2019/04/06/Java8函数式接口/","link":"","permalink":"https://zhechu.github.io/2019/04/06/Java8函数式接口/","excerpt":"","text":"1 消费型接口示例123456789//Consumer&lt;T&gt; 消费型接口 :@Testpublic void consumerTest()&#123; happy(10000, (m) -&gt; System.out.println(\"每次消费：\" + m + \"元\"));&#125;public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; 2 供给型接口示例123456789101112131415161718192021//Supplier&lt;T&gt; 供给型接口 :@Testpublic void supplierTest()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125;&#125;//需求：产生指定个数的整数，并放入集合中public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; 3 函数型接口示例1234567891011121314//Function&lt;T, R&gt; 函数型接口：@Testpublic void functionTest()&#123; String newStr = strHandler(\"\\t\\t\\t 呵呵 \", (str) -&gt; str.trim()); System.out.println(newStr); String subStr = strHandler(\"1234567890\", (str) -&gt; str.substring(2, 5)); System.out.println(subStr);&#125;//需求：用于处理字符串public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str);&#125; 4 断言型接口示例1234567891011121314151617181920212223//Predicate&lt;T&gt; 断言型接口：@Testpublic void predicateTest()&#123; List&lt;String&gt; list = Arrays.asList(\"Hello\", \"atguigu\", \"Lambda\", \"www\", \"ok\"); List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3); for (String str : strList) &#123; System.out.println(str); &#125;&#125;//需求：将满足条件的字符串，放入集合中public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList;&#125; 5 自定义函数式接口示例：将 String 转为 Integer 类型123456789101112131415@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;@Testpublic void converterTest() &#123; Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(\"123\"); System.out.println(converted);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java引用类型","slug":"Java引用类型","date":"2019-04-06T07:34:54.000Z","updated":"2020-11-03T13:04:34.156Z","comments":false,"path":"2019/04/06/Java引用类型/","link":"","permalink":"https://zhechu.github.io/2019/04/06/Java引用类型/","excerpt":"","text":"1 引用对象的状态 状态 说明 Active 活动状态，新创建的引用对象都是这个状态，GC 会根据引用对象是否在创建时指定ReferenceQueue参数进行状态转移，若指定了，那么转移到Pending状态，如果没指定，转移到Inactive状态 Pending 待定状态，该状态的引用对象等着被内部线程ReferenceHandler处理（会调用ReferenceQueue.enqueue方法） Enqueued 入队状态，调用ReferenceQueue.enqueued方法后的引用对象处于这个状态中 Inactive 死亡状态，处于该状态的引用对象将被GC自动清理 TIPS：若构造函数中指定了 ReferenceQueue 参数，那么引用对象需要手动进行清理；若构造函数中没有指定 ReferenceQueue 参数，那么 GC 会自动清理引用对象。 2 引用类型2.1 强引用描述： 一般情况下使用的都是强引用，如：Object obj = new Object()的 obj 就是一个强引用。 生命周期： 当内存不足，JVM 宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会回收强引用对象来释放内存。 2.2 软引用生命周期： 垃圾收集器发现只具有软引用的对象并不会立即进行回收，在内存不足前再进行回收。 使用场景： 实现内存敏感的高速缓存。 示例：测试软引用的对象生命周期（运行参数设置为：-Xmx5M）1234567891011121314151617181920212223242526272829import java.lang.ref.SoftReference;public class SoftRefTest &#123; public static class MyObject &#123; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"MyObject's finalize called\"); &#125; @Override public String toString() &#123; return \"I am MyObject\"; &#125; &#125; public static void main(String[] args) &#123; SoftReference&lt;MyObject&gt; softRef = new SoftReference&lt;&gt;(new MyObject()); System.gc(); System.out.println(\"After GC: Soft Get= \"+softRef.get()); System.out.println(\"分配大块内存\"); byte[] b = new byte[3*1024*1170]; System.out.println(\"After new byte[]:Soft Get= \"+softRef.get()); System.gc(); &#125;&#125; 2.3 弱引用生命周期： 垃圾收集器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，其都会被回收。 使用场景： 实现内存敏感的高速缓存。 示例：测试弱引用的对象生命周期12345678910111213141516171819202122232425262728import java.lang.ref.Reference;import java.lang.ref.WeakReference;public class WeakRefTest &#123; public static class MyObject &#123; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(\"MyObject's finalize called\"); &#125; @Override public String toString() &#123; return \"I am MyObject\"; &#125; &#125; public static void main(String[] args) &#123; Reference&lt;MyObject&gt; weakRef = new WeakReference&lt;&gt;(new MyObject()); System.out.println(\"创建的弱引用为：\"+weakRef); System.out.println(\"Before GC: Weak Get= \"+weakRef.get()); System.gc(); // 主动触发 GC System.out.println(\"After GC: Weak Get= \"+weakRef.get()); &#125;&#125; 3.4 虚引用维基百科的解释 https://zh.wikipedia.org/wiki/%E8%99%9A%E5%BC%95%E7%94%A8 测试示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.lang.ref.PhantomReference;import java.lang.ref.Reference;import java.lang.ref.ReferenceQueue;import java.lang.reflect.Field;/** * 虚引用 测试 * @author lingyuwang * */public class PhantomReferenceTest &#123; public static boolean isRun = true; public static void main(String[] args) throws Exception &#123; String abc = new String(\"abc\"); System.out.println(abc.getClass() + \"@\" + abc.hashCode()); final ReferenceQueue&lt;String&gt; referenceQueue = new ReferenceQueue&lt;String&gt;(); new Thread() &#123; public void run() &#123; while (isRun) &#123; Object obj = referenceQueue.poll(); // 若对象不为空，则表示虚引用已入队 if (obj != null) &#123; try &#123; Field rereferent = Reference.class.getDeclaredField(\"referent\"); rereferent.setAccessible(true); Object result = rereferent.get(obj); System.out.println(\"gc will collect：\" + result.getClass() + \"@\" + result.hashCode() + \"\\t\" + (String) result); // 可以在此重新创建对象 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; /*try &#123; referenceQueue.remove(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"对象已入队，其将被回收\");*/ &#125; &#125;.start(); PhantomReference&lt;String&gt; abcWeakRef = new PhantomReference&lt;String&gt;(abc, referenceQueue); abc = null; Thread.sleep(3000); System.gc(); Thread.sleep(3000); isRun = false; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"线程间交换数据","slug":"线程间交换数据","date":"2019-04-06T07:26:13.000Z","updated":"2020-11-03T13:04:34.289Z","comments":false,"path":"2019/04/06/线程间交换数据/","link":"","permalink":"https://zhechu.github.io/2019/04/06/线程间交换数据/","excerpt":"","text":"示例：线程1和线程2交换data1数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.concurrent.Exchanger;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 线程间交换数据 测试 * @author lingyuwang * */public class ExchangerTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); // 交换字符串 final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;(); // 线程1 service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = Thread.currentThread().getName() + \"的数据\"; System.out.println(\"线程\" + Thread.currentThread().getName() + \"正在把数据\" + data1 +\"换出去\"); // 线程随机睡眠 Thread.sleep((long)(Math.random()*5000)); String data2 = exchanger.exchange(data1); System.out.println(\"线程\" + Thread.currentThread().getName() + \"换回的数据为\" + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); // 线程2 service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = Thread.currentThread().getName() + \"的数据\"; System.out.println(\"线程\" + Thread.currentThread().getName() + \"正在把数据\" + data1 +\"换出去\"); // 线程随机睡眠 Thread.sleep((long)(Math.random()*5000)); String data2 = exchanger.exchange(data1); System.out.println(\"线程\" + Thread.currentThread().getName() + \"换回的数据为\" + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"复制文件性能测试","slug":"复制文件性能测试","date":"2019-04-06T07:06:06.000Z","updated":"2020-11-03T13:04:34.285Z","comments":false,"path":"2019/04/06/复制文件性能测试/","link":"","permalink":"https://zhechu.github.io/2019/04/06/复制文件性能测试/","excerpt":"","text":"环境说明 环境 jdk-1.8 1 准备 filecopy.txt 文件在 D 盘准备好 filecopy.txt 文件，内容建议 1M+。 2 测试测试三次的用时及性能排名结果（性能越好，用时越少） 直接使用 FileInputStream 和 FileOutputStream。性能极差，放弃测试 使用 Buffered 包装 Stream。9109ms 8974ms 8888ms 使用 Buffered 包装 Reader 和 Writer。3722ms 3829ms 3751ms 使用 Stream、FileChannel 和 ByteBuffer（堆内存）。2496ms 2575ms 2518ms 使用 RandomAccessFile、FileChannel 和 ByteBuffer（堆内存）。2005ms 2141ms 2122ms 使用 内存映射 和 NIO 结合的方式（堆外内存）。942ms 926ms 936ms 使用 FileChannel#transferTo 方法（基于零拷贝）。230ms 310ms 202ms TIPS：文件复制方法：org.apache.commons.io.FileUtils#copyFile 方法（基于 FileChannel#transferFrom 方法） 和 java.nio.file#copy 方法。 测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.FileReader;import java.io.FileWriter;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;/** * 复制文件 测试 * @author lingyuwang * */public class CopyFileTest &#123; public static void main(String[] args) throws Exception &#123; // 直接使用 FileInputStream 和 FileOutputStream //testIoCopy(); // 性能极差，放弃测试 -&gt; 6 // 使用 Buffered 包装 Stream //testBioCopy(); // 9109ms 8974ms 8888ms -&gt; 5 // 使用 Buffered 包装 Reader 和 Writer //testRbioCopy(); // 3722ms 3829ms 3751ms -&gt; 4 // 使用 Stream、FileChannel 和 ByteBuffer（堆内存） //testNioCopy(); // 2496ms 2575ms 2518ms -&gt; 3 // 使用 RandomAccessFile、FileChannel 和 ByteBuffer（堆内存） //testRanNioCopy(); // 2005ms 2141ms 2122ms -&gt; 2 // 使用 内存映射 和 NIO 结合的方式（堆外内存） //testMapNioCopy(); // 942ms 926ms 936ms -&gt; 1 // 使用 TransferTo 方法（基于零拷贝） testTransferCopy(); // 230ms 310ms 202ms &#125; public static void transferCopyFile(String resource, String destination) throws Exception &#123; try (FileChannel sourceChannel = new FileInputStream(resource).getChannel(); FileChannel targetChannel = new FileOutputStream(destination).getChannel();)&#123; for (long count = sourceChannel.size(); count &gt; 0;) &#123; long transferred = sourceChannel.transferTo(sourceChannel.position(), count, targetChannel); sourceChannel.position(sourceChannel.position() + transferred); count -= transferred; &#125; &#125; &#125; public static void mapNioCopyFile(String resource, String destination) throws Exception &#123; long length=0; RandomAccessFile raf=new RandomAccessFile(resource , \"r\"); FileChannel fcr=raf.getChannel(); length=fcr.size(); //返回要读取文件的映射内存区块 MappedByteBuffer mbb=fcr.map(FileChannel.MapMode.READ_ONLY, 0, length); ByteBuffer buffer=mbb.get(new byte[(int)length]); //要写入的文件 RandomAccessFile raw=new RandomAccessFile(destination, \"rw\"); FileChannel fcw=raw.getChannel(); MappedByteBuffer mbbw=fcw.map(FileChannel.MapMode.READ_WRITE, 0, length); for(int i=0;i&lt;length;i++)&#123; mbbw.put(i,buffer.get(i)); &#125; fcw.close(); fcr.close(); raf.close(); raw.close(); &#125; public static void ranNioCopyFile(String resource, String destination) throws Exception &#123; RandomAccessFile raf=new RandomAccessFile(resource , \"r\"); RandomAccessFile raw=new RandomAccessFile(destination, \"rw\"); // 读文件通道 FileChannel readChannel = raf.getChannel(); // 写文件通道 FileChannel writeChannel = raw.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) &#123; buffer.clear(); int len = readChannel.read(buffer); // 读入数据 if (len == -1) &#123; break; &#125; buffer.flip(); writeChannel.write(buffer); // 写入文件 &#125; readChannel.close(); writeChannel.close(); raw.close(); raf.close(); &#125; public static void nioCopyFile(String resource, String destination) throws Exception &#123; FileInputStream fis = new FileInputStream(resource); FileOutputStream fos = new FileOutputStream(destination); // 读文件通道 FileChannel readChannel = fis.getChannel(); // 写文件通道 FileChannel writeChannel = fos.getChannel(); ByteBuffer buffer = ByteBuffer.allocate(1024); while (true) &#123; buffer.clear(); int len = readChannel.read(buffer); // 读入数据 if (len == -1) &#123; break; &#125; buffer.flip(); writeChannel.write(buffer); // 写入文件 &#125; readChannel.close(); writeChannel.close(); fos.close(); fis.close(); &#125; public static void rbioCopyFile(String resource, String destination) throws Exception &#123; FileReader fr = new FileReader(resource); BufferedReader bf = new BufferedReader(fr); FileWriter fw = new FileWriter(destination); BufferedWriter bw = new BufferedWriter(fw); String temp = null ; while ((temp = bf.readLine()) != null )&#123; bw.write(temp); &#125; bw.close(); bf.close(); &#125; public static void ioCopyFile(String resource, String destination) throws Exception &#123; FileInputStream fis = new FileInputStream(resource); FileOutputStream fos = new FileOutputStream(destination); int count = 0; while ((count = fis.read()) != -1) &#123; fos.write(count); &#125; fos.close(); fis.close(); &#125; public static void bioCopyFile(String resource, String destination) throws Exception &#123; FileInputStream fis = new FileInputStream(resource); BufferedInputStream bis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream(destination); BufferedOutputStream bos = new BufferedOutputStream(fos); int count = 0; while ((count = bis.read()) != -1) &#123; bos.write(count); &#125; bos.close(); bis.close(); &#125; public static void testIoCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; ioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"io耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testRbioCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; rbioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"io耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testBioCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; bioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"io耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testNioCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; nioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"nio耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testRanNioCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; ranNioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"ran nio耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testMapNioCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; mapNioCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"map nio耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125; public static void testTransferCopy() throws Exception &#123; long start = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) &#123; transferCopyFile(\"D://filecopy.txt\", \"D://filecopy1.txt\"); &#125; System.out.println(\"map nio耗时\" + (System.currentTimeMillis() - start) + \"ms\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"IO聚集写分散读","slug":"IO聚集写分散读","date":"2019-04-06T06:46:59.000Z","updated":"2020-11-03T13:04:34.104Z","comments":false,"path":"2019/04/06/IO聚集写分散读/","link":"","permalink":"https://zhechu.github.io/2019/04/06/IO聚集写分散读/","excerpt":"","text":"IO 聚集写与分散读示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import org.junit.Test;/** * 聚集写，分散读 * @author lingyuwang * */public class IOTest &#123; private static final String TPATH = \"D:/temp.txt\"; /** * 聚集写 * @throws Exception */ @Test public void testGatherDate() throws Exception &#123; ByteBuffer courBuffer = ByteBuffer.wrap(\"java性能优化\".getBytes(\"utf-8\")); ByteBuffer autBuffer = ByteBuffer.wrap(\"呵呵\".getBytes(\"utf-8\")); int courLen = courBuffer.limit(); int autLen = autBuffer.limit(); ByteBuffer[] bufs = new ByteBuffer[]&#123;courBuffer,autBuffer&#125;; File file = new File(TPATH); if(!file.exists()) &#123; file.createNewFile(); &#125; FileOutputStream fos = new FileOutputStream(file); FileChannel fc = fos.getChannel(); fc.write(bufs); fos.close(); System.out.println(\"courLen：\" + courLen); System.out.println(\"autLen：\" + autLen); &#125; /** * 分散读 * @throws Exception */ @Test public void testRead() throws Exception &#123; int courLen = 16; // 来自于 courBuffer.limit(); int autLen = 6; // 来自于 autBuffer.limit(); ByteBuffer b1 = ByteBuffer.allocate(courLen); ByteBuffer b2 = ByteBuffer.allocate(autLen); ByteBuffer[] bufs = new ByteBuffer[]&#123;b1,b2&#125;; File file = new File(TPATH); FileInputStream fis = new FileInputStream(file); FileChannel fc = fis.getChannel(); fc.read(bufs); System.out.println(new String(bufs[0].array(),\"utf-8\")); System.out.println(new String(bufs[1].array(),\"utf-8\")); fis.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"IO体系结构","slug":"IO体系结构","date":"2019-04-06T04:35:23.000Z","updated":"2020-11-03T13:04:34.102Z","comments":false,"path":"2019/04/06/IO体系结构/","link":"","permalink":"https://zhechu.github.io/2019/04/06/IO体系结构/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"集合常用API","slug":"集合常用API","date":"2019-04-06T03:59:40.000Z","updated":"2020-11-03T13:04:34.291Z","comments":false,"path":"2019/04/06/集合常用API/","link":"","permalink":"https://zhechu.github.io/2019/04/06/集合常用API/","excerpt":"","text":"1 List1.1 返回只读的空的 List 集合1Collections.emptyList(); 使用场景 函数返回集合需避免直接返回 null，更好的方式是返回只读空集合。既不给函数的调用者造成困扰，又节省内存。 1.2 生成只读的单一元素的 ListAPI1Collections.singletonList(); 使用场景 有且只有一个只读元素的 List 集合。 示例：123List&lt;String&gt; idList = Collections.singletonList(\"1\");idList.forEach(System.out::println); 2 Map2.1 返回只读的 Map 集合1Collections.emptyMap(); 使用场景 函数返回集合需避免直接返回 null，更好的方式是返回只读空集合。既不给函数的调用者造成困扰，又节省内存。 2.2 生成只读的单一元素的 MapAPI1Collections.singletonMap(); 使用场景 有且只有一个只读元素的 Map 集合。 示例：12345Map&lt;String, String&gt; studentMap = Collections.singletonMap(\"id\", \"1\");studentMap.forEach((k, v) -&gt; &#123; System.out.println(k + \"-&gt;\" + v);&#125;); 3 Set3.1 返回只读的 Set 集合1Collections.emptySet(); 使用场景 函数返回集合需避免直接返回 null，更好的方式是返回只读空集合。既不给函数的调用者造成困扰，又节省内存。 3.2 生成只读的单一元素的 SetAPI1Collections.singleton(); 使用场景 有且只有一个只读元素的 Set 集合。 示例：123Set&lt;String&gt; idSet = Collections.singleton(\"1\");idSet.forEach(System.out::println);","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"HashMap遍历","slug":"HashMap遍历","date":"2019-04-06T01:33:20.000Z","updated":"2020-11-03T13:04:34.085Z","comments":false,"path":"2019/04/06/HashMap遍历/","link":"","permalink":"https://zhechu.github.io/2019/04/06/HashMap遍历/","excerpt":"","text":"1 遍历 key 和 value1.1 方案一：通过 Map.keySet 遍历 key 和 value1234567System.out.println(\"---------------------Before JDK8 ------------------------------\");for (String key : map.keySet()) &#123; System.out.println(\"map.get(\" + key + \") = \" + map.get(key));&#125;System.out.println(\"---------------------JDK8 ------------------------------\");map.keySet().forEach(key -&gt; System.out.println(\"map.get(\" + key + \") = \" + map.get(key))); 1.2 方案二：通过 Map.entrySet 使用 Iterator 遍历 key 和 value123456789System.out.println(\"---------------------Before JDK8 ------------------------------\");Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator();while (iterator.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = iterator.next(); System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue());&#125;System.out.println(\"---------------------JDK8 ------------------------------\");map.entrySet().iterator().forEachRemaining(item -&gt; System.out.println(\"key:value=\" + item.getKey() + \":\" + item.getValue())); 1.3 方案三：通过 Map.entrySet 遍历 key 和 value1234567System.out.println(\"---------------------Before JDK8 ------------------------------\");for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue());&#125;System.out.println(\"---------------------JDK8 ------------------------------\");map.entrySet().forEach(entry -&gt; System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue())); 1.4 方案四：通过 k,v 遍历，JDK8 独有的12System.out.println(\"---------------------Only JDK8 ------------------------------\");map.forEach((k, v) -&gt; System.out.println(\"key:value = \" + k + \":\" + v)); 2 只遍历 value通过 Map.values() 遍历所有的 value，但不能遍历 key 1234567System.out.println(\"---------------------Before JDK8 ------------------------------\");for (Object value : map.values()) &#123; System.out.println(\"map.value = \" + value);&#125;System.out.println(\"---------------------JDK8 ------------------------------\");map.values().forEach(System.out::println); // 等价于map.values().forEach(value -&gt; System.out.println(value)); 3 单元测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.junit.Before;import org.junit.Test;/** * 遍历 Map 测试 * @author lingyuwang * */public class ErgodicMapTest &#123; private Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); @Before public void initData() &#123; map.put(\"key1\", \"value1\"); map.put(\"key2\", \"value2\"); map.put(\"key3\", \"value3\"); &#125; /////////////////////////////////遍历 key 和 value///////////////////////////////////// /** * 方案一 * 通过 Map.keySet 遍历 key 和 value */ @Test public void one() &#123; System.out.println(\"---------------------Before JDK8 ------------------------------\"); for (String key : map.keySet()) &#123; System.out.println(\"map.get(\" + key + \") = \" + map.get(key)); &#125; System.out.println(\"---------------------JDK8 ------------------------------\"); map.keySet().forEach(key -&gt; System.out.println(\"map.get(\" + key + \") = \" + map.get(key))); &#125; /** * 方案二 * 通过 Map.entrySet 使用 Iterator 遍历 key 和 value */ @Test public void two() &#123; System.out.println(\"---------------------Before JDK8 ------------------------------\"); Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; iterator = map.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, Object&gt; entry = iterator.next(); System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue()); &#125; System.out.println(\"---------------------JDK8 ------------------------------\"); map.entrySet().iterator().forEachRemaining(item -&gt; System.out.println(\"key:value=\" + item.getKey() + \":\" + item.getValue())); &#125; /** * 方案三 * 通过 Map.entrySet 遍历 key 和 value */ @Test public void three() &#123; System.out.println(\"---------------------Before JDK8 ------------------------------\"); for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123; System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue()); &#125; System.out.println(\"---------------------JDK8 ------------------------------\"); map.entrySet().forEach(entry -&gt; System.out.println(\"key:value = \" + entry.getKey() + \":\" + entry.getValue())); &#125; /** * 方案四 * 通过 k,v 遍历，JDK8 独有的 */ @Test public void four() &#123; System.out.println(\"---------------------Only JDK8 ------------------------------\"); map.forEach((k, v) -&gt; System.out.println(\"key:value = \" + k + \":\" + v)); &#125; /////////////////////////////////遍历 key 和 value///////////////////////////////////// /////////////////////////////////只遍历 value///////////////////////////////////// /** * 通过 Map.values() 遍历所有的 value，但不能遍历 key */ @Test public void onlyValue() &#123; System.out.println(\"---------------------Before JDK8 ------------------------------\"); for (Object value : map.values()) &#123; System.out.println(\"map.value = \" + value); &#125; System.out.println(\"---------------------JDK8 ------------------------------\"); map.values().forEach(System.out::println); // 等价于map.values().forEach(value -&gt; System.out.println(value)); &#125; /////////////////////////////////只遍历 value/////////////////////////////////////&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"CentOS7添加Tomcat服务","slug":"CentOS7添加Tomcat服务","date":"2019-04-05T15:39:23.000Z","updated":"2020-11-03T13:04:34.061Z","comments":false,"path":"2019/04/05/CentOS7添加Tomcat服务/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7添加Tomcat服务/","excerpt":"","text":"Tomcat 添加启动参数1234567$ cd /usr/local/tomcat/bin$ vi setenv.sh#add tomcat pidCATALINA_PID=\"/usr/local/tomcat/tomcat.pid\"#add java optsJAVA_OPTS=\"-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m\"$ chmod +x setenv.sh 添加 tomcat.service1234567891011121314151617$ cd /usr/lib/systemd/system$ vi tomcat.service[Unit]Description=TomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingEnvironment=\"JAVA_HOME=/usr/local/java/jdk1.7.0_80\"PIDFile=/usr/local/tomcat/tomcat.pidExecStart=/usr/local/tomcat/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 配置开机启动1$ systemctl enable tomcat 启动 tomcat1$ systemctl start tomcat 停止 tomcat1$ systemctl stop tomcat 重启 tomcat1$ systemctl restart tomcat","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"CentOS7添加Nginx服务","slug":"CentOS7添加Nginx服务","date":"2019-04-05T15:39:01.000Z","updated":"2020-11-03T13:04:34.061Z","comments":false,"path":"2019/04/05/CentOS7添加Nginx服务/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7添加Nginx服务/","excerpt":"","text":"添加 nginx.service 文件123456789101112131415$ vi /usr/lib/systemd/system/nginx.service[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 配置开机启动1$ systemctl enable nginx 启动 nginx1$ systemctl start nginx 停止 nginx1$ systemctl stop nginx 重启 nginx1$ systemctl restart nginx","categories":[{"name":"Nginx","slug":"Nginx","permalink":"https://zhechu.github.io/categories/Nginx/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Nginx","slug":"Nginx","permalink":"https://zhechu.github.io/categories/Nginx/"}]},{"title":"CentOS7常用命令","slug":"CentOS7常用命令","date":"2019-04-05T13:08:43.000Z","updated":"2020-11-03T13:04:34.057Z","comments":false,"path":"2019/04/05/CentOS7常用命令/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7常用命令/","excerpt":"","text":"1 文件传输安装 rz、sz1$ yum -y install lrzsz 将本地文件上传至服务器1$ rz 将服务器文件传输到本地1$ sz filename.extensioname TIPS：只能操作文件，若是目录，可压缩为zip文件再进行传输。 2 命令行编辑快捷键 按键 说明 CTRL-B 左移光标 CTRL-F 右移光标 CTRL-P 查看上一条命令【等价于上移光标】 CTRL-N 查看下一条命令【等价于下移光标】 CTRL-A 移动光标至行首 CTRL-E 移动光标至行尾 CTRL-W 删除前一个词 CTRL-U 删除从光标至行首的内容 CTRL-K 删除从光标至行尾的内容 CTRL-Y 粘贴已删除的文本【如：粘贴CTRL-U删除的内容】 CTRL-L 清空当前屏幕【等价于clear命令】 3 输入输出重定向输出1$ command &gt; file TIPS：若文件不存在，会创建一个新的文件。若已存在，则先清空文件内容。 将输出追加到文件末尾1$ command &gt;&gt; file 示例：重定向输出到 output.txt12$ echo test &gt; output.txt$ cat output.txt 示例：将标准输出和标准错误输出重定向到同一个文件12$ ls /fff &gt; f 2&gt;&amp;1$ cat f 示例：输出到空设备文件【目的是将输出信息忽略】1$ ls /fff &gt; /dev/null 2&gt;&amp;1 示例：将 echo 的输出追加到 output.txt 末尾123$ echo test &gt; output.txt$ echo \"new content\" &gt;&gt; output.txt$ cat output.txt 示例：多行输出到文件12345678$ cat &lt;&lt;END &gt; multiline_ouput 1.[install lamp] 2.[install lnmp] 3.[install nfs] 4.[install rsync] please input the num that you want:END$ cat multiline_ouput 4 进程管理4.1 查看进程查看系统中所有进程，使用BSD操作系统格式1$ ps auxw 选项 说明 x 显示当前用户运行的所有进程 ax 显示系统当前运行的所有进程，包括其他用户的进程 u 显示更详细的进程信息 w 显示命令的全名，而非仅显示一行以内的内容 显示列 说明 USER 该进程是由哪个用户产生的 PID 进程的ID号 %CPU 该进程占用CPU资源的百分比，占用越高，进程越耗费资源 %MEM 该进程占用物理内存的百分比，占用越高，进程越耗费资源 VSZ 该进程占用虚拟内存的大小，单位KB RSS 该进程占用实际物理内存的大小，单位KB TTY 该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地字符界面终端，tty7是图形终端。pts/0-256代表虚拟终端 STAT 进程状态。常见的状态有：R，运行、S，睡眠、T，停止状态、s，包含子进程、+，位于后台 START 该进程的启动时间 TIME 该进程占用CPU的运算时间 COMMAND 产生此进程的命令名 4.2 查看系统健康状态1$ top [option] 选项 说明 -d 秒数 指定 top 命令每隔几秒更新。默认是3秒 在 top 命令的交互模式可执行的命令 命令 说明 ? 或 h 显示交互模式的帮助 P 以 CPU 使用率排序，默认就是此项 M 以内存的使用率排序 N 以 PID 排序 q 退出 top 显示行显示示例说明1【任务队列信息】12:26:46系统当前时间up 1 day,13:32系统的运行时间，本机已经运行1天13小时32分钟2 users当前登录了两个用户load average: 0.00, 0.00, 0.00系统在之前1分钟，5分钟，15分钟的平均负载。一般认为小于1时，负载较小。若大于1，系统已经出负荷2【进程信息】Tasks: 95 total系统中的进程总数1 running正在运行的进程数94 sleeping睡眠的进程0 stopped正在停止的进程0 zombie僵尸进程。若不是0，需手工检查僵尸进程3【CPU信息】Cpu(s)：0.1%us用户模式占用的CPU百分比0.1%sy系统模式占用的CPU百分比0.0%ni改变过优先级的用户进程占用的CPU百分比99.7%id空闲CPU的CPU百分比0.1%wa等待输入/输出的进程的占用CPU百分比0.0%hi硬中断请求服务占用的CPU百分比0.1%si软中断请求服务占用的CPU百分比0.0%stst(Steal time)虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比4【物理内存信息】Mem：625344k total物理内存的总量，单位KB571504k used已使用的物理内存数量53840k free空闲的物理内存数量，使用的是虚拟机，总共分配了628MB内存，因此只有53MB的空闲内存了65800k buffers作为缓冲的内存数量5【交换分区信息】Swap：524280k total交换分区（虚拟内存）的总大小0k used已使用的交换分区的大小524280k free空闲交换分区的大小409280k cached作为缓存的交换分区的大小 4.3 查看进程树语法1$ pstree [option] 选项 说明 -p 显示进程的PID -u 显示进程的所属用户 TIPS：若没有安装 psmisc，不可用；安装命令，yum -y install psmisc。 4.4 查看可用的进程信号1$ kill -l 4.5 kill 命令1$ kill [-信号代号] pid 信号代号 信号名称 说明 1 SIGHUP 该信号让进程立即关闭，然后重新读取配置文件之后重启 2 SIGINT 程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键 8 GIGFPE 在发生指明的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误 9 SIGKILL 用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。一般用于强制终止进程 14 SIGALRM 时钟定时信号，计算的是实际的时间或时钟时间。alarm函数使用该信号 15 GIGTERM 正常结束进程的信号，kill命令的默认信号。有时若进程已发生问题，这个信号是无法正常终止进程的，才会尝试SIGKILL信号，也就是信号9 18 SIGCONT 该信号可让暂停的进程恢复执行，本信号不能被阻断 19 SIGSTOP 该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断 4.6 pkill 命令1$ pkill [选项] [信号] 进程名 选项 说明 -t 终端号 按照终端号剔出用户 示例：强制杀死从 pts/1 虚拟终端登录的进程1$ pkill -t -9 pts/1 4.7 查看暂停进程1$ jobs 5 压缩&amp;解压gzip压缩1$ gzip [文件] TIPS：压缩后文件格式是 .gz 且不保留原文件 gunzip解压缩.gz的压缩文件1$ gunzip [压缩文件] tar压缩或解压缩【压缩后文件格式是.tar.gz】1$ tar 选项 [-zcf] [压缩后文件名] [目录] 选项 说明 -c 打包 -v 显示详细信息 -f 指定文件名 -z 打包同时压缩 示例：解压缩 filename.tgz 文件1$ tar -zxvf filename.tgz zip压缩文件或目录1$ zip 选项 [-r] [压缩后文件名] [文件或目录] TIPS：-r表示压缩目录，压缩后文件格式是.zip且保留原文件或目录 unzip解压缩.zip的压缩文件1$ unzip [压缩文件] 6 文件处理6.1 du 命令示例：查看某文件夹占用总的空间大小1$ du -h --max-depth=1 /usr/local/ 6.2 find 命令示例：查找/log目录，删除15天以前修改过的文件1$ find /log -type f -name “*.log” -mtime +15 | xargs rm -f 示例：查找工作目录下的文件【递归查找】1$ find . -type f 示例：删除工作目录下的文件【递归删除】12$ find . -type f -name 'stu*'$ find . -type f -name 'stu*' | xargs rm 示例：查找取反1$ find /data -type d -name \"3*\" 1$ find /data -type d ! -name \"3*\" 7 查看系统信息查看操作系统位数1$ uname -m 查看操作系统1$ cat /etc/redhat-release 查看操作系统内核1$ uname -r","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"组装PC机","slug":"组装PC机","date":"2019-04-05T12:58:49.000Z","updated":"2020-11-03T13:04:34.289Z","comments":false,"path":"2019/04/05/组装PC机/","link":"","permalink":"https://zhechu.github.io/2019/04/05/组装PC机/","excerpt":"","text":"table th:nth-of-type(1) { width: 111px; } 组装 PC 机案例 部件 备注 准系统 470 https://item.taobao.com/item.htm?spm=a1z10.5-c.w4002-15703143181.23.wlLvY6&amp;id=538193455656 内存4G 155 https://item.taobao.com/item.htm?spm=a1z10.5-c.w4002-15703143181.46.8oif4V&amp;id=36992571320 i3-3240 298 https://item.taobao.com/item.htm?spm=a1z10.5-c-s.w4002-14256110857.63.Qd0WhI&amp;id=22314619626 硬盘 1t 349 https://item.jd.com/675971.html 键盘 75 https://item.jd.com/584300.html#crumb-wrap 显示器 799 https://item.jd.com/1097155.html#crumb-wrap","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"CentOS7安装JDK","slug":"CentOS7安装JDK","date":"2019-04-05T12:22:45.000Z","updated":"2020-11-03T13:04:34.057Z","comments":false,"path":"2019/04/05/CentOS7安装JDK/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7安装JDK/","excerpt":"","text":"卸载 JDK若已装有 JDK，需先卸载12$ rpm -qa | grep java$ yum -y remove java* 安装 JDK-1.8通过 RPM 方式安装 JDK-1.8123$ rpm -ih jdk-8u11-linux-x64.rpm$ java -version$ javac -version 配置环境变量12345$ vi /etc/profileexport JAVA_HOME=/usr/java/jdk1.8.0_11/export JRE_HOME=/usr/java/jdk1.8.0_11/jreexport PATH=$JAVA_HOME/bin:$PATHexport JVM_OPTS=\"-Xms512m -Xmx1024m\" 使环境变量生效（对于当前 Session 才生效）1$ source /etc/profile 重启主机使环境变量对所有 Session 都生效1$ reboot 安装 JDK-1.7将 RPM 包改为 jdk-8u11-linux-x64.rpm 即可。其它步骤与安装 JDK-1.8 一样。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"Mysql5.7报连接数超数异常的解决方案","slug":"Mysql5-7报连接数超数异常的解决方案","date":"2019-04-05T10:00:45.000Z","updated":"2020-11-03T13:04:34.167Z","comments":false,"path":"2019/04/05/Mysql5-7报连接数超数异常的解决方案/","link":"","permalink":"https://zhechu.github.io/2019/04/05/Mysql5-7报连接数超数异常的解决方案/","excerpt":"","text":"问题描述：Mysql5.7 报连接数超数异常，表示连接已达上限。具体报错信息“Can not connect to MySQL server. Too many connections”。 解决方案：Mysql5.7 默认的连接数上限是 151，可以将此值配到合适的值，如：1000。 由于笔者是使用 Docker 部署的 Mysql5.7 环境，如下皆为 Docker 环境下的解决步骤。Docker 安装 Mysql 请参考 Docker安装Mysql。 解决步骤在主机创建配置文件，加上 max_connections=1000 配置1234567891011121314151617181920212223242526272829303132333435$ mkdir -p /mysql/mysql.conf.d$ vi mysqld.cnf# Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; version 2 of the License.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA## The MySQL Server configuration file.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html[mysqld]pid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockdatadir = /var/lib/mysql#log-error = /var/log/mysql/error.log# By default we only accept connections from localhost#bind-address = 127.0.0.1# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# 配置最大连接数max_connections=1000 TIPS：此配置文件优先级更高。 在启动容器时，挂载配置文件目录1$ docker run --name mysql -v /mysql/mysql.conf.d:/etc/mysql/mysql.conf.d -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3316:3306 -d mysql:5.7 查看连接数配置1mysql&gt; show variables like &apos;max_connections&apos;; 故障排查使用 root 账号可以查看当前所有用户的连接1mysql&gt; show full processlist; 查看状态1mysql&gt; show global status; 查看具体状态，如：Connections1mysql&gt; show global status like '%Connections%'; TIPS：Max_used_connections 表示自服务器启动以来同时使用的最大连接数。可以作为重要参考因素。 各个状态参数的官方解释 https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html 为方便阅读，可以使用 chrome 浏览器打开，并将其转为中文简体阅读模式","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"CentOS7安装Harbor","slug":"CentOS7安装Harbor","date":"2019-04-05T04:03:38.000Z","updated":"2020-11-03T13:04:34.055Z","comments":false,"path":"2019/04/05/CentOS7安装Harbor/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7安装Harbor/","excerpt":"","text":"Docker compose 官方文档 https://docs.docker.com/compose/install/ Harbor 官方文档 https://github.com/goharbor/harbor/blob/release-1.5.0/docs/installation_guide.md 1 准备1.1 禁用 SELINUX禁用 SELINUX（临时和永久禁用同时设置，不需重启主机即可生效）12$ setenforce 0$ sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config 检查是否禁用1$ getenforce TIPS：值为 Permissive 表示许可，SELINUX 不起作用。 1.2 安装 Docker请参考 CentOS7安装Docker 1.3 安装 Docker compose1.3.1 安装方式一1234$ curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose$ chmod +x /usr/local/bin/docker-compose$ ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose$ docker-compose --version 1.3.2 安装方式二1234$ yum -y install epel-release$ yum -y install python-pip$ pip install docker-compose$ docker-compose --version 2 离线安装 Harbor-1.5.3下载离线安装包 123$ yum -y install wget$ cd /opt$ wget https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.5.3.tgz 解压1$ tar -zxvf harbor-offline-installer-v1.5.3.tgz 基本配置12345678910$ cd harbor$ vi harbor.cfg# IPhostname = 192.168.163.41# admin 账号密码harbor_admin_password = 123456# 是否允许注册账号self_registration = off# 数据库密码db_password = 123456 端口映射和修改容器名称12345678910111213$ vi docker-compose.yml registry: container_name: harbor-registry ports: - 5000:5000 redis: image: vmware/redis-photon:v1.5.3 container_name: harbor-redis proxy: container_name: harbor-nginx ports: - 1180:80 - 1443:443 TIPS：建议修改容器名称，以免与其它环境的容器名称冲突。端口映射同理。另外，建议暴露 5000 端口。 修改 Registry 配置模板 token 的地址1234$ vi common/templates/registry/config.ymlauth: token: realm: $public_url:1180/service/token TIPS： $public_url 改为 $public_url:1180。 执行安装12$ ./prepare$ ./install.sh 查看安装结果1$ docker-compose ps 或使用 Docker 命令查看1$ docker ps 浏览器访问http://192.168.163.41:1180 admin/123456 3 Docker 配置 Harbor 仓库地址配置仓库地址12$ vi /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --insecure-registry=192.168.163.41:5000 TIPS：配置仓库地址后才能与其交互。 重启 Docker 和 Harbor 使配置生效1234$ systemctl daemon-reload$ systemctl restart docker.service$ cd /opt/harbor$ docker-compose restart 4 测试上传和下载镜像从官方下载 alpine 用于测试1$ docker pull alpine TIPS：alpine 镜像大小5M左右，适合用于测试。 登录镜像库1$ docker login 192.168.163.41:5000 TIPS：输入账号和密码：admin/123456。 上传镜像12$ docker tag alpine 192.168.163.41:5000/library/alpine$ docker push 192.168.163.41:5000/library/alpine 浏览器访问查看效果 下载镜像1$ docker pull 192.168.163.41:5000/library/alpine","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"VMware安装CentOS7","slug":"VMware安装CentOS7","date":"2019-04-05T02:42:42.000Z","updated":"2020-11-03T13:04:34.221Z","comments":false,"path":"2019/04/05/VMware安装CentOS7/","link":"","permalink":"https://zhechu.github.io/2019/04/05/VMware安装CentOS7/","excerpt":"","text":"1 环境准备 资料 说明 VMware Workstation Pro 12.1.0 桌面虚拟计算机软件 CentOS-7.0-1406-x86_64-DVD.iso 操作系统镜像 1.1 VMware NAT 配置静态 IP启动VMware NAT服务 自定义网络配置，取消 DHCP 2 安装新建虚拟机 下一步 选择稍后安装 选择CentOS 64位 虚拟机命名及存放位置 根据本机实际情况配置处理器 笔者本机内存总共16G，读者根据本机实际情况配置即可 网络配置，使用 NAT，节省内网IP 使用推荐即可 默认即可 根据本机实际情况配置磁盘 默认即可 检查配置 移除打印机，节省资源 移除声卡，节省资源 配置操作系统镜像 完成 启动虚拟机启动 选择安装 CentOS7，然后按回车键。此过程会有点慢，请耐心等待 选择中文简体 安装桌面 分区配置，默认即可，有需求后续再配也是可以的 开始安装 建议配置 root 用户密码，也可以新建新用户。安装过程有点慢，请耐心等待 大概10分钟，重启 接受许可 完成配置 取消Kdump 重启 默认即可 配置账号 默认即可 进入桌面 完成，还差网络未配置 网络配置请参考 VMware克隆VM修改MAC地址和IP","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"CentOS7安装Docker","slug":"CentOS7安装Docker","date":"2019-04-05T01:54:47.000Z","updated":"2020-11-03T13:04:34.054Z","comments":false,"path":"2019/04/05/CentOS7安装Docker/","link":"","permalink":"https://zhechu.github.io/2019/04/05/CentOS7安装Docker/","excerpt":"","text":"1 安装Docker 1.13.11.1 环境准备需翻墙 1.2 卸载 Docker若已安装过 Docker，则需先卸载之前的版本 查询相关安装包1$ yum list installed | grep docker 卸载12$ yum -y remove docker-engine.x86_64$ yum -y remove docker-engine-selinux.noarch 清除镜像和容器文件1$ rm -rf /var/lib/docker 1.3 安装要求内核版本不低于 3.101$ uname -r 添加 Docker 源12345678$ cat &gt;/etc/yum.repos.d/docker.repo &lt;&lt;-EOF[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/7enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF 查看 docker-engine 的所有版本,找到期望版本的精确名字,如：1.13.1-1.el7.centos1$ yum list docker-engine --showduplicates 查看某个docker-engine版本的依赖，如 1.13.1 依赖 docker-engine-selinux， 版本&gt;= 1.13.1-1.el7.centos1$ yum deplist docker-engine-1.13.1-1.el7.centos 由于 docker-engine 会默认安装 docker-engine-selinux 13，而安装 docker-engine-selinux 13 需要将本机的 selinux 升级，所以手动安装 docker-engine-selinux 1312$ yum makecache fast$ yum -y install docker-engine-selinux-1.13.1-1.el7.centos 安装 docker engine1$ yum -y install docker-engine-1.13.1-1.el7.centos 创建 soft link，随机启动1$ systemctl enable docker 启动 docker1$ systemctl start docker 测试 Docker 是否安装成功，查看 Docker 版本1$ docker -v 确认是否启动1$ systemctl status docker 进一步测试，退出当前终端并重新登录，进行如下测试1$ docker run hello-world 1.4 配置加速器1.4.1 官方加速器默认的镜像拉取是从 Docker 官方镜像库下载，速度较慢。配置国内官方镜像加速器，可以提高拉取镜像效率123456$ vi /etc/docker/daemon.json&#123; \"registry-mirrors\": [ \"https://registry.docker-cn.com\" ]&#125; 需重启 Docker 才会生效1$ systemctl restart docker 1.4.2 DaoCloud 加速器DaoCloud 加速器配置文档 https://www.daocloud.io/mirror Docker 官方加速器不是很稳定，推荐使用 DaoCloud 的1$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 需重启 Docker 才会生效1$ systemctl restart docker","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"VMware克隆VM修改MAC地址和IP","slug":"VMware克隆VM修改MAC地址和IP","date":"2019-04-05T01:22:11.000Z","updated":"2020-11-03T13:04:34.221Z","comments":false,"path":"2019/04/05/VMware克隆VM修改MAC地址和IP/","link":"","permalink":"https://zhechu.github.io/2019/04/05/VMware克隆VM修改MAC地址和IP/","excerpt":"","text":"VMware 克隆虚拟机需要修改物理地址和IP地址，否则物理地址会与原虚拟机的冲突，而IP地址笔者使用的是静态分配模式，因此需要手工配置（更有可控性）。 环境 说明 VMware Workstation Pro 12.1.0 桌面虚拟计算机软件 CentOS-7.0-1406-x86_64-DVD.iso 操作系统镜像 查看 MAC 地址1$ ip addr TIPS：此主机的 MAC 地址为：00:0c:29:df:89:b9 修改 MAC 地址12$ vi /etc/sysconfig/network-scripts/ifcfg-eno16777736HWADDR=00:0c:29:df:89:b9 修改 IP 地址12$ vi /etc/sysconfig/network-scripts/ifcfg-eno16777736IPADDR=192.168.163.43 主机重启即可生效1$ reboot 重启后检查配置1$ ip addr","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}],"tags":[{"name":"VM","slug":"VM","permalink":"https://zhechu.github.io/tags/VM/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"https://zhechu.github.io/categories/Linux/"}]},{"title":"Docker安装Nexus3","slug":"Docker安装Nexus3","date":"2019-04-02T15:27:01.000Z","updated":"2020-11-03T13:04:34.063Z","comments":false,"path":"2019/04/02/Docker安装Nexus3/","link":"","permalink":"https://zhechu.github.io/2019/04/02/Docker安装Nexus3/","excerpt":"","text":"Docker Volume 官方文档 https://docs.docker.com/storage/volumes/ Alpine 镜像官方文档 https://hub.docker.com/_/alpine/ Nexus3 镜像文档 https://hub.docker.com/r/sonatype/nexus3 1 准备下载 Alpine 镜像，其容量5M左右，适合用于数据卷备份1$ docker pull alpine:3.9 下载 Nexus3 镜像1$ docker pull sonatype/nexus3:3.15.2 2 启动 Nexus 容器创建数据卷12$ docker volume create --name nexus-data$ docker volume ls | grep nexus-data 启动 Nexus3 容器并使用数据卷 nexus-data1$ docker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3:3.15.2 查看启动的容器1$ docker ps | grep nexus 3 数据备份与恢复3.1 备份创建及进入备份目录1$ mkdir -p /backup &amp;&amp; cd /backup 先停止容器再开始备份（此时就算删掉容器，数据卷也会在，不会跟着容器删除）12$ docker stop nexus$ docker run --rm -v nexus-data:/volume -v $PWD:/backup alpine tar cvf /backup/nexus-data.tar volume 确认是否备份（若目录下有 nexus-data.tar 压缩包，则备份成功）1$ ls /backup 3.2 恢复先删除容器（测试恢复效果）12$ docker rm -f nexus$ docker ps | grep nexus 再删除数据卷（测试恢复效果）12$ docker volume rm nexus-data$ docker volume ls | grep nexus-data 执行恢复1234$ cd /backup$ ls$ docker run --rm -v nexus-data:/volume -v $PWD:/backup alpine tar xf /backup/nexus-data.tar$ docker volume ls | grep nexus-data 重新启动容器，然后登陆 Nexus 查看之前的状态是否改变，若不变，则表示恢复成功12$ docker run -d -p 8081:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3:3.15.2$ docker ps | grep nexus 4 Nexus 权限配置4.1 禁用匿名用户 TIPS：禁用匿名用户后，本地 Maven settings.xml 文件的 servers 节点需要配置用户名和密码才能下载和上传依赖包。具体步骤请参考下文。 4.2 配置开发者账号创建开发者 develop 角色，并分配下载和上传依赖包权限，但没有管理权限 12345nx-component-uploadnx-repository-view-*-*-addnx-repository-view-*-*-browsenx-repository-view-*-*-editnx-repository-view-*-*-read 创建开发者 develop 账号，并分配 develop 角色 本地 Maven settings.xml 需配置访问账号和密码 settings.xml 配置示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;localRepository&gt;D:\\java\\maven\\maven_repository&lt;/localRepository&gt; &lt;interactiveMode&gt;true&lt;/interactiveMode&gt; &lt;offline&gt;false&lt;/offline&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.mortbay.jetty&lt;/pluginGroup&gt; &lt;pluginGroup&gt;org.jenkins-ci.tools&lt;/pluginGroup&gt; &lt;/pluginGroups&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;public&lt;/id&gt; &lt;username&gt;develop&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;develop&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;develop&lt;/username&gt; &lt;password&gt;123456&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-public/&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;/profiles&gt;&lt;/settings&gt; pom.xml 配置示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.hello&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-hello&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 发布构件到Nexus --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;nexus-releases&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;nexus-snapshots&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;!-- maven 仓库配置 --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;public&lt;/name&gt; &lt;url&gt;http://192.168.1.180:8081/repository/maven-public/&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/project&gt; 5 配置阿里云代理仓库创建阿里云代理仓库 将阿里云代理仓库加入 maven-public 组，并放置在成员的第一位（优先级最高）","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Mysql的EXPLAIN语句检查优化器操作","slug":"Mysql的EXPLAIN语句检查优化器操作","date":"2019-04-02T13:20:29.000Z","updated":"2020-11-03T13:04:34.175Z","comments":false,"path":"2019/04/02/Mysql的EXPLAIN语句检查优化器操作/","link":"","permalink":"https://zhechu.github.io/2019/04/02/Mysql的EXPLAIN语句检查优化器操作/","excerpt":"","text":"EXPLAIN 语法 https://dev.mysql.com/doc/refman/5.7/en/explain.html EXPLAIN 文档 https://dev.mysql.com/doc/refman/8.0/en/execution-plan-information.html EXPLAIN 可视化 https://dev.mysql.com/doc/workbench/en/wb-performance-explain.html EXPLAIN 优化查询教程 https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html 1 语法EXPLAIN 语句的两种用途： 了解以不同方式编写出来的查询命令是否会影响到索引的使用。 了解给数据表增加索引对优化器生成高效执行计划的能力会产生什么影响。 语法： EXPLAIN tbl_name 或： EXPLAIN [EXTENDED] SELECT select_options 2 字段含义EXPLAIN 结果字段 字段 说明 id SELECT 标识符 select_type SELECT 类型 table 输出行的表 partitions 匹配的分区 type JOIN 类型 possible_keys 可供选择的索引 key 实际选择的索引 key_len 所选择索引的长度 ref 显示将哪些列或常量与列中指定的索引进行比较 rows 估计要检查的行 filtered 按表条件过滤的行的百分比，最大值为100，表示不会对行进行过滤 Extra 附加信息 select_type 可选值 可选值 说明 SIMPLE 简单 SELECT（不使用 UNION 或子查询） PRIMARY 一个需要 UNION 或者子查询且位于最外层的 SELECT UNION UNION 连接的 SELECT，除了第一个表外，第二个及以后的表 select_type 都是 UNION DEPENDENT UNION 与 UNION 类似，但其受外部查询影响 UNION RESULT UNION 的结果集 SUBQUERY 子查询 DEPENDENT SUBQUERY 与 DEPENDENT UNION 类似，其受外部查询影响 DERIVED 派生表，FROM 子句中出现的子查询 DEPENDENT DERIVED 与 DEPENDENT UNION 类似，其受外部查询影响 MATERIALIZED 被物化的子查询 UNCACHEABLE SUBQUERY 对于外层的主表，子查询不可被缓存，每次都需要计算 UNCACHEABLE UNION UNION 连接的 SELECT，除了第一个表外，第二个及以后的表的子查询不可被缓存 type 可选值，以下列表描述了从最佳类型到最差类型的连接类型 可选值 说明 system 该表只有一行（=系统表）。这是 const 连接类型的特例 const 该表最多只有一个匹配行，在查询开头读取。因为只有一行，所以优化器的其余部分可以将此行中列的值视为常量。 const表非常快，因为它们只读一次。在将 PRIMARY KEY 或 UNIQUE 索引列与常量值进行比较时使用 eq_ref 可用于使用=运算符进行比较的 PRIMARY KEY 或 UNIQUE NOT NULL 的索引列。比较值可以是常量，也可以是使用在此表之前读取的表中的列的表达式。 ref 与 eq_ref 类似，但使用的是非 PRIMARY KEY 或 UNIQUE NOT NULL 的索引 fulltext 使用全文索引进行连接 ref_or_null 与 ref 类似，但包括 null 过滤 index_merge 表示使用了索引合并优化。在这种情况下，key 输出行中的列包含使用的索引列表，并 key_len 包含所用索引的最长关键部分的列表。 unique_subquery 用于 in 形式子查询中使用唯一索引过滤的查询 index_subquery 类似于 unique_subquery，但其使用的是非唯一索引过滤 range 索引范围扫描，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 或者 like等运算符的查询中 index 索引全表扫描。使用覆盖索引或使用索引中的读取执行全表扫描，以按索引顺序查找数据行。但此时 Uses index 没有出现在 Extra 列中 ALL 全表扫描 Extra 常用可选值 可选值 说明 Distinct 使用了 distinct 关键字 No tables used 没有 FROM 子句，或者有 FROM DUAL 子句的查询 Using filesort 排序时无法使用索引。常见于 ORDER BY 和 GROUP BY 子句中 Using index 查询时不需要回表查询，直接通过索引就可以获取查询的数据。也谓之覆盖索引 Using join buffer 优化关联查询的 BNL 和 BKA 特性。主要是减少内表的循环数量以及比较顺序地扫描查询 Using temporary 表示使用了临时表存储中间结果 Using where WHERE 子句用于限制哪些行与下一个表匹配或发送到客户端 FirstMatch 常见于 WHERE 子句含有 IN() 类型且内表的数据量比较大的子查询 3 案例一（联结查询，外键的作用）主表12345678drop table IF EXISTS master;CREATE TABLE `master` ( `id` int(10) unsigned AUTO_INCREMENT NOT NULL , `name` varchar(255) NOT NULL, `value` int(10) unsigned DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 从表12345678drop table IF EXISTS slave;CREATE TABLE `slave` ( `id` int(10) unsigned AUTO_INCREMENT NOT NULL , `name` varchar(255) NOT NULL, `master_id` int(10) unsigned NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY (`name`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据123456789101112131415insert into master(id, name, value) values(1, 'index.html', 1);insert into master(id, name, value) values(2, 'index.asp', 2);insert into master(id, name, value) values(3, 'index.jsp', 3);insert into master(id, name, value) values(4, 'a.html', 4);insert into master(id, name, value) values(5, 'b.asp', 5);insert into master(id, name, value) values(6, 'c.jsp', 6);insert into slave(name, master_id) values('index.html', 1);insert into slave(name, master_id) values('index.asp', 2);insert into slave(name, master_id) values('index.jsp', 3);insert into slave(name, master_id) values('a.html', 1);insert into slave(name, master_id) values('b.asp', 2);insert into slave(name, master_id) values('c.jsp', 3);commit; 测试查询效果（未加外键）1EXPLAIN select m.id m_id, m.name m_name, s.* from master m left join slave s on s.master_id = m.id; slave 添加外键1alter table slave add constraint foreign key(master_id) references master(id) ON DELETE CASCADE; 测试查询效果（已加外键）1EXPLAIN select m.id m_id, m.name m_name, s.* from master m left join slave s on s.master_id = m.id; 4 案例二（联结查询，key 的作用）主表1234567drop table IF EXISTS master;CREATE TABLE `master` ( `id` int(10) unsigned AUTO_INCREMENT NOT NULL , `name` varchar(255) NOT NULL, `value` int(10) unsigned DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 从表1234567drop table IF EXISTS slave;CREATE TABLE `slave` ( `id` int(10) unsigned AUTO_INCREMENT NOT NULL , `name` varchar(255) NOT NULL, `master_id` int(10) unsigned NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据123456789101112131415insert into master(id, name, value) values(1, 'index.html', 1);insert into master(id, name, value) values(2, 'index.asp', 2);insert into master(id, name, value) values(3, 'index.jsp', 3);insert into master(id, name, value) values(4, 'a.html', 4);insert into master(id, name, value) values(5, 'b.asp', 5);insert into master(id, name, value) values(6, 'c.jsp', 6);insert into slave(name, master_id) values('index.html', 1);insert into slave(name, master_id) values('index.asp', 2);insert into slave(name, master_id) values('index.jsp', 3);insert into slave(name, master_id) values('a.html', 1);insert into slave(name, master_id) values('b.asp', 2);insert into slave(name, master_id) values('c.jsp', 3);commit; 测试查询效果（未加 key）1EXPLAIN select m.id m_id, m.name m_name, s.* from master m left join slave s on s.master_id = m.id; slave 添加外键1ALTER TABLE slave ADD KEY (master_id); 测试查询效果（已加外键）1EXPLAIN select m.id m_id, m.name m_name, s.* from master m left join slave s on s.master_id = m.id; 5 可视化执行计划使用MySQL 官方提供的 MySQL Workbench 工具可以可视化执行计划。 可视化执行计划官方示例123456789SELECT CONCAT(customer.last_name, &apos;, &apos;, customer.first_name) AS customer, address.phone, film.titleFROM rentalINNER JOIN customer ON rental.customer_id = customer.customer_idINNER JOIN address ON customer.address_id = address.address_idINNER JOIN inventory ON rental.inventory_id = inventory.inventory_idINNER JOIN film ON inventory.film_id = film.film_idWHERE rental.return_date IS NULLAND rental_date + INTERVAL film.rental_duration DAY &lt; CURRENT_DATE()LIMIT 5; 图形约定 图形 描述 标准框 表示表 圆形框 GROUP 和 SORT 等操作 嵌套框 子查询 菱形框 JOIN 操作 文本约定 文本位置 描述 框下方的标准文本 表（或别名）名称 框下方的粗体文字 使用的键/索引 框右上角的数字 过滤后从表中使用的行数 框左上角的数字 访问该表的相对成本（需要MySQL 5.7或更高版本） 嵌套循环菱形右侧的数字 JOIN 生成的行数 菱形框上方的数字 JOIN的相对成本（需要MySQL 5.7或更高版本） 执行计划图的信息详解 系统名称 颜色 图上的文字 成本分析 SYSTEM 蓝色 Single row: system constant 非常低 CONST 蓝色 Single row: constant 非常低 EQ_REF 绿色 Unique Key Lookup 低 - 优化器找到可以用来检索所需记录的唯一索引。这种效率很高，因为索引搜索直接指向包含所有行数据的页面 REF 绿色 Non-Unique Key Lookup 低中 - 若匹配行数很少，则为低; 随行数增加，成本会越高 FULLTEXT 黄色 Fulltext Index Search 低 - 针对特定搜索要求 REF_OR_NULL 绿色 Key Lookup + Fetch NULL Values 低中 - 若匹配的行数很少; 随行数增加，成本会越高 INDEX_MERGE 绿色 Index Merge 中 - 在查询中查找更好的索引以提高性能 UNIQUE_SUBQUERY 橙色 Unique Key Lookup into table of subquery 低 - 用于高效的子查询处理 INDEX_SUBQUERY 橙色 Non-Unique Key Lookup into table of subquery 低 - 用于高效的子查询处理 RANGE 橙色 Index Range Scan 中 - 部分索引扫描 INDEX 红色 Full Index Scan 高 - 特别是对于索引行数大的情况 ALL 红色 Full Table Scan 非常高 - 对于大表而言非常昂贵，但对小表的影响较小。没有找到表的可用索引，这会强制优化器搜索每一行。这也可能意味着搜索范围太广，索引将毫无用处 UNKNOWN 黑色 unknown 若无法确定匹配，则这是默认值","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://zhechu.github.io/tags/性能优化/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql远程连接报1130的解决方案","slug":"Mysql远程连接报1130的解决方案","date":"2019-04-01T15:09:06.000Z","updated":"2020-11-03T13:04:34.179Z","comments":false,"path":"2019/04/01/Mysql远程连接报1130的解决方案/","link":"","permalink":"https://zhechu.github.io/2019/04/01/Mysql远程连接报1130的解决方案/","excerpt":"","text":"问题描述：Mysql 报 1130 的错误，表示此账号不允许远程主机连接。 解决方案：配置此账号允许远程主机连接即可。 服务器登录数据库 1$ mysql -u root -p 方案一 1234mysql&gt; use mysql;mysql&gt; select host from user where user='root';mysql&gt; update user set host = '%' where user ='root'; -- '%' 表示允许所有主机连接，也可以指定主机mysql&gt; flush privileges; 方案二 12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;mysql&gt; FLUSH PRIVILEGES;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql远程连接报1045的解决方案","slug":"Mysql远程连接报1045的解决方案","date":"2019-04-01T15:00:24.000Z","updated":"2020-11-03T13:04:34.179Z","comments":false,"path":"2019/04/01/Mysql远程连接报1045的解决方案/","link":"","permalink":"https://zhechu.github.io/2019/04/01/Mysql远程连接报1045的解决方案/","excerpt":"","text":"问题描述：Mysql 报 1045 的错误，表示账号或密码错误。 解决方案：修改账号密码即可。参考 Mysql解决Root用户忘记密码问题","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql的事务级别","slug":"Mysql的事务级别","date":"2019-04-01T14:12:20.000Z","updated":"2020-11-03T13:04:34.176Z","comments":false,"path":"2019/04/01/Mysql的事务级别/","link":"","permalink":"https://zhechu.github.io/2019/04/01/Mysql的事务级别/","excerpt":"","text":"table th:nth-of-type(1) { width: 73px; } table th:nth-of-type(2) { width: 58px; } table th:nth-of-type(3) { width: 102px; } table th:nth-of-type(4) { width: 58px; } ACID 性质 说明 原子性 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。 隔离性 多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性 已被提交的事务对数据库的修改应该永久保存在数据库中。 隔离性 表现 说明 脏读 指某个事务所作出的修改在它尚未被提交时就可以被其他事务看到。其他事务会认为数据行已经被修改了，但对数据行作出修改的那个事务还有可能会被回滚，这将导致数据库里的数据发生混乱。 不可重复读 指同一个事务使用同一条 SELECT 语句每次读取到的结果不一样。比如说，如果有一个事务执行了两次同一个 SELECT 语句，但另一个事务在这条 SELECT 语句的两次执行之间修改了一些数据行，就会发生这种问题。 幻读 指某个事务突然看到了一个它以前没有见过数据行。比如说，如果某个事务刚执行完一条 SELECT 语句就有另一个事务插入了一个新数据行，前一个事务再执行同一条 SELECT 语句时就可能多看到一个新的数据行，那就是一个幻影数据行。 隔离级别 隔离级别 脏读 不可重复读 幻读 锁 备注 READ UNCOMMITTED 是 是 是 只加写锁，读不加锁 允许某个事务看到其他事务尚未提交的数据行改动。 READ COMMITTED 否 是 是 读写锁，允许读写并行，但写读不可并行 只允许某个事务看到其他事务已经提交的数据行改动。 REPEATABLE READ 否 否 否 读写锁，只允许读读并行 若某个事务两次执行同一个 SELECT 语句，其结果是可重复的。也就是说，即使有其他事务在同时插入或修改数据行，这个事务所看到的结果也是一样的。 SERIALIZABLE 否 否 否 排它锁 与 REPEATABLE READ 相似，但对事务的隔离更彻底：某个事务正在查看的数据行不允许其他事务修改，直到该事务完成为止。也就是说，若某个事务正在读取某些数据行，在它完成之前，其他事务将无法对这些数据行修改。 Mysql 5.6 的 InnoDB 存储引擎默认使用的隔离级别是 REPEATABLE READ1SELECT @@tx_isolation Mysql 5.6 查看自动提交模式，默认开启12show global variables like 'autocommit';show session variables like 'autocommit'; Mysql 5.6 查看事务刷盘参数，默认为11show global variables like 'innodb_flush_log_at_trx_commit'; 值 说明 0 在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync刷新IO缓存 1 在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，并调用操作系统fsync刷新IO缓存 2 在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，但并不马上调用fsync来刷新IO缓存，而是每秒只做一次磁盘IO缓存刷新操作 Mysql 5.6 查看 binglog 刷盘参数，默认为01show global variables like 'sync_binlog'; Mysql 5.6 安全逻辑备份1mysqldump --single-transaction qiaoku_home tb_video_pool_hot &gt; tb_video_pool_hot.sql Mysql 5.6 查询当前执行时间大于1秒的事务1select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;1 TIPS：在必要时可以使用kill trx_mysql_thread_id断掉风险最大的连接","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql的日期操作","slug":"Mysql的日期操作","date":"2019-03-31T15:39:03.000Z","updated":"2020-11-03T13:04:34.176Z","comments":false,"path":"2019/03/31/Mysql的日期操作/","link":"","permalink":"https://zhechu.github.io/2019/03/31/Mysql的日期操作/","excerpt":"","text":"获取年月日日期中的年、月、日 3 部分可以用函数 YEAR() 、 MONTH() 、 DAYOFMONTH() 分别分离出来 例：获取年、月、日1select YEAR(now()) as year, MONTH(now()) as month, DAYOFMONTH(now()) as day; 当前时间函数1now(); 当前日期函数1curdate(); 日期相减函数1TIMESTAMPDIFF(结算时间，减数，被减数); 例：时间相减，按年、月、日1select TIMESTAMPDIFF(year,'1992-11-08',curdate()) as 'year', TIMESTAMPDIFF(month,'1992-11-08',curdate()) as 'month', TIMESTAMPDIFF(day,'1992-11-08',curdate()) as 'day'; 日期转换为天数1TO_DAYS(日期); 例：将当前时间转为天数1select TO_DAYS(curdate()); 日期加1DATE_ADD(日期, INTERVAL 10 时间单位); 例：加年、月、日1SELECT DATE_ADD('1970-1-1', INTERVAL 10 YEAR) as 'year', DATE_ADD('1970-1-1', INTERVAL 10 MONTH) as 'month', DATE_ADD('1970-1-1', INTERVAL 10 DAY) as 'day'; 日期减1DATE_SUB(日期, INTERVAL 10 时间单位); 例：减年、月、日1SELECT DATE_SUB('1970-1-1', INTERVAL 10 YEAR) as 'year', DATE_SUB('1970-1-1', INTERVAL 10 MONTH) as 'month', DATE_SUB('1970-1-1', INTERVAL 10 DAY) as 'day';","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql的Null排序","slug":"Mysql的NULL排序","date":"2019-03-31T15:31:50.000Z","updated":"2020-11-03T13:04:34.176Z","comments":false,"path":"2019/03/31/Mysql的NULL排序/","link":"","permalink":"https://zhechu.github.io/2019/03/31/Mysql的NULL排序/","excerpt":"","text":"NULL 排序对于包含 NULL 值的数据行，若设定按升序排列，它们将出现在查询结果的开头；若设定按降序排列，它们将出现在查询结果的末尾。若想让包含 NULL 值的数据行必须出现在查询结果的末尾，就必须额外增加一个排序数据列以区分 NULL 值和非 NULL 值。例如，若想按逝世日期的降序对总统们的姓名排序，那么健在（即逝世日期等于 NULL）的总统们的姓名将出现在查询结果的末尾，而若想让后者出现在查询结果的开头，就应该使用一条下面这样的查询命令： 1mysql&gt; SELECT last_name, first_name, death FROM president ORDER BY IF(death IS NULL,0,1), death DESC;","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql解决Root用户忘记密码问题","slug":"Mysql解决Root用户忘记密码问题","date":"2019-03-31T15:14:18.000Z","updated":"2020-11-03T13:04:34.179Z","comments":false,"path":"2019/03/31/Mysql解决Root用户忘记密码问题/","link":"","permalink":"https://zhechu.github.io/2019/03/31/Mysql解决Root用户忘记密码问题/","excerpt":"","text":"停用 Mysql 服务1$ /etc/rc.d/init.d/mysqld stop 对 mysql 数据库（Mysql元数据库）启用安全模式1$ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp; 登入数据库1$ mysql -u root mysql 更新 root 账号的密码12345mysql&gt; use mysql;mysql&gt; UPDATE user SET Password=PASSWORD('123456') where USER='root';mysql&gt; commit;mysql&gt; FLUSH PRIVILEGES;mysql&gt; quit 重启 Mysql 服务1$ /etc/rc.d/init.d/mysqld restart 测试 root 账号是否可以登录1$ mysql -u root –p 123456","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"CentOS7搭建MysqlProxy实现读写分离","slug":"CentOS7搭建MysqlProxy实现读写分离","date":"2019-03-31T14:22:07.000Z","updated":"2020-11-03T13:04:34.060Z","comments":false,"path":"2019/03/31/CentOS7搭建MysqlProxy实现读写分离/","link":"","permalink":"https://zhechu.github.io/2019/03/31/CentOS7搭建MysqlProxy实现读写分离/","excerpt":"","text":"环境要求： 1.主从服务器操作系统版本和位数一致。 2.Mysql版本一致。 TIPS：为了保证稳定性，最好是服务器操作系统和Mysql数据库环境一致。 服务器配置 角色 IP Master 192.168.1.45 Slave 192.168.1.46 Proxy 192.168.1.47 Master(192.168.1.45)服务器配置123456789101112$ vim /etc/my.cnf#主从复制配置innodb_flush_log_at_trx_commit=2sync_binlog=500#需要备份的数据库binlog-do-db=my_test#不需要备份的数据库binlog-ignore-db=mysql#启动二进制文件log-bin=mysql-bin#服务器IDserver-id=1 TIPS：若没有配置binlog-do-db和binlog_ignore_db，表示备份全部数据库。 重启 Mysql 服务1$ systemctl restart mariadb.service 为从 Mysql 创建用户12$ mysql -u root -pmysql&gt; create user 'mastj'@'192.168.1.46' identified by '123456'; 分配主从复制权限1mysql&gt; grant replication slave on *.* to 'mastj'@'192.168.1.46' identified by '123456'; 查看 Master 状态1mysql&gt; show master status; Slave(192.168.1.46)服务器配置123$ vim /etc/my.cnf#服务器IDserver-id=2 重启 Mysql 服务1$ systemctl restart mariadb.service Master 配置12345678$ mysql -u root -pmysql&gt; change master to master_host='192.168.1.45', master_user='mastj', master_password='123456', master_port=3306, master_log_file='mysql-bin.000021', master_log_pos=1692, master_connect_retry=10; 12345678参数详解： master_host:主服务器的IP。 master_user：配置主服务器时建立的用户名 master_password：用户密码 master_port：主服务器mysql端口，如果未曾修改，默认即可。 master_log_file：日志文件名称，填写查看master状态时显示的File master_log_pos:日志位置，填写查看master状态时显示的Position master_connect_retry：重连次数 启动进程1mysql&gt; start slave; 检查主从复制状态1mysql&gt; show slave status\\G TIPS：Slave_IO_Running和Slave_SQL_Running均为Yes，则表示连接正常。若重启，则需检查参数是否一致（主从） Proxy(192.168.1.47)服务器安装 mysql-proxy12$ tar -xvf mysql-proxy-0.8.3-linux-glibc2.3-x86-64bit.tar.gz$ mv mysql-proxy-0.8.3-linux-glibc2.3-x86-64bit /usr/local/mysql-proxy 配置mysql-proxy，创建主配置文件12345678910111213141516171819$ cd /usr/local/mysql-proxy$ mkdir lua #创建脚本存放目录$ mkdir logs #创建日志目录$ cp share/doc/mysql-proxy/rw-splitting.lua ./lua #复制读写分离配置文件$ cp share/doc/mysql-proxy/admin-sql.lua ./lua #复制管理脚本$ vim /etc/mysql-proxy.cnf #创建配置文件[mysql-proxy]user=rootadmin-username=mastjadmin-password=123456proxy-address=192.168.1.47:4000proxy-read-only-backend-addresses=192.168.1.46proxy-backend-addresses=192.168.1.45proxy-lua-script=/usr/local/mysql-proxy/lua/rw-splitting.luaadmin-lua-script=/usr/local/mysql-proxy/lua/admin-sql.lualog-file=/usr/local/mysql-proxy/logs/mysql-proxy.loglog-level=infodaemon=truekeepalive=true 12345678910111213各参数解释： user=root #运行mysql-proxy用户 admin-username=proxy #主从mysql共有的用户 admin-password=123.com #用户的密码 proxy-address=192.168.0.204:4000 #mysql-proxy运行ip和端口，不加端口，默认4040 proxy-read-only-backend-addresses=192.168.0.203 #指定后端从slave读取数据 proxy-backend-addresses=192.168.0.202 #指定后端主master写入数据 proxy-lua-script=/usr/local/mysql-proxy/lua/rw-splitting.lua #指定读写分离配置文件位置 admin-lua-script=/usr/local/mysql-proxy/lua/admin-sql.lua #指定管理脚本 log-file=/usr/local/mysql-proxy/logs/mysql-proxy.log #日志位置 log-level=info #定义log日志级别，由高到低分别有(error|warning|info|message|debug) daemon=true #以守护进程方式运行 keepalive=true #mysql-proxy崩溃时，尝试重启 修改配置文件权限1$ chmod 660 /etc/mysql-proxy.cnf 修改读写分离配置文件12345678$ vim /usr/local/mysql-proxy/lua/rw-splitting.luaif not proxy.global.config.rwsplit then proxy.global.config.rwsplit = &#123; min_idle_connections = 1, #默认超过4个连接数时，才开始读写分离，改为1 max_idle_connections = 1, #默认8，改为1 is_debug = false &#125;end 启动 mysql-proxy12$ /usr/local/mysql-proxy/bin/mysql-proxy --defaults-file=/etc/mysql-proxy.cnf$ netstat -tupln | grep 4000 #已经启动 TIPS：关闭 mysql-proxy 可使用命令：$ killall -9 mysql-proxy 读写分离测试在主服务器创建 proxy 用户用于 mysql-proxy 使用，从服务器也会同步这个操作1mysql&gt; grant all on *.* to 'mastj'@'192.168.1.47' identified by '123456'; 使用客户端连接 mysql-proxy123$ mysql -u mastj -h 192.168.1.47 -P 4000 -pmysql&gt; use my_test;mysql&gt; create table user (number INT(10),name VARCHAR(255)); 关闭同步，分别在 master 和 slave 上插入数据 slave 服务器12mysql&gt; stop slave;mysql&gt; insert into user values(01,'zhangsan'); master 服务器1mysql&gt; insert into user values(02,'lisi'); proxy 服务器1mysql&gt; select * from user; # 从结果可以看到数据是从slave上读取的，并没考虑master节点上的数据。 直接从 proxy 上插入数据1mysql&gt; insert into user values(03,'hehe'); 再次查询1mysql&gt; select * from t; # 结果显示查询数据没有变化，因为proxy上执行insert相当于写入到了master上，而查询的数据是从slave上读取的。 TIPS：各种场景可以自行测试。","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Mysql将多个由逗号分隔的ID列转成由逗号分隔的中文列","slug":"Mysql将多个由逗号分隔的ID列转成由逗号分隔的中文列","date":"2019-03-31T14:11:47.000Z","updated":"2020-11-03T13:04:34.171Z","comments":false,"path":"2019/03/31/Mysql将多个由逗号分隔的ID列转成由逗号分隔的中文列/","link":"","permalink":"https://zhechu.github.io/2019/03/31/Mysql将多个由逗号分隔的ID列转成由逗号分隔的中文列/","excerpt":"","text":"初始化数据12345678910111213141516171819DROP TABLE IF EXISTS `a`;CREATE TABLE `a` ( `id` varchar(255) NOT NULL, `a_id` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `a` VALUES (&apos;1&apos;, &apos;1,2,3&apos;);INSERT INTO `a` VALUES (&apos;2&apos;, &apos;2,4&apos;);DROP TABLE IF EXISTS `b`;CREATE TABLE `b` ( `id` varchar(255) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `b` VALUES (&apos;1&apos;, &apos;李一&apos;);INSERT INTO `b` VALUES (&apos;2&apos;, &apos;刘二&apos;);INSERT INTO `b` VALUES (&apos;3&apos;, &apos;张三&apos;);INSERT INTO `b` VALUES (&apos;4&apos;, &apos;李四&apos;); a 表数据 b 表数据 查询123SELECT a.a_id, GROUP_CONCAT(b.name) AS `名称`FROM a LEFT JOIN b on FIND_IN_SET(b.id, a.a_id)GROUP BY a.a_id 查询结果","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"CentOS7安装MariaDB","slug":"CentOS7安装MariaDB","date":"2019-03-31T13:56:58.000Z","updated":"2020-11-03T13:04:34.057Z","comments":false,"path":"2019/03/31/CentOS7安装MariaDB/","link":"","permalink":"https://zhechu.github.io/2019/03/31/CentOS7安装MariaDB/","excerpt":"","text":"安装 ftp 服务查看是否已安装 vsftpd1$ rpm -qa | grep vsftpd 安装 vsftpd1$ yum -y install vsftpd 设置开机启动1$ chkconfig vsftpd on 操作123$ systemctl status vsftpd.service$ systemctl start vsftpd.service$ systemctl stop vsftpd.service 安装 MariaDB配置 MariaDB 源1234567891011121314151617在原服务器 /var/ftp 下新建 pub2 目录，并下载 MariaDB-10.1.16-centos7-x86_64 的15个 RPM 包到该目录下， 这15个包分别为： galera-25.3.15-1.rhel7.el7.centos.x86_64.rpm jemalloc-3.6.0-1.el7.x86_64.rpm jemalloc-devel-3.6.0-1.el7.x86_64.rpm MariaDB-10.1.16-centos7-x86_64-client.rpm MariaDB-10.1.16-centos7-x86_64-common.rpm MariaDB-10.1.16-centos7-x86_64-compat.rpm MariaDB-10.1.16-centos7-x86_64-connect-engine.rpm MariaDB-10.1.16-centos7-x86_64-cracklib-password-check.rpm MariaDB-10.1.16-centos7-x86_64-devel.rpm MariaDB-10.1.16-centos7-x86_64-gssapi-client.rpm MariaDB-10.1.16-centos7-x86_64-gssapi-server.rpm MariaDB-10.1.16-centos7-x86_64-oqgraph-engine.rpm MariaDB-10.1.16-centos7-x86_64-server.rpm MariaDB-10.1.16-centos7-x86_64-shared.rpm MariaDB-10.1.16-centos7-x86_64-test.rpm 创建 MariaDB 源（创建成功后，pub2目录下会产生 repodata 文件夹）12$ cd /var/ftp$ createrepo pub2 123456$ vim /etc/yum.repos.d/MariaDB.repo[mariadb]name = MariaDBbaseurl = ftp://192.168.1.44/pub2enabled=1gpgcheck=0 开启 MariaDB 源服务器的 ftp 服务1$ service vsftpd status 若为关闭状态，则开启 ftp 服务1$ service vsftpd restart 也可将 ftp 服务设置为开机自动开启1$ chkconfig vsftpd on 安装 MariaDB1234567891011121314151617$ yum install mariadb mariadb-server$ vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.socksymbolic-links=0innodb_rollback_on_timeout=1innodb_lock_wait_timeout=600max_connections=350log-bin=mysql-binbinlog-format = 'ROW'[mysqld_safe]log-error=/var/log/mariadb/mariadb.logpid-file=/var/run/mariadb/mariadb.pid!includedir /etc/my.cnf.d$ systemctl enable mariadb.service$ systemctl restart mariadb.service","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"CentOS7安装Mysql","slug":"CentOS7安装Mysql","date":"2019-03-31T13:50:54.000Z","updated":"2020-11-03T13:04:34.057Z","comments":false,"path":"2019/03/31/CentOS7安装Mysql/","link":"","permalink":"https://zhechu.github.io/2019/03/31/CentOS7安装Mysql/","excerpt":"","text":"下载mysql的repo源1$ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 安装mysql-community-release-el7-5.noarch.rpm包1$ sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 安装mysql1$ sudo yum install mysql mysql-server -y 配置 /etc/my.cnf1234567891011121314151617181920212223242526272829303132$ vi /etc/my.cnf# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html[mysqld]## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Recommended in standard MySQL setupsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysqld_safe]log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 重启服务1$ service mysqld restart 重置密码1$ mysql_secure_installation","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://zhechu.github.io/tags/CentOS7/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Docker安装Mysql","slug":"Docker安装Mysql","date":"2019-03-31T13:45:17.000Z","updated":"2020-11-03T13:04:34.062Z","comments":false,"path":"2019/03/31/Docker安装Mysql/","link":"","permalink":"https://zhechu.github.io/2019/03/31/Docker安装Mysql/","excerpt":"","text":"官方文档 https://hub.docker.com/_/mysql 下载 mysql 镜像1$ docker pull mysql:5.7 启动 mysql 容器1$ docker run --name mysql -v /home/ly/dev_env/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=pass -p 3316:3306 -d mysql:5.7 关闭 mysql 容器1$ docker stop mysql 重启 mysql 容器1$ docker start mysql TIPS：账号和密码是 root/pass","categories":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://zhechu.github.io/tags/Docker/"}],"keywords":[{"name":"Mysql","slug":"Mysql","permalink":"https://zhechu.github.io/categories/Mysql/"}]},{"title":"Java 地铁换乘面试题","slug":"Java-地铁换乘面试题（Floyd算法实现）","date":"2017-12-14T14:36:48.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/14/Java-地铁换乘面试题（Floyd算法实现）/","link":"","permalink":"https://zhechu.github.io/2017/12/14/Java-地铁换乘面试题（Floyd算法实现）/","excerpt":"","text":"地铁换乘： 已知2条地铁线路，其中A为环线，B为东西向线路，线路都是双向的。经过的站点名分别如下，两条线交叉的换乘点用T1、T2表示。编写程序，任意输入两个站点名称，输出乘坐地铁最少需要经过的车站及经过车站的数量（含输入的起点和终点，换乘站点只计算一次）。 地铁线A（环线）经过车站： A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18 地铁线B（直线）经过车站： B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15 最短路径算法 算法 时间复杂度 支持负权 支持负环 单源/多源 Dijkstra O(n^2) -&gt; O(nlogn) 否 否 单源 Floyed O(n^3) 是 否 多源 1 Dijkstra算法实现（通用且效率高）使用标准的 Dijkstra 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import java.util.*;import org.apache.commons.lang.StringUtils;public class DijkstraDemo&#123; /** * 车站 */ static String strA = \"A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18\"; static String strB = \"B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15\"; /** * 车站合并建模 */ static String station = strA + \" \" + strB; static String[] stations = station.split(\" \"); /** * 车站名到其索引值的映射 */ static HashMap&lt;String, Integer&gt; stationMap = new HashMap&lt;String, Integer&gt;(); /** * 标记始点到该索引的节点是否为最短路径 */ static boolean[] flag = new boolean[stations.length]; /** * 初始点到该点的距离 */ static int[] distance = new int[stations.length]; /** * 图的矩阵表示 */ static int[][] arr = null; /** * 图中始点到每个节点间的路径表示，如：若始点为A1，终点为A2，则路径为 arrRoute[1] = \"A1,A2\"; */ static String[] arrRoute = new String[stations.length]; /** * 表示无穷大 */ private static final int INF = Integer.MAX_VALUE; /* 地铁换乘（参考答案，Floyd算法实现） 已知2条地铁线路，其中A为环线，B为东西向线路，线路都是双向的。 经过的站点名分别如下，两条线交叉的换乘点用T1、T2表示。编写程 序，任意输入两个站点名称，输出乘坐地铁最少需要经过的车站数量 （含输入的起点和终点，换乘站点只计算一次）。 地铁线A（环线）经过车站： A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18 地铁线B（直线）经过车站： B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15 */ public static void main(String args[])&#123; // 接收输入的参数 System.out.println(\"请输入\\\"始发站\\\"（空格）\\\"终到站\\\"(例如：A1 B4（回车结束）)：\"); Scanner sc = new Scanner(System.in); String[] strArray = sc.nextLine().split(\" \"); String x = strArray[0].toUpperCase(); String y = strArray[1].toUpperCase(); System.out.println(\"go:\"+x); System.out.println(\"to:\"+y); sc.close(); // 初始化 init(x); // Dijkstra算法求解 dijkstra(); System.out.println(\"经过的最少车站数：\"+(distance[stationMap.get(y)] + 1)); // 处理A路线与B路线重复的车站T1和T2 List&lt;String&gt; resultList = new ArrayList&lt;&gt;(); List&lt;String&gt; routeList = Arrays.asList(arrRoute[stationMap.get(y)].split(\",\")); int size = routeList.size() - 1; int k = 0; for (; k &lt; size; k++) &#123; if (!routeList.get(k).equals(routeList.get(k + 1))) &#123; resultList.add(routeList.get(k)); &#125; &#125; resultList.add(routeList.get(k)); System.out.println(\"经过的车站：\"+StringUtils.join(resultList, \",\")); &#125; /** * Dijkstra算法求解 */ private static void dijkstra() &#123; // 每次找出始点到其它节点的最短路径 int length = stations.length; int k = 0; for(int i=1; i&lt;length; i++)&#123; int min = INF; // 寻找最短路径 for(int j=0; j&lt;length; j++)&#123; if(flag[j] == false &amp;&amp; distance[j] &lt; min)&#123; k = j; min = distance[j]; &#125; &#125; flag[k] = true; // 更新图中始点到其它节点的距离 for(int j=0; j&lt;length; j++)&#123; int len = arr[k][j] == INF ? INF : min + arr[k][j]; if(flag[j] == false &amp;&amp; len &lt; distance[j])&#123; distance[j] = len; // 更新路径（由于后面节点的路径还未计算，所以，k-&gt;j的路径未经过其它节点） arrRoute[j] = arrRoute[k] + \",\" + stations[j]; &#125; &#125; &#125; &#125; /** * 初始化 * @param startNode 始点 */ private static void init(String startNode) &#123; int length = stations.length; arr = new int[length][length]; for(int i=0; i&lt;stations.length; i++) &#123; stationMap.put(stations[i], i); &#125; for(int i=0; i&lt;length; i++)&#123; for(int j=0; j&lt;length; j++) &#123; if(i == j) &#123; arr[i][j] = 0; &#125; else &#123; arr[i][j] = 1000; // 表示无穷大 &#125; &#125; &#125; for(int i=0; i&lt;length-1; i++) &#123; arr[i][i+1] = 1; arr[i+1][i] = 1; &#125; arr[9][25] = 0; arr[14][31] = 0; arr[25][9] = 0; arr[31][14] = 0; arr[stationMap.get(\"A18\")][stationMap.get(\"B1\")] = 1000; arr[stationMap.get(\"B1\")][stationMap.get(\"A18\")] = 1000; arr[stationMap.get(\"A1\").intValue()][stationMap.get(\"A18\").intValue()] = 1; arr[stationMap.get(\"A18\").intValue()][stationMap.get(\"A1\").intValue()] = 1; // 始点索引 int startNodeIndex = stationMap.get(startNode); for(int i=0; i&lt;length; i++)&#123; flag[i] = false; // 初始化距离 distance[i] = arr[startNodeIndex][i]; // 初始化路径 arrRoute[i] = stations[startNodeIndex] + \",\" + stations[i]; &#125; // 对始点本身进行初始化 flag[startNodeIndex] = true; distance[startNodeIndex] = 0; &#125;&#125; 2 Floyed算法实现2.1 标准算法实现（通用）使用标准的 Floyed 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.util.*;import org.apache.commons.lang.StringUtils;public class FloydDemo&#123; /** * 车站 */ static String strA = \"A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18\"; static String strB = \"B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15\"; /** * 车站合并建模 */ static String station = strA + \" \" + strB; static String[] stations = station.split(\" \"); /** * 车站名到其索引值的映射 */ static HashMap&lt;String, Integer&gt; stationMap = new HashMap&lt;String, Integer&gt;(); /** * 图的矩阵表示 */ static int[][] arr = null; /** * 图中每个节点间的路径表示，如：A1到A2节点的路径为 arrRoute[0][1] = \"A1,A2\"; */ static String[][] arrRoute = null; /* 地铁换乘（参考答案，Floyd算法实现） 已知2条地铁线路，其中A为环线，B为东西向线路，线路都是双向的。 经过的站点名分别如下，两条线交叉的换乘点用T1、T2表示。编写程 序，任意输入两个站点名称，输出乘坐地铁最少需要经过的车站数量 （含输入的起点和终点，换乘站点只计算一次）。 地铁线A（环线）经过车站： A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18 地铁线B（直线）经过车站： B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15 */ public static void main(String args[])&#123; // 初始化 init(); // Floyed算法求解 floyed(); // 接收输入的参数 System.out.println(\"请输入\\\"始发站\\\"（空格）\\\"终到站\\\"(例如：A1 B4（回车结束）)：\"); Scanner sc = new Scanner(System.in); String[] strArray = sc.nextLine().split(\" \"); String x = strArray[0].toUpperCase(); String y = strArray[1].toUpperCase(); System.out.println(\"go:\"+x); System.out.println(\"to:\"+y); sc.close(); int i = stationMap.get(x); int j = stationMap.get(y); System.out.println(\"经过的最少车站数：\"+(arr[i][j] + 1)); // 处理A路线与B路线重复的车站T1和T2 List&lt;String&gt; resultList = duplicateRemoval(i, j); System.out.println(\"经过的车站：\"+StringUtils.join(resultList, \",\")); &#125; /** * 处理A路线与B路线重复的车站T1和T2 * @param i * @param j * @return */ private static List&lt;String&gt; duplicateRemoval(int i, int j) &#123; List&lt;String&gt; resultList = new ArrayList&lt;&gt;(); List&lt;String&gt; routeList = Arrays.asList(arrRoute[i][j].split(\",\")); int size = routeList.size() - 1; int k = 0; for (; k &lt; size; k++) &#123; if (!routeList.get(k).equals(routeList.get(k + 1))) &#123; resultList.add(routeList.get(k)); &#125; &#125; resultList.add(routeList.get(k)); return resultList; &#125; /** * Floyed算法求解 */ private static void floyed() &#123; int length = stations.length; for(int k=0; k&lt;length; k++)&#123; for(int i=0; i&lt;length; i++) &#123; for(int j=0; j&lt;length; j++) &#123; if((arr[i][k] + arr[k][j]) &lt; arr[i][j]) &#123; arr[i][j] = arr[i][k] + arr[k][j]; // 更新路径 arrRoute[i][j] = arrRoute[i][k].substring(0, arrRoute[i][k].lastIndexOf(\",\")) + \",\" + arrRoute[k][j]; &#125; &#125; &#125; &#125; &#125; /** * 初始化 * @return */ private static void init() &#123; int length = stations.length; arr = new int[length][length]; arrRoute = new String[length][length]; for(int i=0; i&lt;stations.length; i++) &#123; stationMap.put(stations[i], i); &#125; for(int i=0; i&lt;length; i++)&#123; for(int j=0; j&lt;length; j++) &#123; if(i == j) &#123; arr[i][j] = 0; &#125; else &#123; arr[i][j] = 1000; // 表示无穷大 &#125; // 初始化路径 arrRoute[i][j] = stations[i] + \",\" + stations[j]; &#125; &#125; for(int i=0; i&lt;length-1; i++) &#123; arr[i][i+1] = 1; arr[i+1][i] = 1; &#125; arr[9][25] = 0; arr[14][31] = 0; arr[25][9] = 0; arr[31][14] = 0; arr[stationMap.get(\"A18\")][stationMap.get(\"B1\")] = 1000; arr[stationMap.get(\"B1\")][stationMap.get(\"A18\")] = 1000; arr[stationMap.get(\"A1\").intValue()][stationMap.get(\"A18\").intValue()] = 1; arr[stationMap.get(\"A18\").intValue()][stationMap.get(\"A1\").intValue()] = 1; &#125;&#125; 2.2 非标准算法实现（效率高）结合线路自身特点，局部使用 Floyed 算法实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import java.util.Date;import java.util.Scanner;public class MainClass &#123; static String strA = \"A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18\"; static String strB = \"B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15\"; static String[] SA = strA.split(\" \"); static String[] SB = strB.split(\" \"); static int LENSA = SA.length; static int LENSB = SB.length; static int indexT1SA = getIndexofSA(\"T1\"); //\"T1\"车站在A线路上的数组下标 static int indexT1SB = getIndexofSB(\"T1\"); //\"T1\"车站在B线路上的数组下标 static int indexT2SA = getIndexofSA(\"T2\"); //\"T2\"车站在A线路上的数组下标 static int indexT2SB = getIndexofSB(\"T2\"); //\"T2\"车站在B线路上的数组下标 /* 地铁换乘（参考答案，Floyd算法实现） 已知2条地铁线路，其中A为环线，B为东西向线路，线路都是双向的。 经过的站点名分别如下，两条线交叉的换乘点用T1、T2表示。编写程 序，任意输入两个站点名称，输出乘坐地铁最少需要经过的车站数量 （含输入的起点和终点，换乘站点只计算一次）。 地铁线A（环线）经过车站： A1 A2 A3 A4 A5 A6 A7 A8 A9 T1 A10 A11 A12 A13 T2 A14 A15 A16 A17 A18 地铁线B（直线）经过车站： B1 B2 B3 B4 B5 T1 B6 B7 B8 B9 B10 T2 B11 B12 B13 B14 B15 */ public static void main(String[] args) &#123; int step = 0; System.out.println(\"请输入\\\"始发站\\\"（空格）\\\"终到站\\\"(例如：A1 B4（回车结束）)：\"); Scanner sc = new Scanner(System.in); String[] strArray = sc.nextLine().split(\" \"); String x = strArray[0].toUpperCase(); String y = strArray[1].toUpperCase(); System.out.println(\"go:\"+x); System.out.println(\"to:\"+y); sc.close(); Date startDate = new Date(); step = getMinStep(x, y) + 1; System.out.println(\"经过的最少车站数：\"+step); Date endDate = new Date(); System.out.println(\"耗时：\"+(endDate.getTime()-startDate.getTime())/1000+\"秒\"); &#125; private static int getMinStep(String x, String y) &#123; if(('A' != x.charAt(0))&amp;&amp;('A' != y.charAt(0)))&#123; //在地铁B线路上 return min(stepBtoB(x, y), stepT1orT2(x, y)); &#125; else if(('B' != x.charAt(0))&amp;&amp;('B' != y.charAt(0)))&#123; //在地铁A线路上 return min(stepAtoA(x, y), stepT1orT2(x, y)); &#125; else&#123; //A到B，或者B到A return stepT1orT2(x, y); &#125; &#125; //从T1或者T2站换乘，s1到s2的最短距离 private static int stepT1orT2(String s1, String s2) &#123; int lenXtoT1 = steptoT1(s1); int lenXtoT2 = steptoT2(s1); int lenYtoT1 = steptoT1(s2); int lenYtoT2 = steptoT2(s2); int lineT1 = lenXtoT1 + lenYtoT1; int lineT2 = lenXtoT2 + lenYtoT2; return min(lineT1, lineT2); &#125; //到T1的最短距离 private static int steptoT1(String s) &#123; if(\"T1\".equals(s))&#123; return 0; &#125; else if(\"T2\".equals(s))&#123; return min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\")); &#125; else if('A' == s.charAt(0)) /*s是A线路上的车站*/&#123; //找到s站在SA的下标 int indexSSA = getIndexofSA(s); //不换乘，s到T1最短路程 int line1 = min(mod(indexSSA, indexT1SA), LENSA-mod(indexSSA, indexT1SA)); //不换乘，s到T2最短路程 int line2 = min(mod(indexSSA, indexT2SA), LENSA-mod(indexSSA, indexT2SA)); return min(line1, line2+min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\"))); &#125; else if('B' == s.charAt(0)) /*s是B线路上的车站*/&#123; //找到s站在SB的下标 int indexSSB = getIndexofSB(s); //不换乘，s到T1最短路程 int line1 = mod(indexSSB, indexT1SB); //不换乘，s到T2最短路程 int line2 = mod(indexSSB, indexT2SB); return min(line1, line2+min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\"))); &#125; else&#123; System.out.println(\"车站名有误，请检查！\"); return -1; &#125; &#125; //s到T2的最短距离 private static int steptoT2(String s) &#123; if(\"T2\".equals(s)) &#123; return 0; &#125; else if(\"T1\".equals(s))&#123; return min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\")); &#125; else if('A' == s.charAt(0)) /*s是A线路上的车站*/&#123; //找到s站在SA的下标 int indexSSA = getIndexofSA(s); //不换乘，s到T1最短路程 int line1 = min(mod(indexSSA, indexT1SA), LENSA-mod(indexSSA, indexT1SA)); //不换乘，s到T2最短路程 int line2 = min(mod(indexSSA, indexT2SA), LENSA-mod(indexSSA, indexT2SA)); return min(line2, line1+min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\"))); &#125; else if('B' == s.charAt(0)) /*s是B线路上的车站*/&#123; //找到s站在SB的下标 int indexSSB = getIndexofSB(s); //不换乘，s到T1最短路程 int line1 = mod(indexSSB, indexT1SB); //不换乘，s到T2最短路程 int line2 = mod(indexSSB, indexT2SB); return min(line2, line1+min(stepAtoA(\"T1\", \"T2\"), stepBtoB(\"T1\", \"T2\"))); &#125; else&#123; System.out.println(\"车站名有误，请检查！\"); return -1; &#125; &#125; //A到A，不换乘 private static int stepAtoA(String s1, String s2) &#123; if(('B' == s1.charAt(0))||('B' == s2.charAt(0)))&#123; System.out.println(\"输入不是A线路上的站点，请检查！\"); return -1; &#125; //找到s1站，在A线路上的数组下标 int indexS1SA = getIndexofSA(s1); //找到s2站，在A线路上的数组下标 int indexS2SA = getIndexofSA(s2); //不换乘，s1到s2的最短距离 return min(mod(indexS1SA, indexS2SA), LENSA-mod(indexS1SA, indexS2SA)); &#125; //B到B，不换乘 private static int stepBtoB(String s1, String s2) &#123; if(('A' == s1.charAt(0))||('A' == s2.charAt(0)))&#123; System.out.println(\"输入不是B线路上的站点，请检查！\"); return -1; &#125; //找到s1站，在B线路上的数组下标 int indexS1SB = getIndexofSB(s1); //找到s2站，在B线路上的数组下标 int indexS2SB = getIndexofSB(s2); //不换乘，s1到s2的最短距离 return mod(indexS1SB, indexS2SB); &#125; private static int min(int a, int b)&#123; return a&lt;b?a:b; &#125; private static int getIndexofSA(String str)&#123; for(int index = 0; index &lt; LENSA; index++)&#123; if(str.equals(SA[index]))&#123; return index; &#125; &#125; return -1; &#125; private static int getIndexofSB(String str)&#123; for(int index = 0; index &lt; LENSB; index++)&#123; if(str.equals(SB[index]))&#123; return index; &#125; &#125; return -1; &#125; private static int mod(int a, int b) &#123; if(a &lt; b)&#123; return b-a; &#125; else&#123; return a-b; &#125; &#125;&#125; TIPS：由于此种方式结合了线路自身的特点，可以作为参考；但，不通用，因此不推荐。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zhechu.github.io/tags/算法/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 模拟银行取号排队系统","slug":"Java-模拟银行拿号排队系统","date":"2017-12-14T14:17:41.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/14/Java-模拟银行拿号排队系统/","link":"","permalink":"https://zhechu.github.io/2017/12/14/Java-模拟银行拿号排队系统/","excerpt":"","text":"利用 Java 多线程模拟银行取号排队系统。 代码地址：https://github.com/zhechu/bank-queue-system-demo 程序入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;/** * 入口类 * @author lingyuwang * */public class MainClass &#123; public static void main(String[] args) &#123; //产生4个普通窗口 for(int i=1;i&lt;5;i++)&#123; ServiceWindow commonWindow = new ServiceWindow(); commonWindow.setNumber(i); commonWindow.setType(CustomerType.COMMON); commonWindow.start(); &#125; //产生1个快速窗口 ServiceWindow expressWindow = new ServiceWindow(); expressWindow.setNumber(5); expressWindow.setType(CustomerType.EXPRESS); expressWindow.start(); //产生1个VIP窗口 ServiceWindow vipWindow = new ServiceWindow(); vipWindow.setNumber(6); vipWindow.setType(CustomerType.VIP); vipWindow.start(); //普通客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable()&#123; public void run()&#123; Integer serviceNumber = NumberMachine.getInstance().getCommonManager().generateNewNumber(); /** * 采用logger方式，无法看到直观的运行效果，因为logger.log方法内部并不是直接把内容打印出出来， * 而是交给内部的一个线程去处理，所以，打印出来的结果在时间顺序上看起来很混乱。 */ //logger.info(\"第\" + serviceNumber + \"号普通客户正在等待服务！\"); System.out.println(\"第\" + serviceNumber + \"号普通客户正在等待服务！\"); &#125; &#125;, 0, Constants.COMMON_CUSTOMER_INTERVAL_TIME, TimeUnit.SECONDS); //快速客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable()&#123; public void run()&#123; Integer serviceNumber = NumberMachine.getInstance().getExpressManager().generateNewNumber(); System.out.println(\"第\" + serviceNumber + \"号快速客户正在等待服务！\"); &#125; &#125;, 0, Constants.COMMON_CUSTOMER_INTERVAL_TIME * 2, TimeUnit.SECONDS); //VIP客户拿号 Executors.newScheduledThreadPool(1).scheduleAtFixedRate( new Runnable()&#123; public void run()&#123; Integer serviceNumber = NumberMachine.getInstance().getVipManager().generateNewNumber(); System.out.println(\"第\" + serviceNumber + \"号VIP客户正在等待服务！\"); &#125; &#125;, 0, Constants.COMMON_CUSTOMER_INTERVAL_TIME * 6, TimeUnit.SECONDS); &#125;&#125; 服务窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.util.Random;import java.util.concurrent.Executors;/** * 没有把VIP窗口和快速窗口做成子类，是因为实际业务中的普通窗口可以随时被设置为VIP窗口和快速窗口。 * */public class ServiceWindow &#123; private CustomerType type = CustomerType.COMMON; private int number = 1; public CustomerType getType() &#123; return type; &#125; public void setType(CustomerType type) &#123; this.type = type; &#125; public void setNumber(int number)&#123; this.number = number; &#125; public void start()&#123; Executors.newSingleThreadExecutor().execute( new Runnable()&#123; public void run()&#123; //下面这种写法的运行效率低，最好是把while放在case下面 /* while(true)&#123; switch(type)&#123; case COMMON: commonService(); break; case EXPRESS: expressService(); break; case VIP: vipService(); break; &#125; &#125; */ switch(type)&#123; case COMMON: while(true) commonService(); case EXPRESS: while(true) expressService(); case VIP: while(true) vipService(); &#125; &#125; &#125; ); &#125; private void commonService()&#123; String windowName = \"第\" + number + \"号\" + type + \"窗口\"; System.out.println(windowName + \"开始获取普通任务!\"); Integer serviceNumber = NumberMachine.getInstance().getCommonManager().fetchNumber(); if(serviceNumber != null )&#123; System.out.println(windowName + \"开始为第\" + serviceNumber + \"号普通客户服务\"); int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME; int serviceTime = new Random().nextInt(maxRandom)+1000 + Constants.MIN_SERVICE_TIME; try &#123; Thread.sleep(serviceTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(windowName + \"完成为第\" + serviceNumber + \"号普通客户服务，总共耗时\" + serviceTime/1000 + \"秒\"); &#125;else&#123; System.out.println(windowName + \"没有取到普通任务，正在空闲一秒\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void expressService()&#123; Integer serviceNumber = NumberMachine.getInstance().getExpressManager().fetchNumber(); String windowName = \"第\" + number + \"号\" + type + \"窗口\"; System.out.println(windowName + \"开始获取快速任务!\"); if(serviceNumber !=null)&#123; System.out.println(windowName + \"开始为第\" + serviceNumber + \"号快速客户服务\"); int serviceTime = Constants.MIN_SERVICE_TIME; try &#123; Thread.sleep(serviceTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(windowName + \"完成为第\" + serviceNumber + \"号快速客户服务，总共耗时\" + serviceTime/1000 + \"秒\"); &#125;else&#123; System.out.println(windowName + \"没有取到快速任务！\"); commonService(); &#125; &#125; private void vipService()&#123; Integer serviceNumber = NumberMachine.getInstance().getVipManager().fetchNumber(); String windowName = \"第\" + number + \"号\" + type + \"窗口\"; System.out.println(windowName + \"开始获取VIP任务!\"); if(serviceNumber !=null)&#123; System.out.println(windowName + \"开始为第\" + serviceNumber + \"号VIP客户服务\"); int maxRandom = Constants.MAX_SERVICE_TIME - Constants.MIN_SERVICE_TIME; int serviceTime = new Random().nextInt(maxRandom)+1000 + Constants.MIN_SERVICE_TIME; try &#123; Thread.sleep(serviceTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(windowName + \"完成为第\" + serviceNumber + \"号VIP客户服务，总共耗时\" + serviceTime/1000 + \"秒\"); &#125;else&#123; System.out.println(windowName + \"没有取到VIP任务！\"); commonService(); &#125; &#125;&#125; 客户类型123456789101112131415161718192021/** * 客户类型 */public enum CustomerType &#123; COMMON,EXPRESS,VIP; public String toString()&#123; String name = null; switch(this)&#123; case COMMON: name = \"普通\"; break; case EXPRESS: name = \"快速\"; break; case VIP: name = name(); break; &#125; return name; &#125;&#125; 客户取号管理器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 客户取号管理器 */public class NumberMachine &#123; /** * 单例的构造函数必须私有化 */ private NumberMachine()&#123;&#125; /** * 单例 */ private static NumberMachine instance = new NumberMachine(); /** * 获取单例客户取号管理器 * @return NumberMachine */ public static NumberMachine getInstance()&#123; return instance; &#125; /** * 普通客户的生成器 */ private NumberManager commonManager = new NumberManager(); /** * 快速客户的生成器 */ private NumberManager expressManager = new NumberManager(); /** * VIP客户的生成器 */ private NumberManager vipManager = new NumberManager(); /** * 获取普通客户的生成器 */ public NumberManager getCommonManager() &#123; return commonManager; &#125; /** * 获取快速客户的生成器 */ public NumberManager getExpressManager() &#123; return expressManager; &#125; /** * 获取VIP客户的生成器 */ public NumberManager getVipManager() &#123; return vipManager; &#125;&#125; 常量1234567891011121314/** * 常量静态类 */public class Constants &#123; public static int MAX_SERVICE_TIME = 10000; //10秒！ public static int MIN_SERVICE_TIME = 1000; //1秒！ /*每个普通窗口服务一个客户的平均时间为5秒，一共有4个这样的窗口，也就是说银行的所有普通窗口合起来 * 平均1.25秒内可以服务完一个普通客户，再加上快速窗口和VIP窗口也可以服务普通客户，所以， * 1秒钟产生一个普通客户比较合理，*/ public static int COMMON_CUSTOMER_INTERVAL_TIME = 1; private Constants()&#123;&#125;&#125; 客户取号生成器123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.List;/** * 客户取号生成器 */public class NumberManager &#123; /** * 最近一个号（最后一个号） */ private int lastNumber = 0; /** * 客户取号集 */ private List&lt;Integer&gt; queueNumbers = new ArrayList&lt;Integer&gt;(); /** * 生成最后一个号 * @return Integer */ public synchronized Integer generateNewNumber()&#123; queueNumbers.add(++lastNumber); return lastNumber; &#125; /** * 获取最后一个号，并将其从客户取号集里删除 * @return Integer */ public synchronized Integer fetchNumber()&#123; if(queueNumbers.size()&gt;0)&#123; return (Integer)queueNumbers.remove(0); &#125;else&#123; return null; &#125; &#125;&#125; 控制台部分日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139第1号普通窗口开始获取普通任务!第3号普通窗口开始获取普通任务!第4号普通窗口开始获取普通任务!第2号普通窗口开始获取普通任务!第1号普通窗口没有取到普通任务，正在空闲一秒第6号VIP窗口开始获取VIP任务!第6号VIP窗口没有取到VIP任务！第6号VIP窗口开始获取普通任务!第6号VIP窗口没有取到普通任务，正在空闲一秒第3号普通窗口没有取到普通任务，正在空闲一秒第4号普通窗口没有取到普通任务，正在空闲一秒第5号快速窗口开始获取快速任务!第5号快速窗口没有取到快速任务！第5号快速窗口开始获取普通任务!第5号快速窗口没有取到普通任务，正在空闲一秒第2号普通窗口没有取到普通任务，正在空闲一秒第1号普通客户正在等待服务！第1号快速客户正在等待服务！第1号VIP客户正在等待服务！第4号普通窗口开始获取普通任务!第3号普通窗口开始获取普通任务!第6号VIP窗口开始获取VIP任务!第5号快速窗口开始获取快速任务!第5号快速窗口开始为第1号快速客户服务第2号普通窗口开始获取普通任务!第1号普通窗口开始获取普通任务!第1号普通窗口没有取到普通任务，正在空闲一秒第2号普通窗口没有取到普通任务，正在空闲一秒第6号VIP窗口开始为第1号VIP客户服务第3号普通窗口没有取到普通任务，正在空闲一秒第4号普通窗口开始为第1号普通客户服务第2号普通客户正在等待服务！第3号普通窗口开始获取普通任务!第3号普通窗口开始为第2号普通客户服务第2号普通窗口开始获取普通任务!第2号普通窗口没有取到普通任务，正在空闲一秒第5号快速窗口完成为第1号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口没有取到快速任务！第1号普通窗口开始获取普通任务!第1号普通窗口没有取到普通任务，正在空闲一秒第5号快速窗口开始获取普通任务!第5号快速窗口没有取到普通任务，正在空闲一秒第3号普通客户正在等待服务！第2号快速客户正在等待服务！第2号普通窗口开始获取普通任务!第2号普通窗口开始为第3号普通客户服务第1号普通窗口开始获取普通任务!第5号快速窗口开始获取快速任务!第5号快速窗口开始为第2号快速客户服务第1号普通窗口没有取到普通任务，正在空闲一秒第4号普通客户正在等待服务！第5号快速窗口完成为第2号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口没有取到快速任务！第1号普通窗口开始获取普通任务!第1号普通窗口开始为第4号普通客户服务第5号快速窗口开始获取普通任务!第5号快速窗口没有取到普通任务，正在空闲一秒第5号普通客户正在等待服务！第3号快速客户正在等待服务！第4号普通窗口完成为第1号普通客户服务，总共耗时3秒第4号普通窗口开始获取普通任务!第4号普通窗口开始为第5号普通客户服务第5号快速窗口开始获取快速任务!第5号快速窗口开始为第3号快速客户服务第6号普通客户正在等待服务！第7号普通客户正在等待服务！第2号VIP客户正在等待服务！第4号快速客户正在等待服务！第5号快速窗口完成为第3号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口开始为第4号快速客户服务第6号VIP窗口完成为第1号VIP客户服务，总共耗时5秒第6号VIP窗口开始获取VIP任务!第6号VIP窗口开始为第2号VIP客户服务第8号普通客户正在等待服务！第5号快速窗口完成为第4号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口没有取到快速任务！第5号快速窗口开始获取普通任务!第5号快速窗口开始为第6号普通客户服务第9号普通客户正在等待服务！第5号快速客户正在等待服务！第2号普通窗口完成为第3号普通客户服务，总共耗时5秒第2号普通窗口开始获取普通任务!第2号普通窗口开始为第7号普通客户服务第10号普通客户正在等待服务！第3号普通窗口完成为第2号普通客户服务，总共耗时7秒第3号普通窗口开始获取普通任务!第3号普通窗口开始为第8号普通客户服务第11号普通客户正在等待服务！第6号快速客户正在等待服务！第5号快速窗口完成为第6号普通客户服务，总共耗时3秒第5号快速窗口开始获取快速任务!第5号快速窗口开始为第5号快速客户服务第4号普通窗口完成为第5号普通客户服务，总共耗时5秒第4号普通窗口开始获取普通任务!第4号普通窗口开始为第9号普通客户服务第12号普通客户正在等待服务！第1号普通窗口完成为第4号普通客户服务，总共耗时7秒第1号普通窗口开始获取普通任务!第1号普通窗口开始为第10号普通客户服务第5号快速窗口完成为第5号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口开始为第6号快速客户服务第13号普通客户正在等待服务！第3号VIP客户正在等待服务！第7号快速客户正在等待服务！第5号快速窗口完成为第6号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口开始为第7号快速客户服务第6号VIP窗口完成为第2号VIP客户服务，总共耗时6秒第6号VIP窗口开始获取VIP任务!第6号VIP窗口开始为第3号VIP客户服务第14号普通客户正在等待服务！第5号快速窗口完成为第7号快速客户服务，总共耗时1秒第5号快速窗口开始获取快速任务!第5号快速窗口没有取到快速任务！第5号快速窗口开始获取普通任务!第5号快速窗口开始为第11号普通客户服务第4号普通窗口完成为第9号普通客户服务，总共耗时2秒第4号普通窗口开始获取普通任务!第4号普通窗口开始为第12号普通客户服务第8号快速客户正在等待服务！第15号普通客户正在等待服务！第16号普通客户正在等待服务！第3号普通窗口完成为第8号普通客户服务，总共耗时5秒第3号普通窗口开始获取普通任务!第3号普通窗口开始为第13号普通客户服务第17号普通客户正在等待服务！第9号快速客户正在等待服务！第18号普通客户正在等待服务！第1号普通窗口完成为第10号普通客户服务，总共耗时6秒第1号普通窗口开始获取普通任务!第1号普通窗口开始为第14号普通客户服务第10号快速客户正在等待服务！第19号普通客户正在等待服务！第4号VIP客户正在等待服务！","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 自定义序列化过程","slug":"Java-自定义序列化过程","date":"2017-12-14T13:24:55.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/14/Java-自定义序列化过程/","link":"","permalink":"https://zhechu.github.io/2017/12/14/Java-自定义序列化过程/","excerpt":"","text":"在对象序列化的过程中，若涉及一些敏感信息，例如用户密码、信用卡账号等，通常需要考虑到保密和如何防止在传递过程中泄露的问题。使用 transient 关键字可以保护这些属性，但是这些属性将不会参与序列化过程。此时可以考虑显式定制序列化和反序列化的过程，在序列化时加入加密、在反序列化时加入解密等操作，而不是使用默认的序列化方式。 对象在序列化和反序列化时，是调用内部的 writeObject() 和 readObject() 方法实现的。两方法的定义如下： 12private void writeObject(ObjectOutputStream out) throws IOException;private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException; 若显式定制序列化和反序列化过程，重写上述两个方法即可。若需在 writeObject() 方法中使用默认的序列化机制，只需在 writeObject() 方法中调用 out.defaultWriteObject() 方法即可； readObject() 方法同理。 TIPS：在自定义序列化和反序列化过程中，对于简单类型的属性，必须使用默认的 writeInt(int i)、readInt(int i)、writeDouble(double d)和readDouble(double d) 等方法对简单类型进行读写操作；而对于引用类型的属性，可以在 writeObject(ObjectOutputStream out) 和 readObject(ObjectInputStream in) 中使用 writeObject() 和 readObject() 方法进行读写。另外，在文件或者网络中读取属性时，读取的顺序必须与写入的顺序保持一致。 示例代码如下：定义 Person 类并重写 writeObject() 和 readObject() 方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class Person implements Serializable &#123; /** * 序列号 */ private static final long serialVersionUID = -130200141065869373L; private String name; private int age; private String sex; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; /** * 实现 writeObject(ObjectOutputStream out) 方法 * @param out * @throws IOException */ private void writeObject(ObjectOutputStream out) throws IOException &#123; String psw = reverse(password); out.writeObject(name); out.writeInt(age); out.writeObject(sex); out.writeObject(psw); &#125; /** * 实现 readObject(ObjectInputStream in) 方法 * @param in * @throws ClassNotFoundException * @throws IOException */ private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException &#123; this.name = (String) in.readObject(); this.age = in.readInt(); this.sex = (String) in.readObject(); this.password = (String) in.readObject(); &#125; /** * 通过简单的反转字符串自定义密码的序列化方法 * @param in * @return */ private String reverse(String in) &#123; StringBuilder sb = new StringBuilder(in); sb.reverse(); return sb.toString(); &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \", sex=\" + sex + \", password=\" + password + \"]\"; &#125;&#125; 对 Person 类的对象执行读写操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import org.junit.Test;public class PersonTest &#123; @Test public void writeAndRead() &#123; write(); read(); &#125; private void write() &#123; Person p = new Person(); p.setName(\"Tom\"); p.setAge(22); p.setSex(\"male\"); p.setPassword(\"serializable\"); FileOutputStream fos = null; ObjectOutputStream oos = null; try &#123; fos = new FileOutputStream(\"D:\\\\person.tmp\"); oos = new ObjectOutputStream(fos); oos.writeObject(p); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (oos != null) &#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void read() &#123; Person p = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fis = new FileInputStream(\"D:\\\\person.tmp\"); ois = new ObjectInputStream(fis); p = (Person) ois.readObject(); System.out.println(p); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 输出结果如下1Person [name=Tom, age=22, sex=male, password=elbazilaires]","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"https://zhechu.github.io/tags/序列化/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 如何终止线程","slug":"Java-如何终止线程","date":"2017-12-13T15:38:21.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/13/Java-如何终止线程/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-如何终止线程/","excerpt":"","text":"终止一个正在运行的线程，Java 线程系统中提供的方法有很多，但是考虑到线程安全和其它的一些不确定因素，Thread 类中提供的 stop() 和 suspend() 方法是不推荐使用的。 除了 stop() 和 suspend() 方法可以终止线程之外，Thread 类中还提供了 intrerrupt() 方法。使用 Thread.isInterrupted() 和 Thread.Interrupted() 便可以实现线程的安全终止。 示例如下：1234567891011121314151617181920public class StopTest extends Thread &#123; public static void main(String[] args) &#123; StopTest thread = new StopTest(); thread.start(); &#125; public void run() &#123; int count = 0; while (!this.isInterrupted()) &#123; System.out.println(\"---\" + count + \"---\" + this.isAlive()); count ++; if (count == 5) &#123; this.interrupt(); System.out.println(\"---\" + count + \"---\" + this.isAlive()); &#125; &#125; &#125;&#125; 输出结果如下：123456---0---true---1---true---2---true---3---true---4---true---5---true","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 实现文件锁定功能","slug":"Java-锁定文件","date":"2017-12-13T15:27:38.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2017/12/13/Java-锁定文件/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-锁定文件/","excerpt":"","text":"Java 提供了两种方式，可以实现文件锁定功能。 使用 RandomAccessFile 实现锁定1234567891011121314151617181920212223242526272829import java.io.File;import java.io.RandomAccessFile;import java.nio.channels.FileChannel;import java.nio.channels.FileLock;import org.junit.Test;public class LockFileChannelTest &#123; @Test public void readTest() throws Exception &#123; read(new File(\"D:/file/笔记.txt\")); &#125; private static void read(File file) throws Exception &#123; RandomAccessFile raf = new RandomAccessFile(file, \"rw\"); FileChannel fc = raf.getChannel(); // 尝试获取文件锁，若有其他用户在使用则返回 null FileLock fl = fc.tryLock(); // 可以用 lock() 方法，区别是其方法为阻塞性方法 if (fl != null &amp;&amp; fl.isValid()) &#123; System.out.println(\"允许执行读写操作！\"); // 省略写入操作代码 fl.release(); // 释放文件锁 &#125; else &#123; System.out.println(\"其他用户正在执行读写操作！\"); &#125; &#125;&#125; 使用 FileChannel 实现锁定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class WiseException extends RuntimeException&#123; /** * 序列号 */ private static final long serialVersionUID = -2856267343603577461L; public WiseException() &#123; super(); &#125; public WiseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); &#125; public WiseException(String message, Throwable cause) &#123; super(message, cause); &#125; public WiseException(String message) &#123; super(message); &#125; public WiseException(Throwable cause) &#123; super(cause); &#125;&#125;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import org.junit.Test;import com.wise.WiseException;public class LockRandomAccessFileTest &#123; @Test public void readTest() &#123; String content = read(new File(\"D:/file/笔记.txt\")); System.out.println(content); &#125; private static String read(File file) &#123; String fileContent = null; FileChannel fc = null; RandomAccessFile fis = null; try &#123; fis = new RandomAccessFile(file, \"rws\"); // 单一线程的读写同步 // 获取通道 channel fc = fis.getChannel(); // 创建 ByteBuffer 缓冲区 ByteBuffer bb = ByteBuffer.allocate(10000); fc.read(bb); bb.flip(); fileContent = new String(bb.array()); &#125; catch (Exception e) &#123; throw new WiseException(\"Read file failed\", e); &#125; finally &#123; // 释放 FileChannel 资源 if (fc != null) &#123; try &#123; fc.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 返回文件内容 return fileContent; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 读写文件","slug":"Java-读写文件（NIO）","date":"2017-12-13T15:20:39.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2017/12/13/Java-读写文件（NIO）/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-读写文件（NIO）/","excerpt":"","text":"使用 NIO 替代 IO 高效读写文件。 读文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import org.junit.Test;import com.wise.WiseException;public class ReadFileTest &#123; @Test public void readTest() &#123; String content = read(new File(\"D:/file/笔记.txt\")); System.out.println(content); &#125; private static String read(File file) &#123; String fileContent = null; FileInputStream fis = null; FileChannel fc = null; try &#123; fis = new FileInputStream(file); // 获取通道 channel fc = fis.getChannel(); // 创建 ByteBuffer 缓冲区 ByteBuffer bb = ByteBuffer.allocate(10000); fc.read(bb); bb.flip(); fileContent = new String(bb.array()); &#125; catch (Exception e) &#123; throw new WiseException(\"Read file failed\", e); &#125; finally &#123; // 释放 FileChannel 资源 if (fc != null) &#123; try &#123; fc.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // 返回文件内容 return fileContent; &#125;&#125; 写文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import org.junit.Test;import com.wise.WiseException;public class WriteFileTest &#123; @Test public void readTest() &#123; write(new File(\"D:/file/笔记.txt\"), \"new new new\"); &#125; private static void write(File file, String str) &#123; FileOutputStream fos = null; FileChannel fc = null; byte[] bts = str.getBytes(); try &#123; fos = new FileOutputStream(file); // 获取通道 channel fc = fos.getChannel(); // 创建 ByteBuffer 缓冲区 ByteBuffer bb = ByteBuffer.allocate(bts.length); bb.put(bts); bb.flip(); fc.write(bb); &#125; catch (Exception e) &#123; throw new WiseException(\"Write file failed\", e); &#125; finally &#123; // 释放 FileChannel 资源 if (fc != null) &#123; try &#123; fc.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"阿里统计单词出现次数面试题","slug":"阿里检索单词面试题（IO）","date":"2017-12-13T14:45:30.000Z","updated":"2020-11-03T13:04:34.291Z","comments":false,"path":"2017/12/13/阿里检索单词面试题（IO）/","link":"","permalink":"https://zhechu.github.io/2017/12/13/阿里检索单词面试题（IO）/","excerpt":"","text":"统计一个单词可重复的英文文件（假设4G）中每个单词出现的次数，把结果按照英文排序放入一个文件中。并能够检索特定单词的出现次数。由于文件过大，不重复单词总数有限，需要考虑到执行速度和内存使用情况？ 两种方案 1 采用 NIO + 多线程 处理（较高效）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.nio.channels.FileLock;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.TreeMap;import java.util.concurrent.CountDownLatch;/** * 统计单词出现次数（高效） * @author lingyuwang ling-yu-wang@qq.com * @date 2016年11月25日 下午8:44:18 * @version V1.0 */public class EfficientCopyFile &#123; public static void main(String[] args) throws Exception &#123; long start = System.currentTimeMillis(); wordCount(\"D://filecopy.txt\", \"D://filecopy2.txt\"); long end = System.currentTimeMillis(); System.out.println(\"用时： \"+(end-start)+\"ms\"); &#125; /** * 统计一个单词可重复的英文文件（假设4G）中每个单词出现的次数，把结果按照英文排序放入一个文件中。 * 并能够检索特定单词的出现次数。由于文件过大，不重复单词总数有限，需要考虑到执行速度和内存使用情况 */ private static void wordCount(String resource, String destination) &#123; // 获取 cpu 个数，开启与 cpu 个数相同的线程数 int threadCount = Runtime.getRuntime().availableProcessors(); File file = new File(resource); long fileLength = file.length(); if (fileLength &lt; 1024) &#123; throw new RuntimeException(\"File length cannot be less than 1024 characters.\"); &#125; // 获取分割点，返回分割点数组 long[] points = getBreakPoint(file, threadCount, fileLength); // 需要 threadCount 个线程解阻塞 CountDownLatch countWordCdl = new CountDownLatch(threadCount); // 需要 threadCount 个线程解阻塞 CountDownLatch wordLengthCdl = new CountDownLatch(threadCount); // 获取单词汇总集合 Map&lt;String, Integer&gt; wordCount = getWordCount(threadCount, file, points, countWordCdl); // 统计 wordCount 单词总大小以及数值字符总大小 long length = getLength(threadCount, wordLengthCdl, wordCount); // 将结果保存至文件 saveToFile(wordCount, length, new File(destination)); &#125; /** * 统计 wordCount 单词总大小以及数值字符总大小 * @param threadCount * @param wordLengthCdl * @param wordCount * @return */ @SuppressWarnings(\"unchecked\") private static long getLength(int threadCount, CountDownLatch wordLengthCdl, Map&lt;String, Integer&gt; wordCount) &#123; Set&lt;Entry&lt;String, Integer&gt;&gt; wordCountSet = wordCount.entrySet(); Entry&lt;String, Integer&gt;[] wordCountEntrys = wordCountSet.toArray(new Entry[]&#123;&#125;); int size = wordCountEntrys.length; int wStep = size/threadCount; // 步长 int[] sizePoints = new int[threadCount+1]; sizePoints[0] = 0; sizePoints[threadCount] = size; for (int i = 1; i &lt; threadCount; i++) &#123; sizePoints[i] = wStep*i; &#125; List&lt;WordLength&gt; WordLengths = new ArrayList&lt;WordLength&gt;(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; WordLengths.add(new WordLength(wordLengthCdl, wordCountEntrys, sizePoints[i], sizePoints[i+1])); &#125; for (WordLength wordLength : WordLengths) &#123; // 开辟threadCount个线程分别处理 map 的不同片段 new Thread(wordLength).start(); &#125; try &#123; wordLengthCdl.await(); // 阻塞获取 word length &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long length = 0; for (WordLength wordLength : WordLengths) &#123; length += wordLength.getLength(); &#125; return length; &#125; /** * 获取单词汇总集合 * @param threadCount * @param file * @param points * @param countWordCdl * @return */ private static Map&lt;String, Integer&gt; getWordCount(int threadCount, File file, long[] points, CountDownLatch countWordCdl) &#123; List&lt;CountWord&gt; CountWords = new ArrayList&lt;CountWord&gt;(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; CountWords.add(new CountWord(countWordCdl, file, points[i], points[i+1])); &#125; for (CountWord countWord : CountWords) &#123; // 开辟threadCount个线程分别处理文件的不同片段 new Thread(countWord).start(); &#125; try &#123; countWordCdl.await(); // 阻塞获取 wordCount &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 获取各自处理的结果 List&lt;Map&lt;String, Integer&gt;&gt; wordCounts = new ArrayList&lt;Map&lt;String, Integer&gt;&gt;(threadCount); for (int i = 0; i &lt; threadCount; i++) &#123; wordCounts.add(CountWords.get(i).getResult()); &#125; // 使用TreeMap保证结果有序 Map&lt;String, Integer&gt; wordCount = new TreeMap&lt;String, Integer&gt;(); for (Map&lt;String, Integer&gt; map : wordCounts) &#123; wordCount = addTo(wordCount, map); &#125; return wordCount; &#125; /** * 获取分割点数组 * @param file * @param threadCount * @param length * @return */ private static long[] getBreakPoint(File file, int threadCount, long length) &#123; long[] points = new long[threadCount+1]; points[0] = 0; // 第一个分割点，固定为 0 points[threadCount] = length; // 最后一个分割点，固定为文件大小 long step = length/threadCount; // 间隔长度 RandomAccessFile raf = null; FileChannel fileChannel = null; FileLock fileLock = null; try &#123; // 得到当前文件的通道 raf = new RandomAccessFile(file , \"rw\"); fileChannel = raf.getChannel(); // 锁定当前文件的部分 fileLock = fileChannel.lock(0, length, false); // 对当前文件片段建立内存映射 MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, length); ByteBuffer byteBuffer = mappedByteBuffer.asReadOnlyBuffer(); byte b; long stepJ = step; long setpJLength = stepJ + step; // setpJLength = stepJ*2 // 遍历分割点，并设值（第一个和最后一个分割点不用处理） for (int i = 1; i &lt; threadCount; i++) &#123; for (long j=stepJ; j&lt;setpJLength; j++)&#123; b = byteBuffer.get((int)j); if (b&lt;65 || b&gt;122 || b&gt;90&amp;&amp;b&lt;97) &#123; // 非字母 points[i] = j; break; &#125; &#125; stepJ = setpJLength; setpJLength = stepJ + step; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放文件锁 try &#123; fileLock.release(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 关闭通道 try &#123; fileChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return points; &#125; /** * 将结果保存至文件 * @param wordCount 单词出现次数集合 * @param file 目标文件 */ private static void saveToFile(Map&lt;String, Integer&gt; wordCount, long length, File file) &#123; RandomAccessFile raw = null; FileChannel fcw = null; try &#123; //要写入的文件 raw = new RandomAccessFile(file, \"rw\"); fcw = raw.getChannel(); // wordCount.size()*2 表示 : , 的总大小，length 表示单词及数值字符总大小 MappedByteBuffer mbbw = fcw.map(FileChannel.MapMode.READ_WRITE, 0, length+wordCount.size()*2); StringBuilder result = new StringBuilder(); for (Entry&lt;String,Integer&gt; entry: wordCount.entrySet()) &#123; result.append(entry.getKey()).append(\":\").append(entry.getValue()).append(\",\"); mbbw.put(result.toString().getBytes()); result.delete(0, result.length()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭通道 if (fcw != null) &#123; try &#123; fcw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (raw != null) &#123; try &#123; raw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 合并 map，相同键，值相加 * @param target 目标集合 * @param plus 被加集合 * @return */ @SuppressWarnings(\"unchecked\") private static &lt;K&gt; Map&lt;K,Integer&gt; addTo(Map&lt;K,Integer&gt; target, Map&lt;K,Integer&gt; plus) &#123; K[] os = (K[]) plus.keySet().toArray(); K key; for (int i=0; i&lt;os.length; i++) &#123; key = os[i]; if (target.containsKey(key)) target.put(key, target.get(key) + plus.get(key)); else target.put(key, plus.get(key)); &#125; return target; &#125;&#125;/** * 计算单词出现次数 * @author lingyuwang ling-yu-wang@qq.com * @date 2016年12月5日 下午8:52:07 * @version V1.0 */class CountWord implements Runnable &#123; private RandomAccessFile raf; private FileChannel fileChannel; private FileLock fileLock; private ByteBuffer byteBuffer; private Map&lt;String, Integer&gt; wordCount; // 单词计数 private long length; // 文件片段大小 private CountDownLatch cdl; public CountWord(CountDownLatch cdl, File file, long start, long end) &#123; try &#123; this.cdl = cdl; length = end - start; // 得到当前文件的通道 raf = new RandomAccessFile(file , \"rw\"); fileChannel = raf.getChannel(); // 锁定当前文件的部分 fileLock = fileChannel.lock(start, length, false); // 对当前文件片段建立内存映射，如果文件过大需要切割成多个片段 MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, start, length); byteBuffer = mappedByteBuffer.asReadOnlyBuffer(); // 创建HashMap实例存放处理结果 wordCount = new HashMap&lt;String,Integer&gt;(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; try &#123; StringBuilder word = new StringBuilder(); String wordStr; byte b; for (int i=0; i&lt;length; i++)&#123; b = byteBuffer.get(i); if (b&gt;=65&amp;&amp;b&lt;=90 || b&gt;=97&amp;&amp;b&lt;=122) &#123; // 字母 word.append((char)b); continue; &#125; // 将前面的 word 存入mbbw wordStr = word.toString(); if (wordStr.matches(\"^[a-zA-Z]+$\")) &#123; if (wordCount.get(wordStr) != null) &#123; // 已存在 key 则加 1 wordCount.put(wordStr, wordCount.get(wordStr)+1); &#125; else &#123; // 不存在，则直接存入 wordCount.put(wordStr, 1); &#125; &#125; word.delete(0, word.length()); // 重置 word &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放文件锁 try &#123; fileLock.release(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 关闭通道 try &#123; fileChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; cdl.countDown(); &#125; &#125; /** * 获取当前线程的执行结果 * @return */ public Map&lt;String, Integer&gt; getResult() &#123; return wordCount; &#125;&#125;/** * 获取单词总大小 * @author lingyuwang ling-yu-wang@qq.com * @date 2016年12月5日 下午10:30:21 * @version V1.0 */class WordLength implements Runnable &#123; private Entry&lt;String, Integer&gt;[] wordCounts; private int start; private int end; private long length; // 单词总大小 private CountDownLatch cdl; public WordLength(CountDownLatch cdl, Entry&lt;String, Integer&gt;[] wordCounts, int start, int end) &#123; this.cdl = cdl; this.wordCounts = wordCounts; this.start = start; this.end = end; &#125; @Override public void run() &#123; try &#123; length = statisticsLength(wordCounts, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; cdl.countDown(); &#125; &#125; /** * 统计数组中的字符串总大小 * @param wordCounts * @return */ private long statisticsLength(Entry&lt;String, Integer&gt;[] wordCounts, int start, int end) &#123; long length = 0; for (int i = start; i &lt; end; i++) &#123; length += wordCounts[i].getKey().length(); length += String.valueOf(wordCounts[i].getValue()).length(); &#125; return length; &#125; /** * 获取单词总大小 * @return */ public long getLength() &#123; return length; &#125;&#125; 2 只采用 NIO （较低效）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;import java.nio.channels.FileLock;import java.util.Map;import java.util.Set;import java.util.TreeMap;import java.util.Map.Entry;/** * 统计单词出现次数（低效） * @author lingyuwang ling-yu-wang@qq.com * @date 2016年11月25日 下午8:44:18 * @version V1.0 */public class InefficiencyCopyFile &#123; public static void main(String[] args) throws Exception &#123; long start = System.currentTimeMillis(); wordCount(); long end = System.currentTimeMillis(); System.out.println(\"用时： \"+(end-start)+\"ms\"); &#125; /** * 统计一个单词可重复的英文文件（假设4G）中每个单词出现的次数，把结果按照英文排序放入一个文件中。 * 并能够检索特定单词的出现次数。由于文件过大，不重复单词总数有限，需要考虑到执行速度和内存使用情况 * @throws Exception */ @SuppressWarnings(\"unchecked\") private static void wordCount() throws Exception &#123; File file = new File(\"D://filecopy.txt\"); long length = file.length(); // 得到当前文件的通道 RandomAccessFile raf = new RandomAccessFile(file , \"rw\"); FileChannel fileChannel = raf.getChannel(); // 锁定当前文件的部分 FileLock fileLock = fileChannel.lock(0, length, false); // 对当前文件片段建立内存映射，如果文件过大需要切割成多个片段 MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, length); ByteBuffer byteBuffer = mappedByteBuffer.asReadOnlyBuffer(); // 创建HashMap实例存放处理结果 Map&lt;String, Integer&gt; wordCount = new TreeMap&lt;String,Integer&gt;(); try &#123; StringBuilder word = new StringBuilder(); String wordStr; byte b; for (int i=0; i&lt;length; i++)&#123; b = byteBuffer.get(i); if (b&gt;=65&amp;&amp;b&lt;=90 || b&gt;=97&amp;&amp;b&lt;=122) &#123; // 字母 word.append((char)b); continue; &#125; // 将前面的 word 存入mbbw wordStr = word.toString(); if (wordStr.matches(\"^[a-zA-Z]+$\")) &#123; if (wordCount.get(wordStr) != null) &#123; // 已存在 key 则加 1 wordCount.put(wordStr, wordCount.get(wordStr)+1); &#125; else &#123; // 不存在，则直接存入 wordCount.put(wordStr, 1); &#125; &#125; word.delete(0, word.length()); // 重置 word &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 释放文件锁 try &#123; fileLock.release(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; // 关闭通道 try &#123; fileChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; raf.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 统计 wordCount 单词总大小以及数值字符总大小 Set&lt;Entry&lt;String, Integer&gt;&gt; wordCountSet = wordCount.entrySet(); Entry&lt;String, Integer&gt;[] wordCounts = wordCountSet.toArray(new Entry[]&#123;&#125;); int size = wordCounts.length; long wordCountslength = statisticsLength(wordCounts, 0, size); // 将结果保存至文件 saveToFile(wordCount, wordCountslength, new File(\"D://filecopy1.txt\")); &#125; /** * 将结果保存至文件 * @param wordCount 单词出现次数集合 * @param file 目标文件 */ private static void saveToFile(Map&lt;String, Integer&gt; wordCount, long length, File file) &#123; RandomAccessFile raw = null; FileChannel fcw = null; try &#123; //要写入的文件 raw = new RandomAccessFile(file, \"rw\"); fcw = raw.getChannel(); // wordCount.size()*2 表示 : , 的总大小，length 表示单词及数值字符总大小 MappedByteBuffer mbbw = fcw.map(FileChannel.MapMode.READ_WRITE, 0, length+wordCount.size()*2); StringBuilder result = new StringBuilder(); for (Entry&lt;String,Integer&gt; entry: wordCount.entrySet()) &#123; result.append(entry.getKey()).append(\":\").append(entry.getValue()).append(\",\"); mbbw.put(result.toString().getBytes()); result.delete(0, result.length()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 关闭通道 if (fcw != null) &#123; try &#123; fcw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (raw != null) &#123; try &#123; raw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 统计数组中的字符串总大小 * @param wordCounts * @return */ private static long statisticsLength(Entry&lt;String, Integer&gt;[] wordCounts, int start, int end) &#123; long length = 0; for (int i = start; i &lt; end; i++) &#123; length += wordCounts[i].getKey().length(); length += String.valueOf(wordCounts[i].getValue()).length(); &#125; return length; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"},{"name":"多线程","slug":"多线程","permalink":"https://zhechu.github.io/tags/多线程/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 实现文件的压缩和解压缩","slug":"Java-实现文件的压缩和解压缩","date":"2017-12-13T14:31:59.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/13/Java-实现文件的压缩和解压缩/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-实现文件的压缩和解压缩/","excerpt":"","text":"Java 支持的压缩格式有 zip、gzip 和 jar 等。zip 是 Windows 系统常用的压缩格式、gzip 是 Linux 系统常用的压缩格式、而 jar 是 Java 特有的一种压缩格式。 下面重点介绍 zip 格式的压缩和解压缩。在使用 zip 格式压缩、解压缩时，压缩可以使用 ZipEntry 类和 ZipOutputStream 类，解压缩可以使用 ZipEntry 类和 ZipInputStream 类。 异常处理类12345678910111213141516171819202122232425262728public class WiseException extends RuntimeException&#123; /** * 序列号 */ private static final long serialVersionUID = -2856267343603577461L; public WiseException() &#123; super(); &#125; public WiseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); &#125; public WiseException(String message, Throwable cause) &#123; super(message, cause); &#125; public WiseException(String message) &#123; super(message); &#125; public WiseException(Throwable cause) &#123; super(cause); &#125;&#125; 文件压缩类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipOutputStream;import org.junit.Test;public class FileZipTest &#123; @Test public void cutTest() &#123; try &#123; zip(new String[]&#123; \"D:\\\\file\\\\笔记\\\\tmp0笔记.txt\", \"D:\\\\file\\\\笔记\\\\tmp1笔记.txt\", \"D:\\\\file\\\\笔记\\\\tmp2笔记.txt\", \"D:\\\\file\\\\笔记\\\\tmp3笔记.txt\" &#125;, \"D:\\\\file\\\\tmp\\\\笔记.zip\"); &#125; catch (WiseException e) &#123; e.printStackTrace(); &#125; &#125; /** * 文件压缩 * @param files 要压缩的文件 * @param destZip 压缩之后的 zip 文件 */ private static void zip(String[] files, String destZip) &#123; FileOutputStream fos = null; BufferedOutputStream bos = null; ZipOutputStream zos = null; try &#123; fos = new FileOutputStream(destZip); bos = new BufferedOutputStream(fos); zos = new ZipOutputStream(bos); // 循环读文件，压缩到 zip 中 for (int i = 0; i &lt; files.length; i++) &#123; FileInputStream fis = null; BufferedInputStream bis = null; try &#123; String file = files[i]; fis = new FileInputStream(file); bis = new BufferedInputStream(fis); // 获取文件名，创建条目并添加到 zip 中 File f = new File(file); ZipEntry ze = new ZipEntry(f.getName()); zos.putNextEntry(ze); // 读取文件中的字节信息，压入条目 int tmp = -1; while ((tmp = bis.read()) != -1) &#123; zos.write(tmp); &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Zip file failed\", e); &#125; finally &#123; if (zos != null) &#123; zos.closeEntry(); &#125; if (bis != null) &#123; bis.close(); &#125; if (fis != null) &#123; fis.close(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Zip file failed\", e); &#125; finally &#123; if (zos != null) &#123; try &#123; zos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (bos != null) &#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 文件解压缩类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.ZipEntry;import java.util.zip.ZipInputStream;import org.junit.Test;public class FileUnzipTest &#123; @Test public void mergeTest() &#123; try &#123; unzip(\"D:\\\\file\\\\tmp\\\\笔记.zip\", \"D:\\\\file\\\\tmp\\\\\"); &#125; catch (WiseException e) &#123; e.printStackTrace(); &#125; &#125; /** * 文件解压缩 * @param zipfile 要解压的 zip 文件 * @param destpath 解压后文件所放目录 */ private static void unzip(String zipfile, String destpath) &#123; FileInputStream fis = null; ZipInputStream zis = null; ZipEntry ze = null; try &#123; fis = new FileInputStream(zipfile); zis = new ZipInputStream(fis); while ((ze = zis.getNextEntry()) != null) &#123; if (!ze.isDirectory()) &#123; // 只处理文件 FileOutputStream fos = null; try &#123; String file = ze.getName(); fos = new FileOutputStream(destpath + file); int tmp = -1; while ((tmp = zis.read()) != -1) &#123; fos.write(tmp); &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Unzip file failed\", e); &#125; finally &#123; if (zis != null) &#123; zis.closeEntry(); &#125; if (fos != null) &#123; fos.close(); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Unzip file failed\", e); &#125; finally &#123; if (zis != null) &#123; try &#123; zis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 实现文件的分割与合并","slug":"Java-实现文件的分割与合并","date":"2017-12-13T14:18:52.000Z","updated":"2020-11-03T13:04:34.148Z","comments":false,"path":"2017/12/13/Java-实现文件的分割与合并/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-实现文件的分割与合并/","excerpt":"","text":"使用 RandomAccessFile 类可实现文件的分割和合并功能，该类具有在文件任意位置进行读写的功能。例如多线程下载、断点续传等功能都需要用到文件分割和合并功能。 异常处理类12345678910111213141516171819202122232425262728public class WiseException extends RuntimeException&#123; /** * 序列号 */ private static final long serialVersionUID = -2856267343603577461L; public WiseException() &#123; super(); &#125; public WiseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); &#125; public WiseException(String message, Throwable cause) &#123; super(message, cause); &#125; public WiseException(String message) &#123; super(message); &#125; public WiseException(Throwable cause) &#123; super(cause); &#125;&#125; 文件分割类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import org.junit.Test;public class FileCutTest &#123; @Test public void cutTest() &#123; try &#123; cut(\"D:/file/笔记.txt\", \"D:/file/笔记\", 1); &#125; catch (WiseException e) &#123; e.printStackTrace(); &#125; &#125; /** * 分割文件 * @param fileName 源文件 * @param filterFolder 分割文件所在目录 * @param size 每一份大小，以 KB 为单位 * @throws Exception */ private void cut(String fileName, String filterFolder, int size) &#123; RandomAccessFile inn = null; RandomAccessFile outt = null; try &#123; size = size * 1024; int maxx = 0; // 若输出目录不存在，则创建 File outFolder = new File(filterFolder); if (!outFolder.exists()) &#123; outFolder.mkdirs(); &#125; File inFile = new File(fileName); int fileLength = (int) inFile.length(); int value; // 取得要分割的个数 inn = new RandomAccessFile(inFile, \"r\"); // 打开要分割的文件 value = fileLength / size; int i = 0; int j = 0; // 根据要分割的数据输出文件 for (; j &lt; value; j++) &#123; try &#123; File outFile = new File(filterFolder + File.separator + \"tmp\" + j + inFile.getName()); outt = new RandomAccessFile(outFile, \"rw\"); maxx += size; for (; i &lt; maxx; i++) &#123; outt.write(inn.read()); &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Cut file failed\", e); &#125; finally &#123; if (outt != null) &#123; outt.close(); &#125; &#125; &#125; File outFile = new File(filterFolder + File.separator + \"tmp\" + j + inFile.getName()); outt = new RandomAccessFile(outFile, \"rw\"); for (; i &lt; fileLength; i++) &#123; outt.write(inn.read()); &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Cut file failed\", e); &#125; finally &#123; try &#123; if (outt != null) &#123; outt.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inn != null) &#123; inn.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 文件合并类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.io.File;import java.io.FilenameFilter;import java.io.IOException;import java.io.RandomAccessFile;import org.junit.Test;public class FileMergeTest &#123; @Test public void mergeTest() &#123; try &#123; merge(\"D:/file/笔记.txt\", \"D:/file/笔记\", \"tmp\"); &#125; catch (WiseException e) &#123; e.printStackTrace(); &#125; &#125; /** * 将分割后的文件合并 * @param fileName 合并之后的文件 * @param filterFolder 分割文件所在目录 * @param filterName 分割后的文件后缀 * @throws Exception */ private void merge(String fileName, String filterFolder, final String filterName) &#123; RandomAccessFile outt = null; try &#123; File[] tt; File inFile = new File(filterFolder); // 在当前目录下的文件 File outFile = new File(fileName); // 取得输出名 outt = new RandomAccessFile(outFile, \"rw\"); // 取得符合条件的文件名 tt = inFile.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; String rr = new File(name).toString(); return rr.startsWith(filterName); &#125; &#125;); // 打印出取得的文件名 for (int i = 0; i &lt; tt.length; i++) &#123; System.out.println(tt[i]); &#125; // 打开所有的文件再写入一个文件里 for (int i = 0; i &lt; tt.length; i++) &#123; RandomAccessFile inn = null; try &#123; inn = new RandomAccessFile(tt[i], \"r\"); int c; while ((c = inn.read()) != -1) &#123; outt.write(c); &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Merge file failed\", e); &#125; finally &#123; if (inn != null) &#123; inn.close(); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new WiseException(\"Merge file failed\", e); &#125; finally &#123; try &#123; if (outt != null) &#123; outt.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://zhechu.github.io/tags/IO/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 动态绑定","slug":"Java-动态绑定","date":"2017-12-13T13:54:21.000Z","updated":"2020-11-03T13:04:34.147Z","comments":false,"path":"2017/12/13/Java-动态绑定/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-动态绑定/","excerpt":"","text":"将一个方法调用和一个方法主体连接到一起称为“绑定”（Bingding）。若在程序运行之前执行绑定，由编译器决定方法调用的程序，称为“早期绑定”或“静态绑定”。若绑定过程在程序运行期间进行，以对象的类型为基础，则称为“后期绑定”或“动态绑定”。 若一种语言实现了后期绑定，同时必须提供一些机制，可以在运行期间判断对象的实际类型，并分别调用适当的方法，即编译器此时依然不知道对象的类型，但方法调用机制能够自己去调查，找到正确的方法主体。Java 方法的执行主要采用动态绑定技术，在程序运行时，虚拟机将调用对象实际类型所限定的方法。 Java 方法在调用过程中主要经历了以下过程： 编译器查看对象变量的声明类型和方法名，通过声明类型找到方法列表。 编译器查看调用方法时提供的参数类型。 若方法由 private、static 和 final 修饰或者是构造器，编译器就可以确定调用哪一个方法，即采取静态绑定技术。若不是上述情况，则使用动态绑定技术，执行后续过程。 虚拟机提取对象的实际类型的方法表。 虚拟机搜索方法签名。 调用方法。 TIPS：Java 方法的执行主要采用动态绑定技术，在程序运行时，虚拟机将调用对象实际类型所限定的方法。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 重写 hashCode() 方法","slug":"Java-重写-HashCode-方法","date":"2017-12-13T13:31:33.000Z","updated":"2020-11-03T13:04:34.149Z","comments":false,"path":"2017/12/13/Java-重写-HashCode-方法/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-重写-HashCode-方法/","excerpt":"","text":"为什么在重写 equals() 方法时，一般都会重写 hashCode() 方法？ 重写 equals() 方法主要是为了方便比较两个对象内容是否相等。hashCode() 方法用于返回调用该方法的对象的散列码值。此方法将返回整数形式的散列码值。 一个类若重写了 equals() 方法，通常也有必要重写 hashCode() 方法，目的是维护 hashCode() 方法的常规协定，该协定声明相等对象必须具有相等的散列码。hashCode() 的常规协定主要有以下几点： 在 Java 应用程序执行期间，在同一对象上多次调用 hashCode() 方法时，必须一致地返回相同的整数，前提是对象上 equals() 方法比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。 若根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode() 方法都必须生成相同的整数结果。 以下情况不是必须的：若根据 equals(Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode() 方法必定会生成不同的整数结果。 TIPS：相等的对象必须有相同的散列码，反之散列码相同则不一定对象相等，而且不相等的对象并不一定需要有不同的散列码。 基于散列法的集合需要使用 hashCode() 方法返回的散列码值存储和管理元素，如：HashTable、HashMap 和 HashSet 等，在使用这些集合时，首先会根据元素的散列码值确定其存储位置，再根据 equals() 方法结果判断元素对象是否已存在，最后根据判断结果执行不同处理。","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java final 关键字","slug":"Java-final-关键字","date":"2017-12-13T13:06:16.000Z","updated":"2020-11-03T13:04:34.147Z","comments":false,"path":"2017/12/13/Java-final-关键字/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-final-关键字/","excerpt":"","text":"在 Java 中，final 关键字可以修饰类、成员变量、局部变量和方法，具体使用情况及其含义如下： 1 final 修饰类final 修饰类时，表示该类不能被其它类继承，例如：String 和 Math。若不希望定义的类被继承，可以将类使用 final 修饰。示例代码如下： 1public final class Person &#123;&#125; 2 final 修饰成员变量final 修饰成员变量时，表示该变量是一个常量。在需要使用常量的场合，可以使用 final 关键字定义。示例代码如下： 12final int MALE = 1;final int FEMALE = 0; TIPS：若 final 修饰的是一个简单类型的变量，那么变量值一旦初始化后，将不能修改。若 final 修饰的是一个引用类型的变量，那么该变量的引用不可以改变，但可以通过该引用修改引用对象的属性值。 3 final 修饰局部变量final 修饰局部变量时，该局部变量只能读，但与 final 修饰成员变量不同， final 修饰局部变量只是 Java 中的语法糖，局部变量上的 final 修饰并不会写入 class 文件，更无法出现在运行期。若局部变量被 final 修饰，则编译器在编译时会检查该变量是否有可能发生第二次修改，若可能就编译失败；反之，消除 final 修饰。 如下代码编译失败： 1234final int age = 1;if (age == 1) &#123; age = 2;&#125; 4 final 修饰方法final 修饰方法时，表示该方法不可以在子类中重写（覆盖）。final 关键字修饰方法的实例代码如下： 123public final m1() &#123; // TODO 添加代码&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Java 修饰符","slug":"Java-修饰符","date":"2017-12-13T12:52:53.000Z","updated":"2020-11-03T13:04:34.147Z","comments":false,"path":"2017/12/13/Java-修饰符/","link":"","permalink":"https://zhechu.github.io/2017/12/13/Java-修饰符/","excerpt":"","text":"Java 可以在类、类的属性以及类的方法前面加上一个修饰符，来对其进行访问权限的控制。public、protected 和 private 修饰符是用于定义成员访问权限的，另外还有一种是 “default” 情况，也就是在成员前不加任何权限修饰符。其权限差别如下表： 修饰符 类内部 同一包中 子类中 其它 publicd 允许 允许 允许 允许 protected 允许 允许 允许 不允许 default 允许 允许 允许 不允许 private 允许 不允许 不允许 不允许","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"eclipse 手动安装 lombok","slug":"eclipse-手动安装-lombok","date":"2017-12-12T15:14:05.000Z","updated":"2020-11-03T13:04:34.267Z","comments":false,"path":"2017/12/12/eclipse-手动安装-lombok/","link":"","permalink":"https://zhechu.github.io/2017/12/12/eclipse-手动安装-lombok/","excerpt":"","text":"lombok 提供了简单的注解的形式来帮助 Javaer 简化消除一些必须有但显得很臃肿的 Java 代码。特别是 POJO。 1 下载 lombok-1.16.18.jar官网下载 官方文档 2 将 lombok.jar 复制到 eclipse.ini 所在的文件夹目录下3 打开 eclipse.ini，在最后面插入以下两行配置并保存12-Xbootclasspath/a:lombok.jar-javaagent:lombok.jar 4 重启 eclipse 即可","categories":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}],"tags":[{"name":"lombok","slug":"lombok","permalink":"https://zhechu.github.io/tags/lombok/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://zhechu.github.io/categories/Java/"}]},{"title":"Hexo + Github 搭建博客","slug":"Hexo-Github-搭建博客","date":"2017-12-11T13:47:37.000Z","updated":"2020-11-03T13:04:34.085Z","comments":false,"path":"2017/12/11/Hexo-Github-搭建博客/","link":"","permalink":"https://zhechu.github.io/2017/12/11/Hexo-Github-搭建博客/","excerpt":"","text":"使用 Hexo + Github 可以搭建自定义主题、免费、稳定的博客，故推荐之。效果预览 哲锄的博客。 Hexo官方文档 https://hexo.io/zh-cn/docs/ 1 搭建环境准备1.1 说明 环境 版本 操作系统 Windows7-64Bit Node.js v8.11.1 Git 2.8.1 Hexo 3.8.0 1.2 安装 Node.jsNode.js 历史版本 下载 安装完后，检查是否安装成功，若安装失败，请检查配置 12$ node -v$ npm -v 1.3 安装 Git下载 参考博文 1.4 Github 配置1.4.1 新建仓库新建 &lt;github account&gt;.github.io仓库，如：zhechu.github.io 1.4.2 配置 ssh key本地生成 key 123$ git config --global user.name \"&lt;github account&gt;\"$ git config --global user.email \"&lt;your mail&gt;\"$ ssh-keygen -t rsa -C \"&lt;your mail&gt;\" TIPS：生成 key 不断回车即可。 如：123$ git config --global user.name \"zhechu\"$ git config --global user.email ling-yu-wang@qq.com$ ssh-keygen -t rsa -C ling-yu-wang@qq.com &lt;github account&gt;.github.io 仓库配置 ssh key 复制 C:\\Users\\.ssh\\id_rsa.pub 文件的内容到 github 测试配置是否成功 1$ ssh -T git@github.com 若显示如下图则表示绑定成功 1.4.3 绑定域名1.4.3.1 申请域名http://www.freenom.com，可申请免费的，申请域名教程请自行搜索。 1.4.3.2 Github绑定域名进入&lt;github account&gt;.github.io仓库设置页面输入域名后保存登录http://www.freenom.com并配置映射 1.4.3.3 Hexo域名设置在博客源码source下新建CNAME文件CNAME文件内容如下（域名是刚才Github绑定的）_config.yml配置url TIPS：域名绑定就ok了！但由于freenom使用的dns解析器需要时间解析，域名绑定可能要等30分钟才会生效。 2 Hexo2.1 安装 Hexo官方中文文档 12$ npm install -g hexo-cli # 安装 Hexo$ hexo -v # 检查是否安装成功 2.2 站点配置12345$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ hexo init # 初始化站点$ npm install # 安装依赖$ hexo g # 生成静态文件$ hexo s # 本地启动服务 TIPS：浏览器访问http://127.0.0.1:4000；若可以访问，则表示配置成功。 2.3 绑定 Github123$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ npm install --save hexo-deployer-git # 安装 hexo-deployer-git 依赖$ vim _config.yml # 配置 Github 仓库信息 2.4 国际化配置12$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ vim _config.yml # 配置语言为 zh-CN 2.5 文章分类12$ cd D:\\mywork\\blog\\hexo\\themes\\snippet # 进入项目主题目录$ vim _config.yml # 配置导航菜单 1$ vim D:\\mywork\\blog\\hexo\\source\\_posts\\test.md # 设置 test文章为 java 分类 2.6 发布文章123$ hexo new post \"&lt;article title&gt;\"$ hexo g # 生成静态文件$ hexo d # 发布到 Github TIPS：在 D:\\mywork\\blog\\hexo\\source_posts 将会生成 article title.md 文件，使用MarkDown编辑器打开就可以编辑文章；浏览器访问&lt;https://&lt;github account&gt;.github.io&gt;即可看到最新发布内容。 2.7 切换主题2.7.1 安装 gulp官方中文文档 123$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ npm install --global gulp # 全局安装$ npm install --save-dev gulp # 项目加入gulp依赖 2.7.2 使用 snippet 主题snippet主题 12345678910111213141516171819202122$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ git clone git://github.com/shenliyang/hexo-theme-snippet.git themes/snippet # 下载主题$ npm install hexo-renderer-ejs –-save$ npm install hexo-renderer-less –-save$ npm install hexo-deployer-git --save$ npm install jshint &amp;&amp; npm install --save-dev jshint$ npm install --global gulp-less &amp;&amp; npm install --save-dev gulp-less$ npm install --global gulp-rename &amp;&amp; npm install --save-dev gulp-rename$ npm install --global gulp-minify-css &amp;&amp; npm install --save-dev gulp-minify-css$ npm install --global gulp-autoprefixer &amp;&amp; npm install --save-dev gulp-autoprefixer$ npm install --global gulp-uglify &amp;&amp; npm install --save-dev gulp-uglify$ npm install --global gulp-jshint &amp;&amp; npm install --save-dev gulp-jshint$ npm install --global jshint-stylish &amp;&amp; npm install --save-dev jshint-stylish$ npm install --global gulp-notify &amp;&amp; npm install --save-dev gulp-notify$ npm install --global gulp-plumber &amp;&amp; npm install --save-dev gulp-plumber$ npm install --global gulp-htmlclean &amp;&amp; npm install --save-dev gulp-htmlclean$ npm install --global gulp-htmlmin &amp;&amp; npm install --save-dev gulp-htmlmin$ npm install --global gulp-rev-append &amp;&amp; npm install --save-dev gulp-rev-append$ npm install --global gulp-sequence &amp;&amp; npm install --save-dev gulp-sequence$ cp D:\\mywork\\blog\\hexo\\themes\\snippet\\gulpfile.js D:\\mywork\\blog\\hexo\\ # 复制 gulpfile.js 到项目根目录$ gulp # 执行打包任务$ vim _config.yml # 配置 snippet 主题 12$ hexo clean &amp;&amp; hexo g # 清空hexo静态文件和缓存，并重新生成静态页$ hexo s # 启动服务，本地预览 TIPS：本地预览http://127.0.0.1:4000。 2.8 禁用评论功能1$ vim D:\\mywork\\blog\\hexo\\scaffolds\\post.md # 修改scaffolds目录下的post.md模板 TIPS：使用 post 方式生成新的文章才会生效。 2.9 启用站内搜索功能123$ cd D:\\mywork\\blog\\hexo # 进入项目根目录$ npm i hexo-generator-json-content@2.2.0 –S # 添加生成索引插件$ vim D:\\mywork\\blog\\hexo\\theme\\snippet\\_config.yml # 修改主题配置_config.yml文件下jsonContent相关参数 2.10 标签插件（写文章时会用到）官方中文文档 3 Google SEO 优化3.1 生成站点地图安装Google站点地图生成插件1$ npm install hexo-generator-sitemap --save _config.yml，添加以下内容：生成和部署1$ hexo g &amp;&amp; hexo d 源码public目录下会有sitemap.xml文件生成 3.2 绑定站点地图进入Google站点控制台https://www.google.com/webmasters/#?modal_active=none点击添加资源使用网址前缀的方式（网域方式只能通过CNAME绑定，dns解析器解析需要时间，可能不会马上生效）下载验证文件并放在源码source目录下按如下方式修改才不会被hexo编译（发布到github上才会保持其内容不变）生成和部署1$ hexo g &amp;&amp; hexo d Google站点控制台点击验证即可添加站点地图由于笔者使用 www.zhechu.cf 域名映射 zhechu.github.io 经过了多次转发，Google无法获取sitemap.xml，需要配置 zhechu.github.io，重复上述步骤即可Google搜索 site:www.zhechu.cf ，若搜索成功，则表示绑定站点地图成功，Google会定时抓取sitemap.xml文件以获取网站最新数据 4 Markdown使用手册Markdown使用手册","categories":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://zhechu.github.io/categories/NodeJS/"}],"tags":[],"keywords":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://zhechu.github.io/categories/NodeJS/"}]}]}